Автор;Имя статьи;Тема;Аннотация;Ссылка на статью;Содержимое
ivansychev;Сбербанк вместе с Goldman Sachs и JP Morgan будет развивать blockchain, на основе которой работает биткойн;Финансы в IT;Технология защиты транзакций blockchain представляет собой распределённую и открытую базу данных, которая не позволяет изменять отдельные записи. Blockchain обеспечивает безопасность криптовалют, включая биткойны. Сбербанк для развития сервисов на основе blockchain планирует присоединиться консорциуму R3, в который входят девять крупнейших банков мира, включая Goldman Sachs, Barclays, Credit Suisse и JP Morgan.;/ru/news/t/297204/;Технология защиты транзакций blockchain представляет собой распределённую и открытую базу данных, которая не позволяет изменять отдельные записи. Blockchain обеспечивает безопасность криптовалют, включая биткойны. Сбербанк для развития сервисов на основе blockchain планирует присоединиться консорциуму R3, в который входят девять крупнейших банков мира, включая Goldman Sachs, Barclays, Credit Suisse и JP Morgan. «Цепочка блоков транзакций» — выстроенная по определенным правилам цепочка из формируемых блоков транзакций, специальных структур для записи транзакций в системе Биткойн и аналогичных криптовалютах. Каждый из блоков содержит информацию о предыдущем блоке, а все блоки можно выстроить в цепочку и перепроверить историю о всех операциях с биткойнами. Blockchain не позволяет умышленно изменять отдельные записи, так как такой блок не будет признан достоверным. Nasdaq планирует использовать blockchain для упрощения верификации транзакций, ускорения процесса торговли и повышения надежности. В России первой организацией, планирующей использовать технологию blockchain, стала Qiwi — в том числе для выпуска криптовалюты «битрубль». Крупные мировые банки, входящие в консорциум R3, стремятся развивать сервисы на основе этой технологии для обеспечения безопасности и для снижения зависимости от международной межбанковской системы SWIFT — «Society for Worldwide Interbank Financial Telecommunications», членами которой являются более десяти тысяч организаций. Теоретически технология поможет снять риски Сбербанка, связанные с возможным отключением от SWIFT в случае санкций. Мы очень внимательно взаимодействуем с этим консорциумом и смотрим, в какую сторону движется эволюция технологии blockchain. Сейчас мы смотрим документацию (консорциума), целесообразность, и я не исключаю, что мы в этот консорциум войдем, хотя окончательно решение еще не принято. Первый заместитель председателя правления Сбербанка Лев Хасис в интервью изданию «Коммерсант»Ее основное отличие от других баз данных — методы защиты, которые практически исключают возможность подмены отдельных записей. Важным элементом защиты blockchain является распределенность и открытость данных. Например, база данных биткоина, в основе которого лежит blockchain, хранится в открытом доступе. Заместитель генерального директора Zecurion Александр Ковалев
marks;Глава Минкомсвязи считает, что технология Blockchain может послужить на благо страны;Криптовалюты;"Министр связи и массовых коммуникаций РФ Николай Никифоров считает, что технологию Blockchain можно использовать в интересах государства. Такое мнение глава Минкомсвязи высказал в кулуарах Российского форума «Интернет-экономика», пишет ТАСС.

«Технология blockchain как новый подвид технологии очень интересна, потому что она может использоваться во многих сферах, необязательно в области криптовалюты. Вообще надо посмотреть как в интересах государства с точки зрения защиты тех или иных моментов данную технологию можно использовать», — сообщил министр.";/ru/news/t/388427/;Министр связи и массовых коммуникаций РФ Николай Никифоров считает, что технологию Blockchain можно использовать в интересах государства. Такое мнение глава Минкомсвязи высказал в кулуарах Российского форума «Интернет-экономика», пишет ТАСС.«Технология blockchain как новый подвид технологии очень интересна, потому что она может использоваться во многих сферах, необязательно в области криптовалюты. Вообще надо посмотреть как в интересах государства с точки зрения защиты тех или иных моментов данную технологию можно использовать», — сообщил министр.Он также добавил, что Минкомсвязи внимательно следит за развитием технологии blockchain, а также своими силами проводит разного рода исследования. «Надо смотреть на горизонт 5-10 лет, как эта технология может помочь народному хозяйству, взаимоотношениям государства и человека, там много разных задумок», — комментирует ситуацию министр.Ранее о намерении развивать сервисы на основе этой технологии заявил Сбербанк. Эта организация собирается стать членом международного консорциума R3, куда уже входят Goldman Sachs, JP Morgan, Credit Suisse и Barclays. В той либо иной форме криптовалюты и технологию Blockchain собираются использовать и другие отечественные компании, в частности, Яндекс и Qiwi.
kristencarter7519;Top 10 Blockchain Development Companies To Partner With In 2020-21;Разработка мобильных приложений *Разработка под Android *Развитие стартапа Офисы IT-компаний Криптовалюты;"Global Blockchain solutions spending is expected to surpass $15.9 billion in 2023. At the same time, this expenditure was $1.5 billion in 2018. Indeed, this is a huge influx in global spending, which depicts how companies will be investing more in blockchain solutions and blockchain-based mobile apps. 

In this group, the major contribution will be seen from industries including finance, banking, healthcare, agriculture, and more. Amidst, outsourcing Blockchain development companies will also gain prominent attention. 

If you are thinking about having Blockchain integration within your business solution, you must be having several questions in your mind, such as: what are the benefits of blockchain? Which are the best companies to hire? And more.";/ru/post/516770/;"Global Blockchain solutions spending is expected to surpass $15.9 billion in 2023. At the same time, this expenditure was $1.5 billion in 2018. Indeed, this is a huge influx in global spending, which depicts how companies will be investing more in blockchain solutions and blockchain-based mobile apps. In this group, the major contribution will be seen from industries including finance, banking, healthcare, agriculture, and more. Amidst, outsourcing Blockchain development companies will also gain prominent attention. If you are thinking about having Blockchain integration within your business solution, you must be having several questions in your mind, such as: what are the benefits of blockchain? Which are the best companies to hire? And more.Don't ponder over this! As after reading this blog, you will have all the essential knowledge to begin blockchain solution development. Benefits of Blockchain Solution Development Blockchain has been considered a game-changing technology in the 21st century that provides incredible benefits to businesses. Solutions and mobile apps infused with blockchain will be powered with a robust security architecture that will provide users immense data safety and freedom from authoritative control. Let's see some benefits of outsourcing blockchain development service to understand the importance of these applications. 1) Impeccable Transparency & SecurityWhile almost every business transaction and record storage is digital, breaches are common. As a distributed ledger system, blockchain infuses a consensus system agreed by every participant. All users share the same documentation, and If you want to change any record, alteration of all subsequent records is required, which implies greater transparency of records and transactions. In short, data available in the blockchain system or application is more accurate, transparent, secured, and consistent. Altogether, there will be no third-party permission or authority to manage data storage. 2) Increased TractabilityIf your business includes supply chain or trade of product, tracing can be the most complex process. Blockchain enables a system that records each product from manufacturing to the final store. It verifies each asset destination and arrival to avert discrepancies. The history of data will improve the authenticity of assets and prevent fraud. 3) More Speed And Efficiency For recording data, a primitive approach can be more time-consuming and prone to human errors. Altogether, it requires third-party intervention. While blockchain prevents the need for multiple data storage and brings in a digital ledger system that provides access to the same information to all users. It will offer greater speed to data access and improve organizational efficiency. Apart from these, blockchain solutions offer many more benefits such as high-grade & futuristic solutions, more trust in systems & application, and much more. Moreover, fund transfer through apps will be more secure and faster to enable businesses to offer the best quality services. So, do you want to infuse blockchain within your business application? You need to consult a blockchain development company expert in creating business solutions as per modern users' needs. However, finding a company with experience and expertise for blockchain-based mobile or software development. To help you, I have enlisted top blockchain development companies by considering reviews and ratings over different online channels like clutch and Good firms. Here are the parameters I have considered while picking up these best blockchain application development companies for 2020-21 to hire for developing a unique visionary platform with a futuristic approach. Experience in blockchain development (more than five years)Per hour price Reviews and ratings over trusted business listing sites and forums Blockchain software developed Expertise in software developmentEstimated revenue gained in previous years If you are striving to secure a blockchain software application for your business or want to infuse this technology in your business solution, you must pick a deft blockchain development company with the required experience and a team of developers with a futuristic vision. Top Outsourcing Blockchain Development Companies In 2020 For Creating A Futuristic Application 1) ValueCoders Valuecoders is a reputed and top Blockchain development company in India, delivering top-notch solutions to diverse industry verticals, including healthcare, supply chain, IT, and more. It helps startups and enterprises deploy blockchain technology in their business to infuse security, transparency, and productivity. The company created high quality & scalable decentralized software applications suitable to business structure and customer-centric economy. As an innovation-driven blockchain development company, it delivers solutions like Smart Contacts, Mining software programs, Crypto Wallets, ICOs, and more. Being an innovation partner in the industry, the company has delivered the following software solutions: Lipchain Blockchain Solution, Titanium Thread Hyper Ledger and more. For creating a visionary product, you need to hire a blockchain development company with required knowledge and experience in order to complete your project on time. This company ensures agile development through strategic planning and MVP approach to help it’s clients.Price Per Hour: Starting $15/hr Employee Strength: 400+Rating: 5.0/5.0Estimated Yearly Revenue: $3.89M2) SoluLab Being a leading blockchain, IOT, and mobile app development company, it caters solutions with unmatched innovation. As it says, It works to add a heart to technology, which makes it a unique team with great endeavors. The company understands your business, objectives, pain points, and priorities. After a complete brainstorming session, It helps businesses to map out the existing workflows and future goals. With 6+ years of diverse experience in delivering one-of-a-kind software solutions, it offers solutions with great designs & features. Its vision is to transform the dreams of enterprises and bring them into reality. Thus, it caters unique solutions as per entrepreneurs' needs and vision. Applications developed by companies are CAM-Blockchain, Versafit, Aladin-Blockchain, and Plotos. Price Per Hour: Starting $25/hrEmployee Strength: 150+Rating: 4.9/5.0Estimated Yearly Revenue: $1.9M3) Espeo SoftwareEspeo is a well known digital consultancy with an impeccable international presence. The company has a worldwide team locating in different locations that work seamlessly and value efficiency, transparent communication, and innovation. Being headquartered in Poland and founded in Finland, it creates and designs top-notch blockchain solutions for its clients through exceptional industry knowledge and strong technical skills. Throughout the project, the company offers complete support and stands beside its clients and delivers best-in-class collaboration. Remember, you need to partner with an expert blockchain development company which can understand your idea and customers and deliver a unique solution. Blockchain projects created by the company are: CloseCross, MakerDao, Gabrotech, and GHP. Price Per Hour: Starting $50/hr Employee Strength: 200+ Rating: 4.7/5.0 Estimated Yearly Revenue: $8M4) AdoriaSoft AdoriaSoft excels as a science-oriented company with a math driven approach. Being an creative blockchain development company, it delivers solutions with impeccable security and features. The company has considerable experience in cryptography and information security.It works on a team augmentation model; it means they can integrate IT professionals in their clients' existing teams for creating business-oriented solutions. Being an experienced blockchain development partner, they develop the project with an agile approach and ensure to implement technologies effectively. The company follows the latest technology trends and meets its clients' expectations. Here are the blockchain projects developed by AdoriaSoft: Encrypted cloud storage, Privileged Access Management, Facerig, Token.io, Save Pharmaceutical, Agopolis, and more. Price Per Hour: Starting $50/hrEmployee Strength: 50+Rating: 4.8/5.0Estimated Yearly Revenue: N/A5) ExyteBeing one of the top blockchain development companies, it has earned a significant name in the market. The company incorporates an innovation-oriented team having expertise in mobile, web, and software application development. It caters a comprehensive range of services, including native and cross-platform application development and deploys technologies like virtual reality, Artificial Intelligence, Augmented reality, Blockchain, and more. Here are blockchain solutions crafted by Exyte: Trace, Vimerum, Micro Skills, Delta Airlines, PWC, Monsanto, Bayer. Price Per Hour: Starting $25/hrEmployee Strength: 50+Rating: 5.0/5.0Estimated Yearly Revenue: N/A6) S-ProS-PRO is one of the best innovation-driven blockchain development companies, helping startups to develop software programs that enable businesses & process transformation. The company delivers business-oriented solutions that digitize their process according to the need of a customer-centric economy. It has already partnered with notable growth-oriented companies, including Founder Institute, BCCS Cluster, Sente.Link, and more. With a team of 150+ years of talented tech enthusiasts, it caters best in class development services with a sophisticated personal approach. The R&D experts at S-PRO are engaged in finding the best possible usage of blockchain technology and deliver each product with a different vision & goal. Blockchain platforms created by companies are App for cryptocurrency payment & investment, Platform for crypto trading, Blockchain-powered Fintech solution, and more. Price Per Hour: Starting $25/hrEmployee Strength: 150+Rating: 4.9/5.0Estimated Yearly Revenue: N/A7) Somish Blockchain LabSomish is a blockchain software design & development company based in India and delivers automation services using the latest technologies. It has more than 10 years of expertise in delivering the best software design, development & re-engineering services. It is catering services to industries' top clients with innovation, quality, and high-quality applications as per the need of the modern customer-centric market. Platforms developed by Somish are Govblocks, Plotus, VerifyChain, EdgeInvest, Konkrete.Price Per Hour: Starting $50/hrEmployee Strength: 50+Rating: N/AEstimated Yearly Revenue: N/A8) PixelPlex Being one of the award-winning software and blockchain development companies, it is delivering the best solutions according to the needs of modern customers and users. It strives to help businesses to serve services that create the difference. With a creative and vision-oriented team, the company has served more than 300 businesses all across the world that admire the company for cooperation and assistance. With a comprehensive background in artificial intelligence, IOT, cybersecurity, and blockchain, PixelPlex delivers solutions infused with innovation and cutting-edge technology. For its exceptional work and assistance, the company is continuing to gain more appreciation and recognition. Blockchain platforms developed by it are Blockchain Ecosystem & Smart Contract Protocol, Intel IoT App, AIRA, and more.Price Per Hour: Starting $50/hrEmployee Strength: 250+Rating: 4.9/5.0Estimated Yearly Revenue: $3M9) MixBytesThe company has the best blockchain engineering talent engaging in creativity & robustness into each application they create. Its team offers full-fledged services, including design, development, quality assurance testing, launch, support, and more. The is an admired partner of ambitious startups and established enterprises and has delivered decentralized solutions for a diverse industry sphere. The company creates cryptographic protocols, public and private blockchain solutions, consensus algorithms, smart contracts, and more. Being one of the renowned blockchain development companies, it has catered blockchain solutions: Aragon One, Smartz, POA-An ethereum based smart contract, and more. Price Per Hour: Starting $50/hrEmployee Strength: 50+Rating: 5.0/5.0Estimated Yearly Revenue: N/A10) Bitdeal Bitdeal is one of the most reliable blockchain development companies in 2020 for all kind of decentralized application development. It is potent enough to support all kinds of blockchain startups, including crypto exchange, mining, ICO, smart contracts, and more. The significant focus of the company is to infuse this technology in business verticals with ease and simplify the risks in cryptocurrency trading. Bitcoin Exchange Script is the major product of Bitdeal that develops a robust trading environment to trade bitcoin. It offers comprehensive support in ICO, mining, smart contract, and other cryptocurrency-based businesses. Applications developed by Bitdeal are Blockchain In Food supply chain, Blockchain In solar technology, Blockchain in pregnancy tracking, Blockchain In Agriculture, and more. Price Per Hour: Starting $25/hrEmployee Strength: 50+Rating: 5.0/5.0Estimated Yearly Revenue: N/AWrapping Up Blockchain is the security future in the IT industry, while cryptocurrency is a base to new financial settings. Clearly, using blockchain technology in your business solution and boost revenue generation. And! If you have a unique app idea for a blockchain solution, you must consult a blockchain company offering mobile app development services to bring it into reality."
discovan;You Do Not Need Blockchain: Eight Well-Known Use Cases And Why They Do Not Work;Блог компании Ростелеком-Солар Децентрализованные сети Информационная безопасность *Бизнес-модели Интернет вещей;"People are resorting to blockchain for all kinds of reasons these days. Ever since I started doing smart contract security audits in mid-2017, I’ve seen it all. A special category of cases is ‘blockchain use’ that seems logical and beneficial, but actually contains a problem that then spreads from one startup to another. I am going to give some examples of such problems and ineffective solutions so that you (developer/customer/investor) know what to do when somebody offers you to use blockchain this way.
Disclaimers

The described use cases and problems occur at the initial stage. I am not saying these problems are impossible to solve. However, it is important to understand which solutions system creators offer for particular problems.
Even though the term ‘blockchain use’ looks strange and I am not sure that blockchain can be used for anything other than money (Bitcoin), I am going to use it without quotes.

1. Supply chain management
Let’s say you ordered some goods, and a carrier guarantees to maintain certain transportation conditions, such as keeping your goods cold. A proposed solution is to install a sensor in a truck that will monitor fridge temperature and regularly transmit the data to the blockchain. This way, you can make sure that the promised conditions are met along the entire route.";/ru/company/solarsecurity/blog/441690/;"People are resorting to blockchain for all kinds of reasons these days. Ever since I started doing smart contract security audits in mid-2017, I’ve seen it all. A special category of cases is ‘blockchain use’ that seems logical and beneficial, but actually contains a problem that then spreads from one startup to another. I am going to give some examples of such problems and ineffective solutions so that you (developer/customer/investor) know what to do when somebody offers you to use blockchain this way.DisclaimersThe described use cases and problems occur at the initial stage. I am not saying these problems are impossible to solve. However, it is important to understand which solutions system creators offer for particular problems.Even though the term ‘blockchain use’ looks strange and I am not sure that blockchain can be used for anything other than money (Bitcoin), I am going to use it without quotes.1. Supply chain managementLet’s say you ordered some goods, and a carrier guarantees to maintain certain transportation conditions, such as keeping your goods cold. A proposed solution is to install a sensor in a truck that will monitor fridge temperature and regularly transmit the data to the blockchain. This way, you can make sure that the promised conditions are met along the entire route.The problem here is not blockchain, but rather sensor, related. Being part of the physical world, the sensor is easy to fool. For example, a malicious carrier might only cool down a small fridge inside the truck in which they put the sensor, while leaving the goods in the non-refrigerated section of the truck to save costs.I would describe this problem as:Blockchain is not Internet of Things (IOT).We will return to this statement a few more times. Even though blockchain does not allow for modification of data, it cannot ensure such data is correct. The only exception is on-chain transactions, when the system does not need the real world, with all necessary information already being within the blockchain, thus allowing the system to verify data (e.g. that an address has enough funds to proceed with a transaction).Applications that submit information to a blockchain from the outside are called “Oracles” (see article ‘Oracles, or Why Smart Contracts Haven’t Changed the World Yet?’ by Alexander Drygin). Until a solution to the problem with oracles is found, any attempt at blockchain-based supply chain management, like the case above, is as pointless as trying to design a plane without first developing a reliable engine.I borrowed the fridge case from the article ‘Do you Need Blockchain’ by Karl W?st and Arthur Gervais. I highly recommend reading this article and paying particular attention to the following diagram:2. Object authenticity guaranteeEven though this case is similar to the previous one, I would like to single it out as it is presented in a different wrapper.Say we make unique and expensive goods, such as watches, wines, or cars. We want our customers to be absolutely sure they are buying something made by us, so we link our wine bottle to a token supported by blockchain and put a QR code on it. Now, every step of the way (from manufacturer, to carrier, to store, to customer) is confirmed by a separate blockchain transaction and the customer can track their bottle online.However, this system is vulnerable to a very simple threat: a dishonest seller can make a copy of a real bottle with a token, fill it with wine of lower quality, and either steal your expensive wine or sell it to someone who does not care about tokens. Why is it so easy? That’s right! Because...Blockchain is not IoT!A bottle is a physical object, and as such can be faked, unlike a digital signature.3. Statement authenticity guaranteeLet’s take university diploma authenticity as an example. In this case, we need to verify the genuineness of the statement (“Peter graduated from the university”), rather than a physical object. To make sure the diploma is authentic and the date of issue is accurate, we need to check a digital signature and a time stamp.Digital signatures are great, some even call the asymmetric cryptography they are based on ‘the greatest invention of the 20th century’. But let’s not confuse it with blockchain. Indeed, digital signatures existed and served us well before blockchain was around. Be careful! Today, digital signatures are often sold as blockchain. Perhaps a digital signature is all you really need and blockchain does not really suit your requirements.Timestamping is closer to blockchain. In fact, blockchain itself is the most reliable timestamping method. You don’t need to invent anything: just put a hash of your data into Bitcoin blockchain.Is it a good idea to put a hash of student diploma digitally signed by several professors on Bitcoin blockchain? Yes. However, it is important not to screw this system up by using centralized verification through a website or an app, which will be a single point of failure.4. VotingWhen it comes to using blockchain for voting, we need to be clear about what problem we want to solve.Forgery of vote/voter authentication. To tackle this problem, we need digital signature rather than blockchain. The main issue here is a private key: where to get it from and how to store it. I won’t explain why any system in which a key is generated anywhere other than on the end user’s device is broken by design. However, on top of this, it is also important to have open source and properly audited key generating software, third-party hardware (smartphone being the simplest option), and a user who can handle a private key.While a system developer can address the first two issues, the third is much more difficult. Bitcoin may actually help us learn how to deal with keys. Indeed, losing a password to your social media account or your vote is one thing, but losing a key to your own money is another story.Yet again, it is oracle that links a public key to a particular person if we need it for the voting process.Publicly visible vote counting. It would be safe to assume that, say, Ethereum smart contracts are perfect for this issue, as they allow everybody to see how many votes any particular candidate received. However, in this case the level of openness may be too much, as we can see how each and every person votes, and thus can influence them. Although the system may be built in such a way that every vote is only visible to the person who cast it, there is another more complicated challenge: as long as voters are technically able to bring evidence of their voting choice, they could still be put under pressure.UPD: Colleagues assure me that there is a solution: incoercible encryption.And here, once again, we need oracles to check whether there have been any extra votes from nonexistent voters.5. Proof of authorshipLet’s say Artist A wants to use blockchain to register that a certain painting is his. He takes a photo of it, puts the photo hash in blockchain, and then uploads the photo to a blog. Now, if Artist B claims that the painting belongs to him, Artist A can easily prove his authorship by showing the photo and hash.There are two potential issues in this case:First, Artist B can say he did not know about blockchain and thus could not use it to register his authorship. Therefore, this procedure can only work if it becomes common practice.Second, Artist B could break into Artist A’s studio, take a photo of the painting, and place the hash in blockchain before Artist A.The reason is that…Blockchain is not IoT!Yet, in general, this use case makes sense. However, it does not require anything other than Bitcoin's blockchain.Note: I am talking about proof of authorship only, as the concept of intellectual property is nonsense in my opinion: ‘Against Intellectual Property’ by Stephan Kinsella.6. Land registryAnother proposed case is linking blockchain-based tokens to land ownership. There are at least two issues with this.Enforcer actions. While a bottle/watch/car can be handed over peer-to-peer (P2P), land ownership and transfer must be registered by a regulatory authority, which can always physically visit your land and enforce its will. What will happen to a blockchain record if the regulatory authority insists that you should transfer your land? The first option: blockchain record still specifies you as a land owner, which is not true anymore; the second option: the regulatory authority can make its own record and thus rewrite yours, which means that blockchain doesn’t work. This is a critical point since blockchain is also promoted as a tool protecting you against the fraudulent activities of both the regulatory authorities and any individual officials.Centralized development and support. Now, who is going to develop such a system and support nodes? If the regulatory authority itself or its counterparty is to do the job, then such a system won’t be decentralized. A decentralized protocol plus centralized development equals a centralized protocol.Besides, each time somebody offers you blockchain, ask yourself:Can we use a distributed database instead?If the answer is ‘Yes’, why go for blockchain at all? Indeed, blockchain is slower and more resource-intensive. Plus, specialists in database development and integration are much less expensive and easier to find, their work product is easier to check, and system support is simpler too.Given all these challenges, I believe a distributed database to be a much better choice for land registry today, even though it definitely needs to become more reliable and open (see ‘Blockchain as a Trigger’ section).Indeed, it looks like this particular use case has already become a reality. Bitfury recently announced the launch of a blockchain land registry system built on the Exonum framework and is set to do the same in Ukraine and Moldova. Strangely enough, I could not find any technical details of this case, meaning that for some reason Bitfury is in no rush to boast of it.7. Interbank transfersThis case is a good one according to the scheme from ‘Do you need blockchain?’ It involves a number of parties that do not trust each other, without any trusted third party being engaged. Although Bitcoin can be used here, banks are unlikely to make their mutual payments publicly visible. Therefore, we would offer a private blockchain where only banks themselves can input data, support nodes, and verify the transactions of all other parties.In terms of functionality, does this system differ from a distributed database with access control? Yes, it does, but only when it comes to a disagreement between the parties. Here, the question is: will banks agree to a consensus offered by the system or will they appeal to a court? If banks can choose the second option (i.e. they have never signed an agreement to unconditionally accept all decisions offered by the system) then this system makes no sense.Plus, this entire case will be nonsensical if regulatory bodies prohibit or restrict the use of such systems or instruct the courts to refuse system data.8. Token for token’s sakeYes, that’s right! I’m actually writing about ICO in the year 2019. To prove its continued relevance, let me just point out that on January 28, BitTorrent had a successful ICO.What I mean by ‘Token for token’s sake’ is that some startups issue tokens and say they entitle you to a share in their companies/ profits/ split-fee options. The problem is:Blockchain is not IoT!Unlike venture capital investors or regulatory bodies, blockchain won’t hold a startup accountable or responsible to their investors. A promise in the form of a token alone does not oblige a company's founders to do anything — something we saw many times during the ICO boom (remember Lambos?). In this respect, an ICO is more similar to crowd funding than an IPO.Although pro decentralized institutions and against regulatory control, I must admit there are almost no such systems in this field yet, which means you must either go for existing tools or trust company founders.Now, let me describe some promising use cases.Blockchain as a triggerOddly enough, even non-working cases may be useful. Say a corporation uses a long-outdated process/system. Instead of opting for a normal and obvious solution, management decides to invest in hype (blockchain/big data/AI/IoT) to gain a lead.That’s when a savvy yet responsible intrapreneur can offer a proper system design, marketing it as blockchain. Depending on the situation, blockchain can either give certain advantages or be not the case at all living on slick presentation slides only.Hint: If you are offered the chance to use blockchain, make sure it is actually blockchain. However, even if it is not, it could still be a sensible offer.MoneyBlockchain is perfect for handling money, primarily because it was created exactly for this purpose. Blockchain records and verifies statements like ‘Party A owned X amount; Party A transferred X amount to Party B; Party B owns X amount’ as all previous similar statements were recorded within the same blockchain.In the second part of the series of his posts on BitTorrent Lessons for Crypto titled ‘If You’re Not Breaking Rules You’re Doing It Wrong’, Simon Morris says that the original objective of decentralization is to break the rules, as those who observe those rules will try to stop you.Bitcoin meets this requirement perfectly, as it breaks the old rule according to which only the government issues money, defines issuing procedures, and decides which transaction is valid and which is not.More importantly, I think Bitcoin performs a specific role: the transfer of value that existed long before the technology in an easy to understand manner (see ‘Shelling Out: The Origins of Money’ by Nick Szabo). At the same time, the majority of blockchain startups have to explain from the very beginning which task they solve and why — something which is nonsensical even for traditional startups that usually look for customers, test hypotheses, and try to stay in sync with the market, i.e. solve existing problems, rather than invent new ones.At any rate, Bitcoin is the only working blockchain application so far. That is why, at the beginning of my article, I questioned the relevance of the term ‘blockchain use’.Note: I do not include cases in which blockchain is not used by end users, but rather by another blockchain that is, in turn, used by decentralized exchanges where tokens of the third blockchain are listed. Who knows, the industry may actually manage to pull itself out of the swamp this way.Smart contractsLet’s be honest: nobody really knows what smart contracts are and what they are for, as this concept is still in its infancy. Ethereum is truly ahead of the curve. By the time decentralized Bitcoin came into play, people already knew and were used to e-money; by the time we got decentralized smart contracts running on Ethereum, we were still struggling to handle hard-copy contracts, while centralized smart contracts are simply non-existent yet. We can try and jump two steps at once, but to do so we need time and a viable concept.Personally, I believe that smart contracts will find their niche. That’s why I am working in the field already. However, this is my personal belief, which has not been neither confirmed nor refuted yet.More examplesThe examples above are only the ones I could remember and summarize. I might have forgotten or simply haven’t heard of some cases. So, I will be grateful if you give more examples in the comments below. Maybe I will continue this article."
KosToZyB;Написание blockchain менее чем за 200 строк кода на Go;Go *;"Привет, Хабр! Представляю вашему вниманию перевод статьи ""Code your own blockchain in less than 200 lines of Go!"".

Данный урок является хорошо адаптированным постом про простое написание blockchain на Javascript. Мы портировали его на Go и добавили дополнительных фич, таких как просмотр цепочек в браузере.";/ru/post/347930/;"Привет, Хабр! Представляю вашему вниманию перевод статьи ""Code your own blockchain in less than 200 lines of Go!"".Данный урок является хорошо адаптированным постом про простое написание blockchain на Javascript. Мы портировали его на Go и добавили дополнительных фич, таких как просмотр цепочек в браузере.Примеры в уроке будут основываться на данных сердцебиения. Мы ведь медицинская компания. Для интереса, вы можете подсчитать свой пульс (кол-во ударов в минуту) и учитывать это число во время учебного курса.Почти каждый разработчик в мире слышал про blockchain, но большинство до сих пор не знают, как это работает. Многие слышали только про биткоин, смарт-контракты. Данный пост является попыткой развеять слухи о blockchain, помогая Вам написать свой собственный blockchain на Go менее чем в 200 строк кода! В конце данного урока Вы сможете запустить и записать данные в blockchain локально, а так же просмотреть это в браузере.Есть ли более хороший способ узнать о blockchain, чем создать свой собственный?Что вы сможете сделатьСоздать свой собственный blockchainПонять, как работает хэширование в сохранение целостности цепочки блоковУвидеть, как добавляются новые блокиУвидите, как разрешаются коллизии, когда несколько узлов генерируют блокиСоздадите просмотр вашего blockchain в браузереДобавите новые блокиПолучите базовые знания о blockchainЧто вы не сможете сделатьЧто бы этот пост оставался простым, мы не будем рассматривать более совершенные концепции proof of work и proof of stake. Сетевое взаимодействие будет моделироваться, что бы Вы могли просматривать Ваш blockchain и просматривать добавленные блоки. Сетевая работа будет зарезервированная для будущих постов.Давайте начнем!УстановкаПоскольку мы собираемся писать код на Go, мы предполагаем, что у вас уже есть опыт разработки на нем. После установки мы так же будем использовать следующие пакеты:go get github.com/davecgh/go-spew/spewSpew позволяет нам красиво выводить структуры и слайсы в консоль.go get github.com/gorilla/muxGorilla/mux это популярный пакет для написания обработчиков запросов.go get github.com/joho/godotenvGotdotenv позволяет нам читать из файла .env который лежит в корне каталога, поэтому нам не придется задавать в нашем коде такие параметры, как http порт.Давайте создадим наш .env файл в корне каталога, который будет определять порт на котором мы будем слушать HTTP запросы. Просто добавьте строку в файл:ADDR=8080Создайте файл main.go. Вся реализация будет в этом файле и будет содержать менее 200 строк кода.ИмпортыИмпорты пакетов, вместе с объявлением пакета:package mainimport (    ""crypto/sha256""    ""encoding/hex""    ""encoding/json""    ""io""    ""log""    ""net/http""    ""os""    ""time""    ""github.com/davecgh/go-spew/spew""    ""github.com/gorilla/mux""    ""github.com/joho/godotenv"")Модель данныхДавайте определим структуру каждого из наших блоков, которые представляют собой blockchain. Чуть ниже мы объясним для чего необходимы все эти поля:type Block struct {    Index     int    Timestamp string    BPM       int    Hash      string    PrevHash  string}Каждый блок содержит данные, которые будут записаны в blockchain и представляет собой событие каждого замера пульса.Index — индекс записи данных в blockchainTimestamp — временная метка, когда данные записываютсяBPM — удары в минуту. Это частота вашего пульсаHash — идентификатор SHA256, идентифицирующий текущую записьPrevHash — идентификатор SHA256, идентифицирующий предыдущую запись в цепочкеДавайте объявим наш blockchain, который представляет собой просто слайс структур:var Blockchain []BlockИтак, как хеширование используется в блоках и в blockchain? Мы используем хэши для определения и сохранения блоков в правильном порядке. Благодаря тому, что поле PrevHash в каждом блоке ссылается на поле Hash в предыдущем блоке (т.е. они равны), мы знаем правильный порядок блоков.Хэширование и создание новых блоковЗачем нам хэшировать? Мы получаем хэш по двум основным причинам:Чтобы сэкономить место. Хэши производятся из всех данных, находящихся в блоке. В нашем случае есть только несколько блоков данных, но представьте, что у нас есть данные из сотен, тысяч или миллионов предыдущих записей. Намного эффективнее хэшировать эти данные в одну строку SHA256 и хэшировать хеши, чем копировать все данные предыдущих блоков снова и снова.Сохранение целостности цепочки. Сохраняя предыдущие хэши, как мы делаем на диаграмме выше, мы можем гарантировать, что блоки в blockchain находятся в правильном порядке. Если злоумышленник захочет присоединитьсяФ и манипулировать данными (например, изменить сердечный ритм, что бы исправить цены на страхование жизни), хэши начнут изменяться и все будут знать, что цепочка ""сломана"" и все будут знать, что доверять этой цепочки нельзя.Давайте напишем функцию, которая возьмет наши данные Block и создаст для них хэш SHA256.func calculateHash(block Block) string {    record := string(block.Index) + block.Timestamp + string(block.BPM) + block.PrevHash    h := sha256.New()    h.Write([]byte(record))    hashed := h.Sum(nil)    return hex.EncodeToString(hashed)}Функция calculateHash объединяет в одну строку Index, Timestamp, BPM, PrevHash из структуры Block, которая является аргументом функции и возвращается все в виде строкового представления хэша SHA256. Теперь мы можем сгенерировать новый блок со всеми необходимыми элементами с помощью новой функции generateBlock. Для этого нам нужно будет передать предыдущий блок, что бы мы могли получить его хэш и индекс, а так же передадим новое значение частоты пульса BPM.func generateBlock(oldBlock Block, BPM int) (Block, error) {    var newBlock Block    t := time.Now()    newBlock.Index = oldBlock.Index + 1    newBlock.Timestamp = t.String()    newBlock.BPM = BPM    newBlock.PrevHash = oldBlock.Hash    newBlock.Hash = calculateHash(newBlock)    return newBlock, nil}Обратите внимание, что текущее время автоматически записывается в блок через time.Now(). Так же обратите внимание, что была вызвана функция calculateHash. В поле PrevHash скопировано значение хэша из предыдущего блока. Index просто увеличивается на единицу от значения из предыдущего блока.Проверка блокаТеперь нам нужно написать функционал для проверки валидности предыдущих блоков. Мы делаем это проверяя Index, что бы убедиться, что они увеличиваются так, как это ожидается. Мы так же проверяем, что бы PrevHash действиетльно совпадал с Hash предыдущего блока. И наконец, мы повторно вычисляем хэш текущего блока, что бы убедиться в его корректности. Давайте напишем функцию isBlockValid, которая выполняет все эти действия и возвращает bool значение. Функция вернет true, если все проверки пройдут верно:func isBlockValid(newBlock, oldBlock Block) bool {    if oldBlock.Index+1 != newBlock.Index {        return false    }    if oldBlock.Hash != newBlock.PrevHash {        return false    }    if calculateHash(newBlock) != newBlock.Hash {        return false    }    return true}Что, если мы столкнемся с проблемой, когда два узла нашей blockchain экосистемы добавили блоки в свои цепочки, и мы получили их оба. Какой из них мы выберем, как правильный источник? Мы выбираем наиболее длинную цепь. Это классическая проблема в blockchain.Итак, давайте убедимся, что новая цепочка, которую мы принимаем, длиннее текущей цепи. Если это так, мы можем перезаписать нашу цепочку новой, у которой есть новый блок или блоки.Мы просто сравним длину срезов цепей:func replaceChain(newBlocks []Block) {    if len(newBlocks) > len(Blockchain) {        Blockchain = newBlocks    }}Если у Вас получилось, то можете похлопать себя по спине! Мы описали каркас функционала для нашего blockchain.Теперь нам нужен удобный способ просмотра нашего blockchain и запись в него, в идеале в браузере, что бы мы могли похвастаться друзьям!Web ServerМы предполагаем, что вы уже знакомы с тем, как работают веб-серверы, и у вас есть немного опыта работы на Go.Используем пакет Gorrila/mux, который загрузили ранее. Создадим функцию run для запуска сервера и вызовем ее позже.func run() error {    mux := makeMuxRouter()    httpAddr := os.Getenv(""ADDR"")    log.Println(""Listening on "", os.Getenv(""ADDR""))    s := &http.Server{        Addr:           "":"" + httpAddr,        Handler:        mux,        ReadTimeout:    10 * time.Second,        WriteTimeout:   10 * time.Second,        MaxHeaderBytes: 1 << 20,    }    if err := s.ListenAndServe(); err != nil {        return err    }    return nil}Обратите внимание, что порт конфигурируется из вашего .env-файла, который мы создали ранее. Вызовем метод log.Println для вывода в консоль информации о запуске сервера. Мы настраиваем сервер и вызываем ListenAndServe. Обычная практика в Go.Теперь нам нужно написать функцию makeMuxRouter, которая будет определять наши обработчики. Для просмотра и записи нашего blockchain в браузере нам хватит двух простых роутов. Если мы отправляем GET запрос на localhost, то мы просматриваем нашу цепочку. Если отправляем POST запрос, то мы можем записывать данные.func makeMuxRouter() http.Handler {    muxRouter := mux.NewRouter()    muxRouter.HandleFunc(""/"", handleGetBlockchain).Methods(""GET"")    muxRouter.HandleFunc(""/"", handleWriteBlock).Methods(""POST"")    return muxRouter}Обработчик GET запроса:func handleGetBlockchain(w http.ResponseWriter, r *http.Request) {    bytes, err := json.MarshalIndent(Blockchain, """", ""  "")    if err != nil {        http.Error(w, err.Error(), http.StatusInternalServerError)        return    }    io.WriteString(w, string(bytes))}Мы будем описывать blockchain в формате JSON, который можно будет просматривать в любом браузере по адресу localhost:8080. Вы можете задать порт в файле .env.POST запрос немножко сложнее и нам понадобится новая структура сообщений Message.type Message struct {    BPM int}Код для обработчика записи в blockchain.func handleWriteBlock(w http.ResponseWriter, r *http.Request) {    var m Message    decoder := json.NewDecoder(r.Body)    if err := decoder.Decode(&m); err != nil {        respondWithJSON(w, r, http.StatusBadRequest, r.Body)        return    }    defer r.Body.Close()    newBlock, err := generateBlock(Blockchain[len(Blockchain)-1], m.BPM)    if err != nil {        respondWithJSON(w, r, http.StatusInternalServerError, m)        return    }    if isBlockValid(newBlock, Blockchain[len(Blockchain)-1]) {        newBlockchain := append(Blockchain, newBlock)        replaceChain(newBlockchain)        spew.Dump(Blockchain)    }    respondWithJSON(w, r, http.StatusCreated, newBlock)}Причина, по которой мы использовали отдельную структуру сообщения, заключается в том, что тело POST запроса приходит в формате JSON и мы будем использовать его для записи новых блоков. Это позволяет нам отправить POST запрос следующего вида и наш обработчик заполнит оставшуюся часть блока за нас:{""BPM"":50}50 — пример частоты пульса. Можете использовать своё значение пульса.После декодирования тела запроса в структуру var m Message, мы создадим новый блок, передавая предыдущий бок и новое значение пульса в функцию generateBlock, которую мы писали ранее. Проведем быструю проверку, что бы убедиться в правильности нового блока функцией isBlockValid.Примечания:spew.Dump — удобная функция, которая красиво выводит структуры в консоль. Очень помогает в отладке.для тестирования запросов, нам нравится использовать Postman. curl так же хорошо справляется, если вы не можете уйти от терминала.Хочется получать уведомление, когда наши POST запросы успешны или завершились с ошибкой. Мы используем небольшую обертку, для получения результата. Помните, что в Go никогда не игнорируются ошибки.func respondWithJSON(w http.ResponseWriter, r *http.Request, code int, payload interface{}) {    response, err := json.MarshalIndent(payload, """", ""  "")    if err != nil {        w.WriteHeader(http.StatusInternalServerError)        w.Write([]byte(""HTTP 500: Internal Server Error""))        return    }    w.WriteHeader(code)    w.Write(response)}Почти готово!Давайте соединим все наработки в одной функции main:func main() {    err := godotenv.Load()    if err != nil {        log.Fatal(err)    }    go func() {        t := time.Now()        genesisBlock := Block{0, t.String(), 0, """", """"}        spew.Dump(genesisBlock)        Blockchain = append(Blockchain, genesisBlock)    }()    log.Fatal(run())}Что здесь происходит?godotenv.Load() позволяет нам читать переменные из файла .envgenesisBlock — самая важная часть основной функции main. Нам нужно проинициализировать первый блок, т.к. предыдущего блока еще не существует.Все готово!Весь код вы можете забрать с githubДавайте проверим наш код.Запускаем в терминале наше приложение go run main.goВ терминале мы видим, что веб-сервер работает и мы получаем вывод нашего проинициализированного первого блока.Теперь посетите localhost:8080. Как и ожидалось, мы видим первый блок.Теперь давайте отправим POST запросы для добавления блоков. Используя Postman, мы собираемся добавить несколько новых блоков с различными значениями BPM.curl команда (от переводчика):curl -X POST http://localhost:8080/ -H 'content-type: application/json' -d '{""BPM"":50}'Обновим нашу страничку в браузере. Теперь можно увидеть новые блоки в нашей цепочке. Новые блоки содержат PrevHash соответствуют Hash у старых блоков, как мы и ожидали!В дальнейшемПоздравляем! Вы только что создали свой blockchain с правильным хэшированием и блочной проверкой. Теперь Вы можете изучать более сложные проблемы blockchain, такие, как Proof of Work, Proof of Stake, Smart Contracts, Dapps, Side Chains и другие.Данный урок не затрагивает такие темы, как новые блоки добавляются с помощью Proof of Work. Это будет отдельный урок, но существует множество blockchain и без механизмов Proof of Work. Сейчас все моделируется путем записи и просмотра данных blockchain на веб-сервере. В этом уроке нет составляющей P2P.Если Вы хотите, что бы мы добавили механизм Proof of Work и работу по сети, вы можете сообщить об этом в чате Telegram или подписаться на нас в Twitter! Это лучшие способы связаться с нами. Мы ждем новых отзывов и новых предложений по урокам. Мы рады услышать Вас!Чтобы узнать больше о Coral Health и о том, как мы используем blockchain в исследовательской работе по медицине, можете посетить наш сайт.P.S. Автор перевода будет благодарен за указанные ошибки и неточности перевода."
rwaltzsoftware;Blockchain Is Changing The Way Rail Industry Works;Распределённые системы *IT-компании;"Railways had made our transportation very easy since 1830 when the first railway began in England. From 1830 to 2020, the development in the railways has been quite significant. The concept of blockchain is expanding widely; hence the public interests are also growing on a vast scale. Major enthusiasts about blockchain are the investors and businessmen who wish for transparency and equity in the transaction. Now since blockchain is no more just a concept its application in railways is expected to smoothen the transportation.";/ru/post/485708/;"Railways had made our transportation very easy since 1830 when the first railway began in England. From 1830 to 2020, the development in the railways has been quite significant. The concept of blockchain is expanding widely; hence the public interests are also growing on a vast scale. Major enthusiasts about blockchain are the investors and businessmen who wish for transparency and equity in the transaction. Now since blockchain is no more just a concept its application in railways is expected to smoothen the transportation. In 2009 Satoshi Nakamoto initiated the blockchain technology on the bitcoin platform. Blockchain behaves as an open distributed digital ledger that eliminates the third party transaction. The use of blockchain will chop the transaction cost making it more beneficial for the customers to make the transactions. Blockchain also increases the security of the transaction so that any fraud will be avoided. Apart from the financial ease and security blockchain has significant use in the transportation industry. In 2013 network rail released the network rail technical strategy which specifies the areas requiring innovation in railways. It poses the characteristics of a cryptographically secured transaction, integrity, transparency, and cheap and efficient transaction.Cryptographically secured: As compared to the current mechanism, cryptographic security has a high threshold.Integrity: the data obtained with the help of blockchain is entirely efficient, accurate and reliable.Cheap and efficient: blockchain allows you to direct make the transaction without any third party interference, so the additional cost gets eliminated, making it affordable and efficient as well.Transparency: The data stored on a blockchain cannot be altered and hence offers a time-stamped version of the ‘truth.’ Advantages of blockchain in railwaysWith the help of smart contracts and sensors, all the trains can communicate with each other. The problem of train delays will be avoided with the help of smart contracts.All the accidents will get eliminated due to the smart management and communication of the trains.Blockchain will improvise the availability of the entire system.With the help of blockchain, the trains can choose their available routes and lock them so that there will be no other train to cross the way.Blockchain can be used for all other purposes, for example, for checking the driver’s license and driver authorization and billing the infrastructure.Blockchain updates the status of the trains continuously, avoiding any delay.Smart ticketing has become possible due to blockchain technology in the railways.Digital signatures are analogous to physical signatures and that has become a thing for the documentation in railways with the help of blockchain technology. It is performed using a key pair, a secret key which only the signer knows, a public key which everybody knows.Where is the blockchain technology being used in railways?The application of blockchain is increasing every day as china and Australia have already begun to support the various businesses related to blockchain. Now Russia implements the blockchain technology in railways. Since this technology is the best answer for efficiency and transparency, Russia has observed a significant change in its railway transportation with the help of blockchain.Blockchain allows complete data analyzing the new railway system in Russia will enable them to track everyday travelers.The railway system analyses the data and can avail of the offers for the right travelers.Transparency and traceability into the Russian railway system are due to blockchain technology.The use of blockchain in railways has increased the security of the data for the Russian railways.Blockchain technology assures that every information in the ledger is encoded cryptographically thus making it difficult to decode. All the information is interconnected; hence no one can change information since they have to make a change in all the information which is a challenging task.Decentralization is an excellent advantage of using blockchain technology because the information is not stored at a single location. Hence hacking and changing information is nearly impossible.The entire world along with Russia is witnessing the change in many sectors due to blockchain technology."
kristencarter7519;VeChain Has Introduced Blockchain-Based Healthcare Data Management Platform At Cyprus Hospital;Распределённые системы *Софт Искусственный интеллект;"Blockchain possesses incredible potential, that's why blockchain systems are considered as a paradise for data. In all these years, the discovery of Blockchain has been enjoyed for the introduction of distributed systems to secure data by cryptography. 

From the creation of cryptocurrency to distributed ledger systems and mobile applications, this technology is being welcomed by every business vertical, and its adoption has become complimentary for companies. Moreover, its adoption can majorly be cherished by the healthcare industry. 

A number of IT institutions are engaged in finding the most promising usage of blockchain technology in healthcare. Let's take a brief look at Blockchain adoption in 2020. 

The Global Blockchain Adoption
In 2020, the worldwide spending on blockchain systems is USD 4.3 billion. As per Statista, the market of Blockchain will be worth 20 billion USD by the year 2025. Its most critical adoption can be seen in the healthcare industry, where this technology is being considered as the biggest game-changer. 



The truth is that this technology has shown a path to distributed systems coupled with unmatched security measures That secure data in a chain of blocks infused with cryptographic locks. Top-notch level security and quality of not being tempered by any external entity boost its adoption in several instances.";/ru/post/510754/;Blockchain possesses incredible potential, that's why blockchain systems are considered as a paradise for data. In all these years, the discovery of Blockchain has been enjoyed for the introduction of distributed systems to secure data by cryptography. From the creation of cryptocurrency to distributed ledger systems and mobile applications, this technology is being welcomed by every business vertical, and its adoption has become complimentary for companies. Moreover, its adoption can majorly be cherished by the healthcare industry. A number of IT institutions are engaged in finding the most promising usage of blockchain technology in healthcare. Let's take a brief look at Blockchain adoption in 2020. The Global Blockchain AdoptionIn 2020, the worldwide spending on blockchain systems is USD 4.3 billion. As per Statista, the market of Blockchain will be worth 20 billion USD by the year 2025. Its most critical adoption can be seen in the healthcare industry, where this technology is being considered as the biggest game-changer. The truth is that this technology has shown a path to distributed systems coupled with unmatched security measures That secure data in a chain of blocks infused with cryptographic locks. Top-notch level security and quality of not being tempered by any external entity boost its adoption in several instances.Almost every industry is leveraging this technology for advancing their work environment and infusing transparency, security, and low data tempering risk. In such scenarios, the space healthcare setting has found its usage exciting and paradigm-changing. Here are some pointers that will show you the significance of blockchain adoption in the healthcare industry. 15% of healthcare agents have planned to implement a blockchain system by the end of 2020. Different medical healthcare systems are being utilized to keep the records of billions of patients throughout the world. In 2016, medical healthcare data fraud resulted in the loss of $30 million in the USA. Every year, millions of healthcare records get breached across the world. Clearly, data security is essential. Thus, blockchain adoption is the most sought-after solution. In such a setting, the launch of a blockchain system in Cyprus hospital is most significant. Let's take a look at it. The ways Blockchain can impact the healthcare industry This technology has immense potential and can enhance healthcare systems in different ways mentioned below. Health Records — Blockchain technology can change many aspects of healthcare, including health data. Stored in various locations under the current accounting system.Control of scattered persons. This means that the patient's consent and medical history records can be Incomplete, contradictory or unclear. Records stored on the Blockchain can provide complete health records give greater control over your information to individuals, and to patients. Any consent can be given and stored on the Blockchain.Clinical trial management — Similarly, blockchain technology can be used to manage clinical trials. Blockchain tools can automatically connect clinical data and disseminate it to different researchers and let's practice. Due to the irreversibility of blockchain records, the possibility of audit and data verification can be simplified.Providing credentials: are another function for which the Blockchain is well suited, as it is a directory of providers of health insurance plans. These concepts are not theoretical. More recently, Humana, Multiplan, Optum, Quest Diagnostics, and UnitedHelcare announce a pilot program that will use blockchain techniques to manage data providers to improve data quality and reduce administrative costs.Improved Supply chain: Blockchain is an elixir of improved traceability and transparency in the supply chain for healthcare, providing both the big picture and the smallest details of every transaction of any pharmaceutical product. With inventory data stored on the Blockchain, patients can acquire real-time information about the production of any drug to a retail pharmacy. Barcode notation will allow you to implement other functions in the system, such as:Monitoring the availability of medicines in clinicsWho was given the medicine?Drug amount transferredIn short, Blockchain can collaborate all the disconnected data segments of a resource into the life history of any resource, whether it is about the medical history of a patient or the drug moving throughout the supply chain.Vechain launches Blockchain-based medical platform in Cyprus hospitalThe Mediterranean Hospital in Cyprus has adopted the E-HCert application, which provides an archival solution based on the Weichen Thor blockchain. Vechin revealed the news on Twitter on June 20, stating that it would now be useful for hospital patients to conduct COVID-19 tests and store their results on the Weichen blockchain. Thanks to this initiative, citizens of Cyprus will be able to confirm their health status, which will allow them to go abroad or return to work.Moreover, Vechain also infused a blockchain-based medical data management platform. It was named The E-NewHealthLife. Mediterranean Hospital of Cyprus is the first to adopt this blockchain-based data management system. The platform is the result of the collaborative effort of VeChain and I-Dante. VeChain and I-Dante Partnered to Developed Blockchain-Based Medical Data Management PlatformAttempts have been made to modernize the technology infrastructure in the health sector, but problems include administrative and technical difficulties in combining data from various digital systems, rising costs, and balancing health issues and privacy issues, which have expended much effort. This dilemma has given rise to an urgent need for low-cost but high-performance digital solutions.Thanks to proven benefits in terms of secure data storage and efficient exchange of information between multiple parties, blockchain technology has become the best option. There is an urgent need to provide better and more effective medical solutions that may be subject to better patient-centred medical care, secure data exchange, use of patient data and rules of exchange, in which case the e-web application implementation is decided. NewHealthLife in the hospital's emergency department as the first phase of this project.VeChain ToolChainTM with I-Dante developed The Digital Healthcare Passport. It is an encrypted NFC card that can be assigned to any patient in the hospital. These NFC cards allow patients to automatically identify themselves at the emergency department front desk, check their turn on a mobile phone, and securely manage their medical records using the e-NewLifeLife web application.An application using Blockchain can serve both hospitals and end-users. Since E-NewHealthLife is fully compliant with GDPR (EU General Data Protection Regulation), the application allows owners to have complete control over their profile and medical records. Data can be transferred to third parties only with the permission of the owner.Final Text Amid the coronavirus pandemic, it is essential to keep track of each patient's medical history, this Blockchain-based platform will not just integrate the data security, but will also infuse patient data tracking for safe travel people. It is very important to include Blockchain development in every industry to get an easier and safer system.
SkidanovAlex;The authoritative guide to Blockchain Sharding;Высокая производительность *Распределённые системы *Криптовалюты;"Hi, I'm one of the developers of the sharded blockchain Near Protocol, and in this article want to talk about what blockchain sharding is, how it is implemented, and what problems exist in blockchain sharding designs.
It is well-known that Ethereum, the most used general purpose blockchain at the time of this writing, can only process less than 20 transactions per second on the main chain. This limitation, coupled with the popularity of the network, leads to high gas prices (the cost of executing a transaction on the network) and long confirmation times; despite the fact that at the time of this writing a new block is produced approximately every 10–20 seconds the average time it actually takes for a transaction to be added to the blockchain is 1.2 minutes, according to ETH Gas Station. Low throughput, high prices, and high latency all make Ethereum not suitable to run services that need to scale with adoption.";/ru/post/437926/;"Hi, I'm one of the developers of the sharded blockchain Near Protocol, and in this article want to talk about what blockchain sharding is, how it is implemented, and what problems exist in blockchain sharding designs.It is well-known that Ethereum, the most used general purpose blockchain at the time of this writing, can only process less than 20 transactions per second on the main chain. This limitation, coupled with the popularity of the network, leads to high gas prices (the cost of executing a transaction on the network) and long confirmation times; despite the fact that at the time of this writing a new block is produced approximately every 10–20 seconds the average time it actually takes for a transaction to be added to the blockchain is 1.2 minutes, according to ETH Gas Station. Low throughput, high prices, and high latency all make Ethereum not suitable to run services that need to scale with adoption.What is the primary reason for Ethereum’s low throughput? The reason is that every node in the network needs to process every single transaction. Developers have proposed many solutions to address the issue of throughput on the protocol level. These solutions can be mostly separated into those that delegate all the computation to a small set of powerful nodes, and those that have each node in the network only do a subset of the total amount of work. An extreme case of the former approach is Thunder that has one single node processing all the transactions and claims to achieve 1200 tx/sec, a 100x improvement over Ethereum (I do not, however, endorse Thunder, or attest to the validity of their claims). Algorand, SpaceMesh, Solana all fit into the former category, building various improvements in the consensus and the structure of the blockchain itself to run significantly more transactions, but still bounded by what a single (albeit very powerful) machine can process.The latter approach, in which the work is split among all the participating nodes, is called sharding. This is how Ethereum Foundation currently plans to scale Ethereum. At the time of this writing the full spec is still not published. Here are links to a detailed overview of Ethereum shard chains and the Beacon chain.In this post I summarize the core ideas of blockchain sharding, on which both Near and majority of other sharded protocols are based. The subsequent post will outline more advanced topics in sharding.The simplest Sharding, a.k.a. BeanstalkLet’s start with the simplest approach to sharding, that we throughout this write-up will call a Beanstalk. This is also what Vitalik calls “scaling by a thousand altcoins” in this presentation.In this approach instead of running one blockchain, we will run multiple, and call each such blockchain a “shard”. Each shard will have its own set of validators. Here and below we use a generic term “validator” to refer to participants that verify transactions and produce blocks, either by mining, such as in Proof of Work, or via a voting-based mechanism. For now let’s assume that the shards never communicate with each other.The Beanstalk design, though simple, is sufficient to outline some major challenges in sharding.Validator partitioning and Beacon chainsThe first challenge is that with each shard having its own validators, each shard is now 10 times less secure than the entire chain. So if a non-sharded chain with X validators decides to hard-fork into a sharded chain, and splits X validators across 10 shards, each shard now only has X/10 validators, and corrupting one shard only requires corrupting 5.1% (51% / 10) of the total number of validators.Which brings us to the second point: who chooses validators for each shard? Controlling 5.1% of validators is only damaging if all those 5.1% of validators are in the same shard. If validators can’t choose which shard they get to validate in, a participant controlling 5.1% of the validators is highly unlikely to get all their validators in the same shard, heavily reducing their ability to compromise the system.Almost all sharding designs today rely on some source of randomness to assign validators to shards. Randomness on blockchain on itself is a very challenging topic and would deserve a separate blog post at some later date, but for now let’s assume there’s some source of randomness we can use.Both the randomness and the validators assignment require computation that is not specific to any particular shard. For that computation, practically all existing designs have a separate blockchain that is tasked with performing operations necessary for the maintenance of the entire network. Besides generating random numbers and assigning validators to the shards, these operations often also include receiving updates from shards and taking snapshots of them, processing stakes and slashing in Proof-of-Stake systems, and rebalancing shards when that feature is supported. Such chain is called a Beacon chain in Ethereum and Near, a Relay chain in PolkaDot, and the Cosmos Hub in Cosmos.Throughout this post we will refer to such chain as a Beacon chain. The existence of the Beacon chain brings us to the next interesting topic, the quadratic sharding.Quadratic shardingSharding is often advertised as a solution that scales infinitely with the number of nodes participating in the network operation. While it is in theory possible to design such a sharding solution, any solution that has the concept of a Beacon chain doesn’t have infinite scalability. To understand why, note that the Beacon chain has to do some bookkeeping computation, such as assigning validators to shards, or snapshotting shard chain blocks, that is proportional to the number of shards in the system. Since the Beacon chain is itself a single blockchain, with computation bounded by the computational capabilities of nodes operating it, the number of shards is naturally limited.However, the structure of a sharded network does bestow a multiplicative effect on any improvements to its nodes. Consider the case in which an arbitrary improvement is made to the efficiency of nodes in the network which will allow them faster transaction processing times.If the nodes operating the network, including the nodes in the Beacon chain, become four times faster, then each shard will be able to process four times more transactions, and the Beacon chain will be able to maintain 4 times more shards. The throughput across the system will increase by the factor of 4 x 4 = 16?—?thus the name quadratic sharding.It is hard to provide an accurate measurement for how many shards are viable today, but it is unlikely that in any foreseeable future the throughput needs of blockchain users will outgrow the limitations of quadratic sharding. The sheer number of nodes necessary to operate such a volume of shards securely is orders of magnitude higher than the number of nodes operating all the blockchains combined today.However, if we want to build future proof protocols, it might be worth starting researching solutions to this problem today. The most developed proposal as of now is exponential sharding, in which shards themselves are forming a tree, and each parent shard is orchestrating a series of child shards, while can itself be a child of some other shard.Vlad Zamfir from Ethereum Foundation is known to be working on a sharding design that doesn’t involve a beacon chain; I worked with him on one of the prototypes, the detailed overview of which is here.State ShardingUp until now we haven’t defined very well what exactly is and is not separated when a network is divided into shards. Specifically, nodes in the blockchain perform three important tasks: not only do they 1) process transactions, they also 2) relay validated transactions and completed blocks to other nodes and 3) store the state and the history of the entire network ledger. Each of these three tasks imposes a growing requirement on the nodes operating the network:The necessity to process transactions requires more compute power with the increased number of transactions being processed;The necessity to relay transactions and blocks requires more network bandwidth with the increased number of transactions being relayed;The necessity to store data requires more storage as the state grows. Importantly, unlike the processing power and network, the storage requirement grows even if the transaction rate (number of transactions processed per second) remains constant.From the above list it might appear that the storage requirement would be the most pressing, since it is the only one that is being increased over time even if the number of transactions per second doesn’t change, but in practice the most pressing requirement today is the compute power. The entire state of Ethereum as of this writing is 100GB, easily manageable by most of the nodes. But the number of transactions Ethereum can process is around 20, orders of magnitude less than what is needed for many practical use cases.Zilliqa is the most well-known project that shards processing but not storage. Sharding of processing is an easier problem because each node has the entire state, meaning that contracts can freely invoke other contracts and read any data from the blockchain. Some careful engineering is needed to make sure updates from multiple shards updating the same parts of the state do not conflict. In those regards Zilliqa is taking a very simplistic approach, criticism of which can be found in this post.While sharding of storage without sharding of processing was proposed, I’m not aware of any project working on it. Thus in practice sharding of storage, or State Sharding, almost always implies sharding of processing and sharding of network.Practically, under State Sharding the nodes in each shard are building their own blockchain that contains transactions that affect only the local part of the global state that is assigned to that shard. Therefore, the validators in the shard only need to store their local part of the global state and only execute, and as such only relay, transactions that affect their part of the state. This partition linearly reduces the requirement on all compute power, storage, and network bandwidth, but introduces new problems, such as data availability and cross-shard transactions, both of which we will cover below.Cross-shard transactionsBeanstalk as a model is not a very useful approach to sharding, because if individual shards cannot communicate with each other, they are no better than multiple independent blockchains. Even today, when sharding is not available, there’s a huge demand for interoperability between various blockchains.Let’s for now only consider simple payment transactions, where each participant has account on exactly one shard. If one wishes to transfer money from one account to another within the same shard, the transaction can be processed entirely by the validators in that shard. If, however, Alice that resides on shard #1 wants to send money to Bob who resides on shard #2, neither validators on shard #1(they won’t be able to credit Bob’s account) nor the validators on shard #2 (they won’t be able to debit Alice’s account) can process the entire transaction.There are two families of approaches to cross-shard transactions:Synchronous: whenever a cross-shard transaction needs to be executed, the blocks in multiple shards that contain state transition related to the transaction get all produced at the same time, and the validators of multiple shards collaborate on executing such transactions. The most detailed proposal known to me is Merge Blocks, described here.Asynchronous: a cross-shard transaction that affects multiple shards is executed in those shards asynchronously, the “Credit” shard executing its half once it has sufficient evidence that the “Debit” shard has executed its portion. This approach tends to be more prevalent due to its simplicity and ease of coordination. This system is today proposed in Cosmos, Ethereum Serenity, Near, Kadena, and others. A problem with this approach lies in that if blocks are produced independently, there’s a non-zero chance that one of the multiple blocks will be orphaned, thus making the transaction only partially applied. Consider the figure below that depicts two shards both of which encountered a fork, and a cross-shard transaction that was recorded in blocks A and X’ correspondingly. If the chains A-B and V’-X’-Y’-Z’ end up being canonical in the corresponding shards, the transaction is fully finalized. If A’-B’-C’-D’ and V-X become canonical, then the transaction is fully abandoned, which is acceptable. But if, for example, A-B and V-X become canonical, then one part of the transaction is finalized and one is abandoned, creating an atomicity failure. We will cover how this problem is addressed in proposed protocols in the second part, when covering changes to the fork-choice rules and consensus algorithms proposed for sharded protocols.Note that communication between chains is useful outside of sharded blockchains too. Interoperability between chains is a complex problem that many projects are trying to solve. In sharded blockchains the problem is somewhat easier since the block structure and consensus are the same across shards, and there’s a beacon chain that can be used for coordination. In a sharded blockchain, however, all the shard chains are the same, while in the global blockchains ecosystem there are lots of different blockchains, with different target use cases, decentralization and privacy guarantees.Building a system in which a set of chains have different properties but use sufficiently similar consensus and block structure and have a common beacon chain could enable an ecosystem of heterogeneous blockchains that have a working interoperability subsystem. Such system is unlikely to feature validator rotation, so some extra measures need to be taken to ensure security. Both Cosmos and PolkaDot are effectively such systems. This writeup by Zaki Manian from Cosmos provides detailed overview and comparison of the key aspects of the two projects.Malicious behaviorYou now have a good understanding of how sharding is implemented, including the concepts of the beacon chain, validator rotations and cross-shard transactions.With all that information, there’s one last important thing to consider. Specifically, what adversarial behavior can malicious validators exercise.Malicious ForksA set of malicious validators might attempt to create a fork. Note that it doesn’t matter if the underlying consensus is BFT or not, corrupting sufficient number of validators will always make it possible to create a fork.It is significantly more likely for more that 50% of a single shard to be corrupted, than for more than 50% of the entire network to be corrupted (we will dive deeper into these probabilities in the second part). As discussed above, cross-shard transactions involve certain state changes in multiple shards, and the corresponding blocks in such shards that apply such state changes must either be all finalized (i.e. appear in the selected chains on their corresponding shards), or all be orphaned (i.e. not appear in the selected chains on their corresponding shards). Since generally the probability of shards being corrupted is not negligible, we can’t assume that the forks won’t happen even if a byzantine consensus was reached among the shard validators, or many blocks were produced on top of the block with the state change.This problem has multiple solutions, the most common one being occasional cross-linking of the latest shard chain block to the beacon chain. The fork choice rule in the shard chains is then changed to always prefer the chain that is cross-linked, and only apply shard-specific fork-choice rule for blocks that were published since the last cross-link.Approving invalid blocksA set of validators might attempt to create a block that applies the state transition function incorrectly. For example, starting with a state in which Alice has 10 tokens and Bob has 0 tokens, the block might contain a transaction that sends 10 tokens from Alice to Bob, but ends up with a state in which Alice has 0 tokens and Bob has 1000 tokens.In a classic non-sharded blockchain such an attack is not possible, since all the participant in the network validate all the blocks, and the block with such an invalid state transition will be rejected by both other block producers, and the participants of the network that do not create blocks. Even if the malicious validators continue creating blocks on top of such an invalid block faster than honest validators build the correct chain, thus having the chain with the invalid block being longer, it doesn’t matter, since every participant that is using the blockchain for any purpose validates all the blocks, and discards all the blocks built on top of the invalid block.On the figure above there are five validators, three of whom are malicious. They created an invalid block A’, and then continued building new blocks on top of it. Two honest validators discarded A’ as invalid and were building on top of the last valid block known to them, creating a fork. Since there are fewer validators in the honest fork, their chain is shorter. However, in classic non-sharded blockchain every participant that uses blockchain for any purpose is responsible for validating all the blocks they receive and recomputing the state. Thus any person who has any interest in the blockchain would observe that A’ is invalid, and thus also immediately discard B’, C’ and D’, as such taking the chain A-B as the current longest valid chain.In a sharded blockchain, however, no participant can validate all the transactions on all the shards, so they need to have some way to confirm that at no point in history of any shard of the blockchain no invalid block was included.Note that unlike with forks, cross-linking to the Beacon chain is not a sufficient solution, since the Beacon chain doesn’t have the capacity to validate the blocks. It can only validate that a sufficient number of validators in that shard signed the block (and as such attested to its correctness).I am aware of only two solutions to this problem, neither of which is really satisfactory today:Have some reasonable mechanism that will alert the system if an attempt to apply the state transition incorrectly is made. Assuming that each shard is running some sort of BFT consensus, for as long as number of malicious validators in a particular shard is less than ?, at least one honest validator would need to attest to a block, and verify that the state transition function is applied correctly. If more than ? of the nodes are malicious, they can finalize a block without a single honest node participating. Assuming that at least one node in the shard is not malicious, some mechanism is needed that would allow such nodes to monitor what blocks are being produced, and have sufficient time to challenge nodes with invalid state transition.Have some information in the blocks that is sufficient to prove that the state transition is applied correctly but is significantly cheaper to validate than the actual application of the state transition function. The closest mechanism to achieve that is zk-SNARKs (though we don’t really need the “zk”, or zero-knowledge, part, a non-zk SNARK would be sufficient), but zk-SNARKs are notoriously slow to compute at this point.Many protocols today assume that with proper validator rotation and a byzantine fault tolerant consensus neither forks nor invalid state transitions are possible. The reason why this assumption is unreasonable is a topic for a separate article.OutroI write a lot about blockchains and sharding, and we also have a video series where we talk to founders of scalable protocols, such as Cosmos and Solana, with tech deep dives. You can follow me on twitter here."
KosToZyB;Часть 2: Сетевое взаимодействие — Написание blockchain менее чем за 200 строк кода на Go;Go *;Вы прочитали первую часть из этой серии? Если нет, то стоит взглянуть. Не волнуйся, мы подождем...;/ru/post/348624/;"Вы прочитали первую часть из этой серии? Если нет, то стоит взглянуть. Не волнуйся, мы подождем...Добро пожаловать!Мы были ошеломлены обратной связью от нашего первого поста: ""Написание blockchain менее чем за 200 строк кода на Go"". То, что предназначалось для небольшого урока для начинающих разработчиков по blockchain, приобрело новую жизнь. Нас завалили запросами сделать пост, где мы добавляем сетевое взаимодействие.Прежде чем начнем, вы можете присоединиться к нашему чату в Telegram! Это лучшее место, что бы задать нам вопросы, дать отзывы и попросить новые уроки. Если вы нуждаетесь в помощи с вашим кодом, то это идеальное место, что бы спросить!Последний пост показал вам, как создать свой собственный blockchain с хэшированием и валидацией каждого нового блока. Но все это выполнялось на одной ноде. Как мы можем подключить еще одну ноду к нашему основному приложению и создавать новые блоки, и обновлять всю цепочку блоков на всех остальных нодах?Рабочий процессПервый терминал создает первый базовый блок и TCP сервер, к которому могут подключаться новые ноды.Шаг 1Открываются дополнительные терминалы и TCP соединения с первым терминаломНовый терминал записывает блок на первый терминалШаг 2Первый терминал проверяет блокПервый терминал рассылает новую цепочку блоков каждой новой нодеШаг 3Все терминалы синхронизированы!После урока попробуйте сделать сами: каждый новый терминал, так же выступает в качестве ""первых"" терминалов, но с различными TCP портами и каждый с каждым имеет соединения для правильной работы сети.Что вы сможете сделатьЗапустите терминал, который обеспечивает первый базовый блокЗапустите множество новых дополнительных терминалов, сколько хотите и пусть они запишут блоки в первый терминалПервый терминал должен рассылать обновленные блоки для новых терминаловЧто вы не сможете сделатьКак и в предыдущем посте, цель данного урока в том, что бы получить базовую сеть из нод, что бы вы дальше смогли самостоятельно изучать blockchain. Вы не сможете добавить компьютеры из другой сети, которые будут писать в ваш первый терминал, но этого можно достичь, запустив бинарник в облаке. Кроме того, цепочка блоков будет смоделирована для каждой из нод. Не волнуйтесь, мы скоро все объясним.Давайте начнем кодить!Местами будет обзор предыдущего поста. Оставим множество функций, таких как генерация блоков, хэширование, проверка. Функционал HTTP использовать не будем, а просматривать результат будем в консоли, а для работы по сети будем использовать TCP.Какие различия между TCP и HTTP?Не будем вдаваться в подробности, но все, что вам нужно знать, что TCP является базовым протоколом, который передает данные. HTTP построен поверх TCP стека, что бы использовать эту передачу данных между интернетом и браузером. Когда вы просматриваете веб-сайт, вы используете HTTP протокол. В данном уроке будем работать с TCP, так как нам не нужно ничего просматривать в браузере. Go имеет хороший сетевой пакет, предоставляющий все функции TCP соединения, которые нам необходимы.Установка, импорты и обзорНекоторая реализация уже рассматривались в первой части. Для генерации и проверки цепочки блоков будем использовать функции из предыдущей статьи.УстановкаСоздайте .env файл в вашей главной директории и добавьте строку:ADDR=9000Сохраняем номер порта TCP, который хотим использовать (в нашем случае 9000) в переменной окружения под названием ADDR.Если вы еще этого не сделали, установите следующие пакеты:go get github.com/davecgh/go-spew/spewдля красивой печати нашей цепочки блоков в консольgo get github.com/joho/godotenvдля чтения переменных из нашего .env файла.Создайте пустой main.go файл. Там расположим наш код.ИмпортыДекларация пакета и необходимые нам импорты:package mainimport (    ""bufio""    ""crypto/sha256""    ""encoding/hex""    ""encoding/json""    ""io""    ""log""    ""net""    ""os""    ""strconv""    ""time""    ""github.com/davecgh/go-spew/spew""    ""github.com/joho/godotenv"")ОбзорСледующие фрагменты кода хорошо описаны в первой части.Давайте создадим нашу Block структуру и объявим слайс блоков, это и будет наша цепочка блоков.type Block struct {    Index     int    Timestamp string    BPM       int    Hash      string    PrevHash  string}var Blockchain []BlockОбъявим так же нашу функцию хэширования, которая понадобится нам при создании новых блоков.func calculateHash(block Block) string {    record := string(block.Index) + block.Timestamp + string(block.BPM) + block.PrevHash    h := sha256.New()    h.Write([]byte(record))    hashed := h.Sum(nil)    return hex.EncodeToString(hashed)}И функция создания блоков:func generateBlock(oldBlock Block, BPM int) (Block, error) {    var newBlock Block    t := time.Now()    newBlock.Index = oldBlock.Index + 1    newBlock.Timestamp = t.String()    newBlock.BPM = BPM    newBlock.PrevHash = oldBlock.Hash    newBlock.Hash = calculateHash(newBlock)    return newBlock, nil}Можем убедиться, что наш новый блок правильный, для этого проверим, что поле PrevHash ссылается на поле Hash из предыдущего блока.func isBlockValid(newBlock, oldBlock Block) bool {    if oldBlock.Index+1 != newBlock.Index {        return false    }    if oldBlock.Hash != newBlock.PrevHash {        return false    }    if calculateHash(newBlock) != newBlock.Hash {        return false    }    return true}Теперь гарантируем, что возьмем самую длинную цепочку, как правильную:func replaceChain(newBlocks []Block) {    if len(newBlocks) > len(Blockchain) {        Blockchain = newBlocks    }}Замечательно! Получили основной функционал по работе с цепочкой блоков. Теперь можем перейти к созданию взаимодействия по сети.Сетевое взаимодействиеДавайте создадим сеть, которая может передавать новые блоки, интегрировать их в цепочку и транслировать новую цепочку для сети.Начнем с функции main, но перед этим давайте объявим глобальную переменную bcServer, которая является каналом принимающим входящие блоки.var bcServer chan []BlockПримечание: Каналы являются одним из наиболее популярных инструментов в Go и обеспечивает красивую реализацию чтения/записи данных и чаще всего используется для предотвращения состояния гонки. Они становятся мощным инструментом, когда несколько Go-рутин конкурентно (не путать с параллельностью) пишут в один и тот же канал. Обычно в Java и других C-подобных языках вам придется блокировать и разблокировать мьютекс для доступа к данным. Каналы в Go делают это намного проще, хотя в Go так же есть и мьютексы. Можете подробнее почитать об этом тут.Теперь давайте объявим нашу функцию main и загрузим переменные окружения из нашего файла .env, который находится в корневом каталоге. А так же запустим экземпляр нашего bcServer в функции main.func main() {   err := godotenv.Load()   if err != nil {       log.Fatal(err)   }   bcServer = make(chan []Block)   // create genesis block   t := time.Now()   genesisBlock := Block{0, t.String(), 0, """", """"}   spew.Dump(genesisBlock)   Blockchain = append(Blockchain, genesisBlock)}Теперь нам необходимо создать TCP сервер. Помните, что TCP серверы похожи на HTTP серверы, но для работы с браузером протокола TCP недостаточно. Все данные будут отображаться через консоль. Будем обрабатывать несколько соединений с нашим TCP портом. Добавим это к нашей функции main:server, err := net.Listen(""tcp"", "":""+os.Getenv(""ADDR""))    if err != nil {        log.Fatal(err)    }    defer server.Close()Этот код запустит наш TCP сервер на порту 9000. Важно выполнить defer server.Close(), что бы соединение закрылось, когда больше нет необходимости в нем. Почитать подробнее про defer можно тут.Теперь нам необходимо создавать новое соединение каждый раз, когда получаем запрос на установку соединения, и нам необходимо будем его обработать. Добавим еще кода:for {    conn, err := server.Accept()    if err != nil {        log.Fatal(err)    }    go handleConn(conn)}Создаем бесконечный цикл, в котором принимаем новые соединения. Для конкурентной обработки, каждое соединение запускаем в обработчике в Go рутине go handleConn(conn), поэтому не останавливаем наш цикл. Таким образом можем одновременно слушать несколько соединений конкурентно.Внимательный читатель заметит, что функция обработчик handleConn не объявлена. Мы пока что создали нашу основную функцию main. Целиком она выглядит так:func main() {    err := godotenv.Load()    if err != nil {        log.Fatal(err)    }    bcServer = make(chan []Block)    // create genesis block    t := time.Now()    genesisBlock := Block{0, t.String(), 0, """", """"}    spew.Dump(genesisBlock)    Blockchain = append(Blockchain, genesisBlock)    // start TCP and serve TCP server    server, err := net.Listen(""tcp"", "":""+os.Getenv(""ADDR""))    if err != nil {        log.Fatal(err)    }    defer server.Close()    for {        conn, err := server.Accept()        if err != nil {            log.Fatal(err)        }        go handleConn(conn)    }}Давайте теперь напишем нашу функцию handleConn. Она принимает только один аргумент, это интерфейс net.Conn. На наш взгляд, интерфейсы в Go поразительны и они отличают его от всех C-подобный языков. Конкурентность и Go рутины рекламируют язык, но интерфейсы и тот факт, что они могут реализовывать интерфейс не явно, является самой мощной функцией языка. Если вы еще не используете интерфейсы в Go, ознакомитесь с ними как только сможете. Интерфейсы это ваш следующий шаг, для становления как Go разработчика.Поместите в заготовку функции обработчика отложенное закрытие соединения defer, что бы не забыть его закрыть, когда завершим работу.func handleConn(conn net.Conn) {    defer conn.Close()}Теперь нам нужно разрешить клиенту добавлять новые блоки в цепочку. Для данных будем использовать частоту пульса, как в первой части. Замерьте свой пульс в течение минуты и запомните это число. Это будет параметр BPM (beats per minute)Для реализации вышеуказанного нам необходимо:попросить клиента ввести свой BPMзапросить это значение у клиента через stdinсоздать новый блок с этими данными, используя функции generateBlock, isBlockValid и replaceChainположить новую цепочку блоков в канал, созданный ранее для передачи по сетиразрешить клиенту вводить новое значение BMPКод, который реализует выше описанный функционал:io.WriteString(conn, ""Enter a new BPM:"")scanner := bufio.NewScanner(conn)go func() {    for scanner.Scan() {        bpm, err := strconv.Atoi(scanner.Text())        if err != nil {            log.Printf(""%v not a number: %v"", scanner.Text(), err)            continue        }        newBlock, err := generateBlock(Blockchain[len(Blockchain)-1], bpm)        if err != nil {            log.Println(err)            continue        }        if isBlockValid(newBlock, Blockchain[len(Blockchain)-1]) {            newBlockchain := append(Blockchain, newBlock)            replaceChain(newBlockchain)        }        bcServer <- Blockchain        io.WriteString(conn, ""\nEnter a new BPM:"")    }}()Создаем новый сканер. for scanner.Scan() это цикл, который работает конкурентно в Go рутине и отдельно от других соединений. Делаем быстрое строковое преобразование значения BMP (которое всегда будет типом integer, поэтому проверяем его). Выполняем стандартную генерацию блока, проверка блока на валидность и добавление нового блока в цепочку.Синтаксис bcServer <- Blockchain просто означает, что мы бросаем нашу новую цепочку в канал, который создали ранее. Затем предлагаем клиенту ввести новое значение BPM для создания следующего блока.Широковещательный каналНам необходимо разослать новую цепочку блоков для всех соединений на нашем TCP сервере. Поскольку мы программируем на одном компьютере, нам надо имитировать, как данные будет передаваться всем клиентам. В функцию handleConn нам необходимо добавить:конвертацию нашей цепочки блоков в JSON формат, что она была удобочитаемойзапись новой цепочки блоков в консоль для каждого из соединенийустановка таймаута периодичности, что бы наша цепочка блоков не спамила постоянно. В существующих системах это происходит каждый X минут. Будем использовать 30 секундвывод основной цепочку блоков на первом терминале, что бы мы могли видеть, что происходит. Так мы убедимся, что блоки добавляемые различными нодами, действительно интегрируются в основную цепочку блоковВот код, выполняющий все в нужном порядке:go func() {    for {        time.Sleep(30 * time.Second)        output, err := json.Marshal(Blockchain)        if err != nil {            log.Fatal(err)        }        io.WriteString(conn, string(output))    }}()for _ = range bcServer {    spew.Dump(Blockchain)}Замечательно! Наша функция handleConn готова. Фактически вся программа готова и мы сохранили ее компактность в 200 строк кода. Это неплохо, не так ли?Целиком со всем кодом, можно ознакомиться тут!Интересный материалДавайте перейдем в директорию с нашим кодом и запустим нашу программу, выполнив: go run main.goКак и ожидалось, видим наш базовый блок. В это же время запустили TCP сервер на порту 9000, который может принимать несколько соединений.Откройте новое окно терминала и подключитесь к нашему TCP серверу с помощью nc localhost 9000. Будем использовать разный цвет в терминалах, что бы было понятно, что это разные клиенты. Сделайте это несколько раз с разными сеансами терминала, что бы запустить несколько клиентов.Теперь введите BPM на любом из клиентов. Видим, что новый блок добавлен в первый терминал! Сеть работает!Ждем 30 секунд. Перейдите к одному из других клиентов, и вы увидите, что новая цепочка блоков передалась всем клиентам, даже если эти клиенты никогда не вводили BPM!Следующие шагиПоздравляем! Вы не только создали свой собственный blockchain из последнего урока, но и добавили сетевое взаимодействие. Теперь есть несколько направлений для того, что бы двигаться дальше:что бы получить большую сеть, работающую локально, создайте несколько каталогов, в которых хранится копия приложения. Каждая копия должна иметь разные TCP-порты. Для каждого сеанса терминала слушайте порт TCP и подключайтесь к другому, что бы вы могли получать и отправлять ваши данные.Объединяйте данные, полученные с нескольких портов. Это тема для другого урока, но это делается легко. Все это blockchain. Он должен принимать данные, а также передавать данные.Вы можете попробовать это с друзьями, настройте сервер в облаке, используя ваш любимый хостинг-провайдер. Попросите ваших друзей подключиться к нему и отправить данные. На данном этапе можно добавить немного безопасности. Если будут запросы, то мы сделаем учебник по этому материалу.Вы уже понимаете множество аспектов blockchain. Рекомендуем почитать алгоритмы наподобие Proof of Work или Proof of Stake.Или можете просто подождать, пока мы напишем новое сообщение в блоге :-)Напомним, что бы сообщить нам, что вы хотите увидеть, присоединяйтесь к нашему Telegram чату! Возможно, вы сможете поменять наше мнение о том, что написать в дальнейших уроках. Можете подписаться на наш Twitter так же.Чтобы узнать больше о Coral Health и о том, как мы используем blockchain в исследовательской работе по медицине, можете посетить наш сайт.P.S. Автор перевода будет благодарен за указанные ошибки и неточности перевода."
Ragnar_by;Blockchain на Go. Часть 3: Постоянная память и интерфейс командной строки;Go *;"Содержание


Blockchain на Go. Часть 1: Прототип 
 Blockchain на Go. Часть 2: Proof-of-Work
Blockchain на Go. Часть 3: Постоянная память и интерфейс командной строки
Blockchain на Go. Часть 4: Транзакции, часть 1
Blockchain на Go. Часть 5: Адреса 
Blockchain на Go. Часть 6: Транзакции, часть 2
Blockchain на Go. Часть 7: Сеть

Вступление
В предыдущей части мы построили блокчейн с PoW системой и возможностью майнинга. Наша реализация всё ближе к полностью функциональному блокчейну, но ей все ещё не хватает некоторых важных функций. Сегодня мы начнем хранить блокчейн в базе данных, после этого сделаем интерфейс командной строки для операций с блокчейном. По сути, блокчейн — это распределенная база данных. Мы пока опустим «распределенная» и сосредоточимся на «база данных».";/ru/post/351296/;"СодержаниеBlockchain на Go. Часть 1: Прототип  Blockchain на Go. Часть 2: Proof-of-WorkBlockchain на Go. Часть 3: Постоянная память и интерфейс командной строкиBlockchain на Go. Часть 4: Транзакции, часть 1Blockchain на Go. Часть 5: Адреса Blockchain на Go. Часть 6: Транзакции, часть 2Blockchain на Go. Часть 7: СетьВступлениеВ предыдущей части мы построили блокчейн с PoW системой и возможностью майнинга. Наша реализация всё ближе к полностью функциональному блокчейну, но ей все ещё не хватает некоторых важных функций. Сегодня мы начнем хранить блокчейн в базе данных, после этого сделаем интерфейс командной строки для операций с блокчейном. По сути, блокчейн — это распределенная база данных. Мы пока опустим «распределенная» и сосредоточимся на «база данных».Выбор базы данныхПока что, у нас нет базы данных в реализации, мы просто создаем блоки при запуске программы и храним их в памяти. Мы не можем повторно использовать или поделиться с другими нашим блокчейном, поэтому нам нужно сохранить его на диске.Какая база данных нам нужна? На самом деле, подойдет любая. В  Биткоин Paper  ничего не сказано про конкретную базу данных, так что выбор остается за разработчиком. Bitcoin Core , который был первоначально опубликован Сатоши Накамото и который в настоящее время является эталонной реализацией Bitcoin, использует LevelDB (хотя он был представлен клиенту только в 2012 году). А мы будем использовать…BoltDB Потому что:Она простая и минималистичная  Она реализована на Go Ей не требуется запуск сервераОна позволяет строить необходимые нам структуры данных Из  BoltDB README:Bolt -это просто хранилище типа «ключ-значение», вдохновленное проектом Говарда Чу  LMDB. Цель проекта — предоставить простую, быструю и надежную базу данных для проектов, для которых не требуется полноценный сервер базы данных, такой как Postgres или MySQL.Так как Bolt предназначен для использования в качестве такого низкоуровневого элемента функциональности, простота является ключевой. API будет небольшим и ориентироваться только на получение значений и установке значений. Это всё! Звучит идеально для наших нужд! Потратим минутку на обзор базы. BoltDB — это хранилище «ключ-значение», что значит, что нет таблиц, как в реляционных СУБД ( MySQL, PostgreSQL и тд), нет рядов и столбцов. Вместо этого, данные хранятся в парах «ключ-значение»( как в Golang map). Пары хранятся в «корзинах», которые предназначены для группировки похожих пар (подобно таблицах в реляционных СУБД). Таким образом, чтобы получить значение, надо знать корзину и ключ.Важной вещью про BoltDB является то, что здесь нет типов данных: ключи и значения — это байтовые массивы. Так как мы храним Go структуры ( в частности Block), то мы должны сериализовать их, то есть реализовать механизм по переводу структуры в байтовый массив и восстановлению её назад из массива. Мы будем использовать  encoding/gob  для этого, хотя  JSON, XML, Protocol Buffers тоже подходят. Мы используем encoding/gob, потому что это просто и это часть стандартной библиотеки Go.Структура базы данныхДо того, как мы начнем реализовывать персистентную логику, мы должны решить, как будем хранить наши данные в базе. И для этого мы будем использовать способ, который используем Bitcoin Core.Если по-простому, то Bitcoin Core использует две «корзины» для хранения данных. blocks хранит метаданные, описывающие все блоки в цепи chainstate сохраняет состояние цепи, которое представляет собой все непотраченные выходы транзакций и некоторые метаданныеТакже блоки хранятся как отдельные файлы на диске. Это сделано для повышения производительности: чтение одного блока не требует загрузку всех (или некоторых) в память. Это мы не будет реализовывать.В blocks пары key->value это:'b' + 32-байтовый хэш блока -> запись индекса блока'f' + 4-байтовый номер файла -> запись информации о файле 'l' -> 4-байтовый номер файла: номер использованного файла для последнего блока  'R' -> 1-байтовый boolean : находимся ли мы в процессе переиндексации 'F' + 1-байтовая длина имени флага + строка имени флага -> 1 байт boolean: различные флаги, которые могут быть включены или выключены 't' + 32-байтовый хеш транзакции -> запись индекса транзакции В chainstate пары key->value это:'c' + 32-байтовый хеш транзакции -> запись о непотраченном выходе транзакции для этой транзакции'B' -> 32-байтовый хеш блока: хеш блока, до которого база данных представляет собой неизрасходованные выходы транзакции (Подробное пояснение можно найти здесь)Так как у нас пока что нет транзакций, то мы сделаем только корзину blocks. Кроме того, как было сказано выше, мы будем хранить всю базу данных в одном файле, без хранения блоков в отдельных файлах. Поэтому нам не нужно ничего, связанное с файловыми номерами. Поэтому пары key->value, которые мы будем использовать, это: 32-байтовый хэш блока -> структура блока (сериализованная)'l' -> хэш последнего блока в цепиЭто всё, что нам необходимо знать для реализации механизма постоянства ( персистентности). Сериализация Как сказано ранее, в BoltDB значения могут быть лишь []byte типа, и мы хотим хранить структуру Block в базе. Мы будем использовать encoding/gob для сериализации структур. Давайте реализуем метод Serialize для Block (обработка ошибок для краткости опущена)func (b *Block) Serialize() []byte {	var result bytes.Buffer	encoder := gob.NewEncoder(&result)	err := encoder.Encode(b)	return result.Bytes()}Здесь всё просто: в начале, мы объявляем буфер, где будут храниться сериализованные данные, затем инициализируем gob кодировщик и кодируем блок, результат возвращаем как массив байтов.Теперь нам нужна функция десериализации, которая получает на вход массив байтов и возвращает Block. Это будет не метод, а независимая функция:func DeserializeBlock(d []byte) *Block {	var block Block	decoder := gob.NewDecoder(bytes.NewReader(d))	err := decoder.Decode(&block)	return &block}Вот и всё, что нам надо для сериализации.ПерсистентностьНачнем с функции NewBlockchain. Сейчас она создает новый экземпляр  Blockchain и добавляет к нему генезис-блок. Мы хотим сделать следующее: Открыть БД файл Проверить, сохранен ли там блокчейн Если он там есть: Создать новый экземпляр Blockchain Установить кончик(tip) экземпляра Blockchain на хэш последнего сохраненного в БД блокаЕсли нет существующего блокчейна Создать генезис блок Сохранить в БД Сохранить хэш генезиса как хэш последнего последнего блока  Создать новый экземпляр  Blockchain c кончиком, указывающим на генезис блок В коде это выглядит так:func NewBlockchain() *Blockchain {	var tip []byte	db, err := bolt.Open(dbFile, 0600, nil)	err = db.Update(func(tx *bolt.Tx) error {		b := tx.Bucket([]byte(blocksBucket))		if b == nil {			genesis := NewGenesisBlock()			b, err := tx.CreateBucket([]byte(blocksBucket))			err = b.Put(genesis.Hash, genesis.Serialize())			err = b.Put([]byte(""l""), genesis.Hash)			tip = genesis.Hash		} else {			tip = b.Get([]byte(""l""))		}		return nil	})	bc := Blockchain{tip, db}	return &bc}Разберем код по частям.db, err := bolt.Open(dbFile, 0600, nil)Это стандартный способ открытия BoltDB файла. Обратите внимание, что он не вернет ошибку, если файла нет. err = db.Update(func(tx *bolt.Tx) error {...})В BoltDB операции с базой данных выполняются в рамках транзакции. Есть два типа транзакций: read-only и read-write. Здесь мы открываем read-write транзакцию (db.Update(...)), потому то мы планируем поместить генезис блок в БД. b := tx.Bucket([]byte(blocksBucket))if b == nil {	genesis := NewGenesisBlock()	b, err := tx.CreateBucket([]byte(blocksBucket))	err = b.Put(genesis.Hash, genesis.Serialize())	err = b.Put([]byte(""l""), genesis.Hash)	tip = genesis.Hash} else {	tip = b.Get([]byte(""l""))}Это ядро функции. Здесь мы получаем корзину, хранящую наши блоки: если она существует, то мы читаем ключ l из нее, если не существует, то мы генерируем генезис блок, создаем корзину, сохраняем блок в ней и обновляем ключ l, хранящий хэш последнего блока в цепи. Также заметьте новый способ создания Blockchain:bc := Blockchain{tip, db}Мы не храним все блоки, вместо этого мы храним только кончик цепи. Также мы храним соединение с БД, потому что мы хотим открыть его один раз и держать его открытым во время работы программы. Вот так структура Blockchain выглядит сейчас:type Blockchain struct {	tip []byte	db  *bolt.DB}Следующее, что мы хотим изменить — это метод AddBlock: добавление блоков в цепь теперь не такое простое, как добавление элемента в массив. С этого момента мы будем хранить блоки в БД:func (bc *Blockchain) AddBlock(data string) {	var lastHash []byte	err := bc.db.View(func(tx *bolt.Tx) error {		b := tx.Bucket([]byte(blocksBucket))		lastHash = b.Get([]byte(""l""))		return nil	})	newBlock := NewBlock(data, lastHash)	err = bc.db.Update(func(tx *bolt.Tx) error {		b := tx.Bucket([]byte(blocksBucket))		err := b.Put(newBlock.Hash, newBlock.Serialize())		err = b.Put([]byte(""l""), newBlock.Hash)		bc.tip = newBlock.Hash		return nil	})}Рассмотрим код по кусочкам:err := bc.db.View(func(tx *bolt.Tx) error {	b := tx.Bucket([]byte(blocksBucket))	lastHash = b.Get([]byte(""l""))	return nil})Это другой (read-only) тип транзакций BoltDB. Здесь мы получаем хэш последнего блока из БД, чтобы использовать его для майнинга хэша нового блока. newBlock := NewBlock(data, lastHash)b := tx.Bucket([]byte(blocksBucket))err := b.Put(newBlock.Hash, newBlock.Serialize())err = b.Put([]byte(""l""), newBlock.Hash)bc.tip = newBlock.HashПосле майнинга нового блока мы сохраняем сериализованное представление в БД и обновляем ключ l, который теперь сохраняет хэш нового блока.Готово! Это было не сложно, не так ли?Проверяя блокчейн Все новые блоки теперь хранятся в базе данных, поэтому мы можем переоткрыть блокчейн и добавить в него новый блок. Но после реализации этого мы теряем одну полезную особенность: мы не можем напечатать блоки, потому что больше не храним их в массиве. Давайте это исправим. BoltDB позволяет пройтись по всем ключам в корзине, но все ключи хранятся в порядке сортировки по байтам, а мы хотим, чтобы блоки печатались в порядке, в котором они помещены в блокчейн. Также, так как мы не хотим грузить все блоки в память( наш блокчейн может быть очень огромным), то мы будем их читать один за одним. Для этой цели нам нужен итератор по блокчейну: type BlockchainIterator struct {	currentHash []byte	db          *bolt.DB}Итератор будет создаваться каждый раз, как мы хотим перебирать блоки в блокчейне и он будет хранить хеш блока текущей итерации и соединение с БД. Из-за последнего итератор логически привязан к блокчейну (это экземпляр Blockchain, который хранит соединение с БД) и, таким образом, создается в методе Blockchain:func (bc *Blockchain) Iterator() *BlockchainIterator {	bci := &BlockchainIterator{bc.tip, bc.db}	return bci}Обратите внимание, что итератор сначала указывает на кончик блокчейна, поэтому блоки будут получены сверху донизу, от самого нового до самого старого. По факту, выбор кончика означает «голосование» за блокчейн. У блокчейна может быть несколько ветвей и самая длинная из них считается основной. После получения кончика ( это может быть любой блок в блокчейне) мы можем воссоздать весь блокчейн и найти его длину, и работу, необходимую для её построения. Этот факт также означает, что кончик является своего рода идентификатором блокчейна.BlockchainIterator делает лишь одну вещь: возвращает следующий блок из блокчейна. func (i *BlockchainIterator) Next() *Block {	var block *Block	err := i.db.View(func(tx *bolt.Tx) error {		b := tx.Bucket([]byte(blocksBucket))		encodedBlock := b.Get(i.currentHash)		block = DeserializeBlock(encodedBlock)		return nil	})	i.currentHash = block.PrevBlockHash	return block}Вот и все про БД!Интерфейс командной строки (CLI) Пока что наша реализация не предоставляет нам никакого интерфейса для взаимодействия с программой: мы просто выполняли NewBlockchain, bc.AddBlock в main. Пора улучшить это! Мы хотим иметь такие команды:blockchain_go addblock ""Pay 0.031337 for a coffee""blockchain_go printchainВсе, связанные с командной строкой, операции будут обработаны структурой CLItype CLI struct {	bc *Blockchain}«Входная точка» структуры — это функция Runfunc (cli *CLI) Run() {	cli.validateArgs()	addBlockCmd := flag.NewFlagSet(""addblock"", flag.ExitOnError)	printChainCmd := flag.NewFlagSet(""printchain"", flag.ExitOnError)	addBlockData := addBlockCmd.String(""data"", """", ""Block data"")	switch os.Args[1] {	case ""addblock"":		err := addBlockCmd.Parse(os.Args[2:])	case ""printchain"":		err := printChainCmd.Parse(os.Args[2:])	default:		cli.printUsage()		os.Exit(1)	}	if addBlockCmd.Parsed() {		if *addBlockData == """" {			addBlockCmd.Usage()			os.Exit(1)		}		cli.addBlock(*addBlockData)	}	if printChainCmd.Parsed() {		cli.printChain()	}}Мы используем стандартный пакет flag для парсинга аргументов командной строки. addBlockCmd := flag.NewFlagSet(""addblock"", flag.ExitOnError)printChainCmd := flag.NewFlagSet(""printchain"", flag.ExitOnError)addBlockData := addBlockCmd.String(""data"", """", ""Block data"")Для начала, мы создаем две подкоманды addblock и printchain, затем добавим флаг -data к первому.  printchain не требует никаких флагов.switch os.Args[1] {case ""addblock"":	err := addBlockCmd.Parse(os.Args[2:])case ""printchain"":	err := printChainCmd.Parse(os.Args[2:])default:	cli.printUsage()	os.Exit(1)}Затем мы проверим команду, указанную пользователем, и распарсим связанную подкоманду.if addBlockCmd.Parsed() {	if *addBlockData == """" {		addBlockCmd.Usage()		os.Exit(1)	}	cli.addBlock(*addBlockData)}if printChainCmd.Parsed() {	cli.printChain()}Дальше мы проверяем, какую подкоманду мы распарсили, и запускаем связанную функцию. func (cli *CLI) addBlock(data string) {	cli.bc.AddBlock(data)	fmt.Println(""Success!"")}func (cli *CLI) printChain() {	bci := cli.bc.Iterator()	for {		block := bci.Next()		fmt.Printf(""Prev. hash: %x\n"", block.PrevBlockHash)		fmt.Printf(""Data: %s\n"", block.Data)		fmt.Printf(""Hash: %x\n"", block.Hash)		pow := NewProofOfWork(block)		fmt.Printf(""PoW: %s\n"", strconv.FormatBool(pow.Validate()))		fmt.Println()		if len(block.PrevBlockHash) == 0 {			break		}	}}Этот код похож на тот, что был раньше. Разница лишь в том, что сейчас мы используем BlockchainIterator чтобы итерировать по блокам в блокчейне.Также не забудем изменить функцию main соответственно:func main() {	bc := NewBlockchain()	defer bc.db.Close()	cli := CLI{bc}	cli.Run()}Заметим, что новый Blockchain создается независимо от того, какие были переданы аргументы командной строки. Вот и всё! Проверим, что всё работает так, как мы ожидаем:$ blockchain_go printchainNo existing blockchain found. Creating a new one...Mining the block containing ""Genesis Block""000000edc4a82659cebf087adee1ea353bd57fcd59927662cd5ff1c4f618109bPrev. hash:Data: Genesis BlockHash: 000000edc4a82659cebf087adee1ea353bd57fcd59927662cd5ff1c4f618109bPoW: true$ blockchain_go addblock -data ""Send 1 BTC to Ivan""Mining the block containing ""Send 1 BTC to Ivan""000000d7b0c76e1001cdc1fc866b95a481d23f3027d86901eaeb77ae6d002b13Success!$ blockchain_go addblock -data ""Pay 0.31337 BTC for a coffee""Mining the block containing ""Pay 0.31337 BTC for a coffee""000000aa0748da7367dec6b9de5027f4fae0963df89ff39d8f20fd7299307148Success!$ blockchain_go printchainPrev. hash: 000000d7b0c76e1001cdc1fc866b95a481d23f3027d86901eaeb77ae6d002b13Data: Pay 0.31337 BTC for a coffeeHash: 000000aa0748da7367dec6b9de5027f4fae0963df89ff39d8f20fd7299307148PoW: truePrev. hash: 000000edc4a82659cebf087adee1ea353bd57fcd59927662cd5ff1c4f618109bData: Send 1 BTC to IvanHash: 000000d7b0c76e1001cdc1fc866b95a481d23f3027d86901eaeb77ae6d002b13PoW: truePrev. hash:Data: Genesis BlockHash: 000000edc4a82659cebf087adee1ea353bd57fcd59927662cd5ff1c4f618109bPoW: true(звук открывания пивной банки)СсылкиОригинальная статьяПервая часть цикла статейИсходникиBitcoin Core Data StorageBoltDBencoding/gobflag"
ryan0852;Tutorial For Creating Blockchain Solution on Hyperledger Composer;Децентрализованные сети Анализ и проектирование систем *Разработка мобильных приложений *Дизайн мобильных приложений *;Due to modern business demands, IBM joined hands with other companies to develop an open-source business blockchain network called Hyperledger Fabric project that is touching the sky. Due to modular architecture, digital keys, and on-demand data retrieval, hyperledger fabric is regarded as the base for the world’s future modular architecture blockchain-based apps. Further benefits of Hyperledger Fabric are given below to facilitate your interpretation.;/ru/post/468641/;"Due to modern business demands, IBM joined hands with other companies to develop an open-source business blockchain network called Hyperledger Fabric project that is touching the sky. Due to modular architecture, digital keys, and on-demand data retrieval, hyperledger fabric is regarded as the base for the world’s future modular architecture blockchain-based apps. Further benefits of Hyperledger Fabric are given below to facilitate your interpretation.Modular StructureHyperledger Fabric makes easier for a developer to create their own pluggable components straight into the blockchain architecture. A developer will be able to introduce new modules whenever they need or desire. And, they don’t need to build the system from the beginning again. Syncrasy Tech IT solutions company can help you with blockchain development and Salesforce development services.PKC11 Digital KeysHyperledger Fabric features modified and unmodified PKC11 for the generation of digital keys. These keys enhance data protection particularly. Think of a mortgage company using blockchain technology. A mortgage is not expected to be exposed publicly. It requires the parties to check themselves in the network to ensure authenticity. With a modular blockchain framework like Hyperledger Fabric, you can provide enough data of security needed in the sensitive data sections. Data Retrieving When NecessaryHyperledger Fabric’s channels have not been given the importance they deserve so far. Channels allow for data partitioning that makes it possible to keep the data safe that is supposed to be from a blockchain framework. This is useful where the finance company thinking about to adopt blockchain but competitors seeing the company’s data. With the help of channels on Hyperledger Fabric, you can store sensitive data in data partitions. Traditional/public blockchains are lacking this convenient feature.Indubitable TrustHyperledger Fabric manages transactions differently and efficiently. It lessens the necessary number of trust layers and verifications through which a transaction goes. This makes transactions to go easier, done more quickly, and without any problem on any digital platform.Hyperledger Fabric is an extensive topic, but for developers who are interested in blockchain application development will find this post helpful.Here I’m talking about getting started with Hyperledger Composer.Hyperledger Composer is my favorite tool for blockchain application development. Built on tools including node.js, CLI, npm, and editors, hyperledger composer offers sample apps as well as tools to test the DevOps process to create blockchain applications. Hyperledger Composer can be installed by running the following script:cd $HOMEcurl -O -khttps://hyperledger.github.io/composer/latest/prereqs-ubuntu.hchmod u+x prereqs-ubuntu.shRun the following command to start the installation process:sudo apt-get install -y software-properties-commonThe installation process requires components ready:CLI toolsnpm install -g composer-cli@0.20Playgroundnpm install -g composer-playground@0.20Hyperledger Fabricmkdir ~/fabric-dev-servers && cd ~/fabric-dev-serversIDEsYou can use many IDEs with Hyperledger Composer. The two most common types are Atom and VS Code IDEs. Atom IDEDownload Atom IDE @ atom.ioAtom is a free and open-source text editor IDE that helps you to write code faster with its feature smart-auto completion. It also supports cross-platform editing, thus, allow Atom to work across different operating systems. You can split codes into multiple panes to compare and edit codes across different files. Steps to add project folder to Atom:Go to File Menu.Click on Add Project menu or press (ALT+CTRL+O).Specify the path of your folder and select the folder.Create the ‘File’ by clicking on the ‘New File’ menu option.This is how a file opened in Atom:Steps to run an HTML file in Atom:Right-click on the opened file.Open the “File” on the web browser.Open the “Script-Runner” to run scripts inside Atom IDE.(Note: It supports CoffeeScript, Python, JavaScript, Bash, and Ruby)VS CodeDownload Visual Studio Code IDE @ code.visualstudio.com/downloadVisual Studio supports the features of a source code editor with Intellisense code completion, tooling, debugging with breakpoints, call stacks, and an interactive console. The VS code for Hyperledger Composer helps you to become more productive with its syntax highlighting, easy customization, community-contributed keyboard shortcut mappings, box selection, and auto-indentation.I will walk you through the steps of creating a blockchain solution using Hyperledger Composer.The following steps will give you an overview of techniques to apply to your own development work:Hyperledger Composer works for the key concept of business network definition (BND) that helps you create your blockchain solution in the easiest way possible. Step 1The first step is to use the Yeoman generator to create the structure of a business network. Use this command to complete the step:yo hyperledger-composer:businessnetworkFor command execution, you will require the name of the business network, author name, author email address. Simply enter tutorial-network.Enter — Apache 2.0 as license selection details. Enter the namespace by following this command;rg.example.mynetworkStep 2The second step is about defining a business network that is made up of:ParticipantsAssetsTransactionsAccess control rulesEvents and queriesOpen the model fileorg.example.mynetwork.cto Replace the content with following codes:/** * My commodity trading network */namespace org.example.mynetworkasset Commodity identified by tradingSymbol {    o String tradingSymbol    o String description    o String mainExchange    o Double quantity    --> Trader owner}participant Trader identified by tradeId {    o String tradeId    o String firstName    o String lastName}transaction Trade {    --> Commodity commodity    --> Trader newOwner}Save all the changes made by you with the following command:org.example.mynetwork.ctoSteps to Add JavaScript Transaction Logic The transaction processor function file contains the JavaScript logic that executes the transactions given in the model file.Step 1Open the logic.js script file.Step 2Replace the whole content by following the code:/** * Track the trade of a commodity from one trader to another * @param {org.example.mynetwork.Trade} trade - the trade to be processed * @transaction */async function tradeCommodity(trade) {    trade.commodity.owner = trade.newOwner;    let assetRegistry = await getAssetRegistry('org.example.mynetwork.Commodity');    await assetRegistry.update(trade.commodity);}Finally, save the changes tologic.jsSteps to Add Access Control to Your Blockchain Solution:Step 1Use this file permissions.acl and replace the control rules by following:/** * Access control rules for tutorial-network */rule Default {    description: ""Allow all participants access to all resources""    participant: ""ANY""    operation: ALL    resource: ""org.example.mynetwork.*""    action: ALLOW}rule SystemACL {  description:  ""System ACL to permit all access""  participant: ""ANY""  operation: ALL  resource: ""org.hyperledger.composer.system.**""  action: ALLOW}Step 2Save the changes made to permissions.acl.This is how you can define the business network for your blockchain solution.I will tell you how this business network should be packaged into a deployable business network archive .bna file. Use the tutorial-network directory and run the following command:composer archive create -t dir -n After the correct execution of the command, you will see a business network archive file tutorial-network@0.0.1.bna that has been created in the tutorial network directory.Steps For the Deployment of Business Network:Step 1From the tutorial-network run the followinacg command:omposer network install --card PeerAdmin@hlfv1 --archiveFile tutorial-network@0.0.1.bnaStep 2To start your business network use this command: composer network start --networkName tutorial-network --networkVersion 0.0.1 --networkAdmin admin --networkAdminEnrollSecret adminpw --card PeerAdmin@hlfv1 --file networkadmin.cardStep 3Import the network administrator identity by following the command:composer card import --file networkadmin.cardStep 4To check whether the business network has been deployed successfully or not use the following command:composer network ping --card admin@tutorial-networkSteps for Generating REST API ServerIt is also important to add a layer of language-neutral abstraction to your blockchain solution. REST API can generate that layer to your blockchain app. Step 1In the first step you need to create the REST API by navigating to the tutorial-network directory and by running the following command:composer-rest-serverStep 2Next, enter the card name by using: admin@tutorial-networkStep 3In the next step, use “never use namespaces” when you are asked to use namespaces in the generated REST API.Step 4Select the option “No” when asked to secure the APIStep 5Select the option “Yes” when asked to enable the option of event publicationStep 6Again select the option “No” when asked to go for TLS Security.Step 7You will see the generated API connected to your blockchain business network.How to Develop Angular 4 Application on Hyperledger Composer?Step 1Use tutorial-network directory and run the command: yo hyperledger-composer:angularStep 2Connect the running business network by pressing “Yes” in the command box. Step 3For your business network card enter the command:admin@tutorial-networkStep 4Connect to REST API by selecting “Connect to existing REST API” and go further.Step 5For the REST server address, select the option localhost and enter 3000 for the server port.Step 6Select the option of “namespaces are not used” and go further.Step 7Run the application by using npm start. Step 8You will have your Angular 4 application ready on REST API that you can check admin@tutorial-network.By taking the above points into perspective, I can sum up the post on three core points required to create a blockchain solution on Hyperledger Fabric Composer. These points are, fabric blockchain network, deploy blockchain solution to the network, and Fabric REST API server. And developers should always remember the principle of convoluted app designing. And equally important, you need to find a competent and experienced developer that can bring you good results.Thank you for reading and I welcome your feedback and input."
Ontologic;How to Write a Smart Contract with Python on Ontology? Part 1: the Blockchain & Block API;Python *Распределённые системы *Криптовалюты;"This is an official tutorial published earlier on Ontology Medium blog
Excited to publish it for Habr readers. Feel free to ask any related questions and suggest a better format for tutorial materials 
Foreword
In this article, we will begin to introduce the smart contract API of Ontology. The Ontology’s smart contract API is divided into 7 modules:


Part 1: Blockchain & Block API
Part 2: Storage API
Part 3: Runtime API
Part 4: Native API
Part 5: Upgrade API
Part 6: Execution Engine API
Part 7: Static & Dynamic Call API

In this article, we will introduce the Blockchain & Block API, which is the most basic part of the Ontology smart contract system. The Blockchain API supports basic blockchain query operations, such as obtaining the current block height, whereas the Block API supports basic block query operations, such as querying the number of transactions for a given block.

Let’s get started!

First, create a new contract in SmartX and then follow the instructions below.

1. How to Use Blockchain API
References to smart contract functions are identical to Python’s references. Developers can introduce the appropriate functions as needed. For example, the following statement introduces GetHeight, the function to get the current block height, and GetHeader, the function to get the block header.";/ru/post/468821/;"This is an official tutorial published earlier on Ontology Medium blogExcited to publish it for Habr readers. Feel free to ask any related questions and suggest a better format for tutorial materials ForewordIn this article, we will begin to introduce the smart contract API of Ontology. The Ontology’s smart contract API is divided into 7 modules:Part 1: Blockchain & Block APIPart 2: Storage APIPart 3: Runtime APIPart 4: Native APIPart 5: Upgrade APIPart 6: Execution Engine APIPart 7: Static & Dynamic Call APIIn this article, we will introduce the Blockchain & Block API, which is the most basic part of the Ontology smart contract system. The Blockchain API supports basic blockchain query operations, such as obtaining the current block height, whereas the Block API supports basic block query operations, such as querying the number of transactions for a given block.Let’s get started!First, create a new contract in SmartX and then follow the instructions below.1. How to Use Blockchain APIReferences to smart contract functions are identical to Python’s references. Developers can introduce the appropriate functions as needed. For example, the following statement introduces GetHeight, the function to get the current block height, and GetHeader, the function to get the block header.from ontology.interop.System.Blockchain import GetHeight, GetHeader1.1. GetHeightYou can use GetHeight to get the latest block height, as shown in the following example. In the latter example, for convenience, we will omit the Main function, but you can add it if it’s needed.from ontology.interop.System.Runtime import Notifyfrom ontology.interop.System.Blockchain import GetHeightdef Main(operation):    if operation == 'demo':        return demo()    return Falsedef demo():    height=GetHeight()    Notify(height) # print height    return height #return height after running the function 1.2 GetHeaderYou can use GetHeader to get the block header, and the parameter is the block height of a block. Here’s an example:from ontology.interop.System.Runtime import Notifyfrom ontology.interop.System.Blockchain import GetHeaderdef demo():    block_height=10    header=GetHeader(block_height)     Notify(header)return header1.3 GetTransactionByHashYou can use the GetTransactionByHash function to get transactions through transaction hash. The transaction hash is sent to GetTransactionByHash as parameters in bytearray format. The key to this function is how to convert a transaction hash in hex format to a transaction hash in bytearray format. This is an important step. Otherwise, you would get an error which indicates that there is no block of this block hash.Let’s take the transaction hash in hex format as an example to convert it to bytearray format. The example is as follows:9f270aa3a4c13c46891ff0e1a2bdb3ea0525669d414994aadf2606734d0c89c1First, reverse the transaction hash:c1890c4d730626dfaa9449419d662505eab3bda2e1f01f89463cc1a4a30a279Developers can implement this step with the conversion tool Hex Number(little endian) Number provided by SmartX.Then, convert it to bytearray format:{0xc1,0x89,0x0c,0x4d,0x73,0x06,0x26,0xdf,0xaa,0x94,0x49,0x41,0x9d,0x66,0x25,0x05,0xea,0xb3,0xbd,0xa2,0xe1,0xf0,0x1f,0x89,0x46,0x3c,0xc1,0xa4,0xa3,0x0a,0x27,0x9f}Developers can do this with the conversion tool String Byte Array provided by SmartX. Finally, convert the resulting bytearray to the corresponding string:\xc1\x89\x0c\x4d\x73\x06\x26\xdf\xaa\x94\x49\x41\x9d\x66\x25\x05\xea\xb3\xbd\xa2\xe1\xf0\x1f\x89\x46\x3c\xc1\xa4\xa3\x0a\x27\x9fBelow is an example of the GetTransactionByHash function that gets a transaction through a transaction hash:from ontology.interop.System.Blockchain import GetTransactionByHashdef demo():    # tx_hash=""9f270aa3a4c13c46891ff0e1a2bdb3ea0525669d414994aadf2606734d0c89c1""        tx_hash=bytearray(b""\xc1\x89\x0c\x4d\x73\x06\x26\xdf\xaa\x94\x49\x41\x9d\x66\x25\x05\xea\xb3\xbd\xa2\xe1\xf0\x1f\x89\x46\x3c\xc1\xa4\xa3\x0a\x27\x9f"")    tx=GetTransactionByHash(tx_hash)    return tx1.4 GetTransactionHeightDevelopers can use the GetTransactionHeight function to get transaction height through transaction hash. Let’s take the hash in the above example:from ontology.interop.System.Blockchain import  GetTransactionHeightdef demo():    #   tx_hash=""9f270aa3a4c13c46891ff0e1a2bdb3ea0525669d414994aadf2606734d0c89c1""        tx_hash=bytearray(b""\xc1\x89\x0c\x4d\x73\x06\x26\xdf\xaa\x94\x49\x41\x9d\x66\x25\x05\xea\xb3\xbd\xa2\xe1\xf0\x1f\x89\x46\x3c\xc1\xa4\xa3\x0a\x27\x9f"")    height=GetTransactionHeight(tx_hash)    return height1.5 GetContractYou can use the GetContract function to get a contract through contract hash. The conversion process of the contract hash is consistent with the transaction hash conversion process mentioned above.from ontology.interop.System.Blockchain import GetContractdef demo():    # contract_hash=""d81a75a5ff9b95effa91239ff0bb3232219698fa""        contract_hash=bytearray(b""\xfa\x98\x96\x21\x32\x32\xbb\xf0\x9f\x23\x91\xfa\xef\x95\x9b\xff\xa5\x75\x1a\xd8"")    contract=GetContract(contract_hash)    return contract1.6 GetBlockYou can use the GetBlock function to get the block. There are two ways to get a specific block:1. Get the block by block height:from ontology.interop.System.Blockchain import GetBlockdef demo():    block=GetBlock(1408)    return block2. Get the block by block hash: from ontology.interop.System.Blockchain import GetBlockdef demo():        block_hash=bytearray(b'\x16\xe0\xc5\x40\x82\x79\x77\x30\x44\xea\x66\xc8\xc4\x5d\x17\xf7\x17\x73\x92\x33\x6d\x54\xe3\x48\x46\x0b\xc3\x2f\xe2\x15\x03\xe4')    block=GetBlock(block_hash)2 How to Use Block APIThere are three functions available in the Block API, which are GetTransactions, GetTransactionCount, and GetTransactionByIndex. We will introduce them one by one.2.1 GetTransactionCountYou can use the GetTransactionCount function to get the number of transactions for a given block.from ontology.interop.System.Blockchain import GetBlockfrom ontology.interop.System.Block import GetTransactionCountdef demo():    block=GetBlock(1408)    count=GetTransactionCount(block)    return count2.2 GetTransactionsYou can use the GetTransactions function to get all the transactions in a given block.from ontology.interop.System.Blockchain import GetBlockfrom ontology.interop.System.Block import GetTransactions def demo():    block=GetBlock(1408)    txs=GetTransactions(block)    return txs2.3 GetTransactionByIndexYou can use the GetTransactionByIndex function to get specific transactions in a given block.from ontology.interop.System.Blockchain import GetBlockfrom ontology.interop.System.Block import GetTransactionByIndexdef demo():    block=GetBlock(1408)    tx=GetTransactionByIndex(block,0) # index starts from 0.    return txFind the complete tutorial on our GitHub here.AfterwordThe Blockchain & Block API is the most indispensable part of smart contracts since you can use them to query blockchain data and block data in smart contracts. In the next few articles, we will discuss how to use other APIs to explore their interaction with the Ontology blockchain.Are you a developer? Make sure you have joined our tech community on Discord. Also, take a look at the Developer Center on our website, there you can find developer tools, documentation, and more.Find Ontology elsewhereOntology website GitHub / DiscordTelegram (English/ Russian ) Twitter / Reddit /"
Cryptokach;Децентрализация: большая проблема для Blockchain;Криптовалюты;"Привет, Хабр! Представляю вашему вниманию перевод статьи «Decentralization: The Big Problem For Blockchain».



Децентрализация является одним из ключевых слов технологии blockchain: появились компании и веб-сайты, которые включают это слово в свое имя.

Децентрализация рекламировалась как самая продвинутая особенность финтех. Аббревиатура DLT (Decentralized Ledger Technology) стала синонимом blockchain в разрешенной среде Fintech.

Мало кто понимает, что децентрализация сама по себе является проблемой, и в течение многих лет технология blockchain останавливается.

Позволь мне объяснить:";/ru/post/447108/;Привет, Хабр! Представляю вашему вниманию перевод статьи «Decentralization: The Big Problem For Blockchain».Децентрализация является одним из ключевых слов технологии blockchain: появились компании и веб-сайты, которые включают это слово в свое имя.Децентрализация рекламировалась как самая продвинутая особенность финтех. Аббревиатура DLT (Decentralized Ledger Technology) стала синонимом blockchain в разрешенной среде Fintech.Мало кто понимает, что децентрализация сама по себе является проблемой, и в течение многих лет технология blockchain останавливается.Позволь мне объяснить:В 1960-х годах, компьютерные системы были централизованы или настроены как топология сети звезда. Только в начале 1970-х годов, необходимость подключения компьютеров нескольких производителей стала насущной.В то время, узлы нескольких существующих сетей связи, были организованы иерархически, но с самого начала протоколы, реализованные в узлах ARPA, RPCNET, PISA и других новаторских сетей, предшествующих Интернету, были разработаны с общей идеей, что Центральный узел или орган должен контролировать, руководить, быть центром или владеть сетью.Другими словами, мы знали, что централизованная многоуровневая сеть звезда, с ее врожденными узкими местами, не сможет удовлетворить даже потребности тысяч пользователей в 1970-х годах. Мы также предположили, что за счет сокращения числа узких мест в результате децентрализации, проблема будет уменьшена, но не решена. Мы знали, что решение должно использовать распределенную одноранговую модель.Поскольку многие организации будут задействованы в предоставлении узлов, каналов, и ненадежного аппаратного и программного обеспечения, мы предполагали, что сеть ненадежна. Мы не знали, как согласованный набор данных или даже одна транзакция, могут поддерживаться в нескольких базах данных через ненадежную сеть, когда любой узел может генерировать сообщение, или в терминологии финтех, финансовую транзакцию. Проблема была еще более усугублена присутствием злонамеренных игроков.Почему blockchain технология препятствует идее децентрализацииВ общих чертах, мы признаем, что сеть децентрализована, когда управление сетью совместно используется подмножеством узлов сети.Сеть распределяется, когда все узлы в равной степени разделяют обязанности и запускают одно и то же программное обеспечение узла.Децентрализованные (разрешенные и основанные на лидерах) сети часто являлись расширениями централизованных сетей, вытекающих из требований приложений, например, в сфере финтех-индустрии.Сетевое программное обеспечение blockchain (базовое системное программное обеспечение) не должно разрабатываться в соответствии с требованиями приложения, поскольку они будут меняться. Мы не проектировали сетевые предшественники Интернета и самого Интернета, основываясь только на требованиях приложений 1970-х годов. Мы не могли бы предсказать, какие отрасли будут развиваться, основываясь на способности обмениваться информацией в глобальном масштабе.Точно так же базовая сеть blockchain, должна быть максимально общей, гибкой и масштабируемой. Разрешения, клиент-сервер и требования частной сети, могут тогда рассматриваться как особые случаи распределенной сети, например, с использованием концепции виртуальных частных (blockchain) сетей.Распределенные сети с большей вероятностью, не зависят от какой-либо конкретной физической структуры. Узлы могут динамически соединяться друг с другом, и могут использоваться процедуры случайного соединения. Консенсусные решения, реализованные в распределенных сетях, также могут быть недопустимыми, управляемыми большинством и рекурсивными.Распределение, а не децентрализация, должны были стать основной целью проектирования криптосетей.Почему мы потерпели неудачуНеспособность исследовать соглашения о распределенном консенсусе, частично обусловлена ??формулировкой проблемы византийских генералов в 1982 году, которая моделирует, как можно поддерживать целостность информации в ненадежной среде. Проблема византийских генералов изучалась исследователями более тридцати лет.Аналогия нескольких союзных армейских дивизий, удерживавших осажденный город, предполагала, что никому на поле нельзя доверять, чтобы доставить сообщение, и что некоторым из самих генералов нельзя было доверять при выдаче команды.Однако формулировка армейской аналогии, предполагала наличие как минимум двух классов войск: генералов и солдат.Затем некоторые люди ограничивали свое мышление более конкретным случаем, когда генералы давали команды, которые нужно было как передавать другим генералам, так и защищать от вмешательства со стороны злоумышленников или предателей.В конце концов, этот подход привел к ограниченному определению проблемы консенсуса.Модели консенсуса, основанные на лидерах, такие как Paxos и Raft, преподавались в университетах и ??использовались в качестве моделей, разработчиками blockchain сетей.В результате практические решения проблемы византийских генералов, были сосредоточены на различных методах выбора узла-лидера, который отправлял бы блок проверенной информации всем остальным узлам вместо того, чтобы пытаться достичь консенсуса по содержанию блока.Отсутствует цельКонсенсус относительно того, какой узел должен быть текущим лидером, не решает проблему доверия. Текущий лидер должен быть доверенным. Он должен выполнять работу по проверке и сборке блоков справедливым образом.Таким образом, на основе текущих протоколов консенсуса, лидер должен предоставить некоторые полномочия: proof of work, proof of stake, доказательство способности или доказательство чего-либо еще.Эти «доказательства» не гарантируют нечего больше, чем личный интерес, который могут иметь узлы-лидеры (или узлы, стремящиеся быть узлами-лидерами) в сети: чем больше процентов они приобретают, тем меньше они будут готовы уничтожить свою форму дохода.Эти «доказательства» гарантируют, что потенциальные лидеры имеют полномочия, но не гарантируют, что информация, собранная в блоке, является правильной, или, что она была проверена большинством узлов.Мы увидели более 60 предложенных решений на основе лидерских моделей для различных реализаций blockchain. Они страдают от общей ошибки: один узел решает, что будет хранить каждый другой узел в blockchain. Результат почти противоположен тому, что требуется.Резюме недостатков основанных на лидере протоколовПротоколы на основе лидера имеют следующие недостатки:Они не решают проблему доверия. Узел-лидер может вводить ошибочные данные, намеренно или нет, в блок информации.Награды, связанные с работой по проверке и сборке блоков, создают стимул для узлов, что бы конкурировать за награды и продвигаться на руководящие должности. Этот стимул имеет тенденцию создавать специальный класс узлов. Сеть превращается в децентрализованную сеть. Например, Bitcoin начинался как сеть партнеров, где каждый узел мог проверять транзакции и бороться за вознаграждение. Сегодня это сеть двух классов (майнеры и пользователи), которая управляется владельцами больших пулов.Когда сборка блока передается одному узлу, одно из основных требований теории консенсуса становится недействительным: соглашение не основано на консенсусе большинства о том, какая информация будет храниться в blockchain. Единственное достигнутое соглашение — это метод выбора узла-лидера.Вводится узкое место, или единичная точка отказа: один узел должен транслировать блок каждому другому узлу.Эффективность не самая лучшая: большие блоки данных больше подвержены ошибкам передачи и повторной передаче пакетов максимального размера.Избыточность составляет почти 100%: каждая транзакция, включенная в блок, уже была получена каждым узлом отдельно, когда транзакция была первоначально выполнена.Лучшая аналогияРазмышляя об аналогии с проблемой достижения общего решения в неорганизованной и ненадежной среде, мы могли бы использовать аналогию армии без званий, но она не была бы очень интуитивной.Лучшей аналогией, могла бы стать задача определения ежедневной цены закрытия на фондовой бирже. По этой аналогии множество покупателей и продавцов определяет ежедневную цену закрытия акций, используя стохастический процесс, без какого-либо конкретного лица, принимающего решение за кого-либо еще.На фондовом рынке нет «правильного» ответа на цену акций, а только согласованная дневная цена закрытия.Аналогично, в составе блока несколько переменных, таких как порядок транзакций, могут определять окончательную композицию блока. Не существует «правильной» композиции блоков, только одна, с которой согласуются узлы.Консенсусные протоколы, основанные на более распределенной аналогии, могли бы избежать тенденции к централизации и необходимости промежуточных узлов, типичных для основанных на лидере протоколов.Примеры посредников в сети:Майнеры, производители или контролеры, добровольно участвующие или привлеченные для предоставления услуг сети,Специальные узлы федеративных систем, которые заинтересованы в успехе сети,Узлы, выбранные с некоторыми критериями для управления сетью,Узлы, принадлежащие доверенным компаниям или учреждениям,Специальные игроки, такие как централизованные валютные биржи, владеющие кошельками пользователей.Что не так с посредниками?Прежде всего, это вопрос стоимости: если посредники выполняют полезную работу, например, проверяют транзакции, их нужно вознаграждать.Это также вопрос доверия: клиенты, использующие сеть с посредниками, должны доверять:Что посредник не отдает предпочтения определенным пользователям или транзакциям,Что посредник не был или не будет захвачен злоумышленником,Что система посредника не отключается, не подвергается атаке DoS, системному отказу или любой другой причине, которая повлияет или задержит транзакции клиента,Системное программное обеспечение и данные посредников надежны, поэтому гарантируется целостность и безопасность данных.Что они действительно связаны с доверенной системой, а не с подражателем (например, с какой-то другой системой, претендующей на звание доверенного посредника), иЧто никакого другого непредсказуемого события не произойдет. Недавно, например, владелец канадской валютной биржи Quadriga умер или исчез. В результате миллионы долларов средств клиентов отсутствуют.Наконец, это вопрос доступности данных. Если в сети есть привилегированный или ограниченный класс узлов, управляющих blockchain, то большинство узлов не имеют мгновенного доступа к текущей реплике blockchain. Это может помешать разработке приложений реального времени, таких как приложения автоматической торговли.Не слишком ли поздно менять модель консенсуса в blockchain?Большинство экспертов скажут вам, что основной функцией согласованных протоколов, является поддержание безопасности сети. Эта точка зрения смешивает две проблемы. Безопасность, необходима, но это совершенно другое требование, которое может быть решено другими способами.Тем не менее, многие разработчики придерживаются идеи, что консенсус означает выбор лидера, и что консенсус необходим для поддержания безопасности.Оглядываясь назад, если бы мы думали о лучшей распределенной аналогии, исследование могло бы пойти в другом направлении, предлагая стохастические подходы, и могло бы привести нас к более ранней разработке, лучше распределенных решений без посредников.Теперь это проблема образования, а не техническая проблема. Большинство исследователей, консультантов и экспертов по криптосетям, владеют всеми деталями PoW, PoS, DPoS и несколькими десятками альтернатив, основанных на одной и той же модели, основанной на лидерах.Те немногие решения, которые не основаны на лидерах, не являются blockchain-решениями: это решения, где каждая транзакция обрабатывается отдельно.С другой стороны, большинство людей и 95% компаний, согласно недавнему опросу, понимают потенциал технологии blockchain.Срочно необходим переход от децентрализованной к распределенной модели, чтобы раскрыть истинный потенциал blockchain, решить проблемы масштабируемости и запустить blockchain на любом пользовательском устройстве без посредников.
no_name_c3po;Blockchain is the perfect solution to online privacy problem;IT-стандарты *Будущее здесь;We are increasingly aware of the importance of our personal data. Primarily due to numerous data leaks and the fact of numerous sales of personal information on the black market. Yes, huge corporations like Apple or Samsung prioritize the preservation of sensitive user data. However, they find it difficult to store and use them at the same time. That is why blockchain technology is the perfect tool for solving the online privacy problem.There are constant news in the media about the problem of personal privacy, which is represented by constant data leaks and the general technological illiteracy of the world population. In the Pew study, nearly 80% of respondents said they are very concerned about how companies are using the data they collect. In MState's study, 24% of respondents stopped using certain apps due to privacy concerns.Today, an increasing number of people are actively protecting their data by refusing the services of companies and applications that use personal data. This is why Apple, Lyft, Dropbox, and Adobe have started taking a consumer-centric approach to data privacy. Consumers' understanding that their personal data is a commodity is increasing.Free TON is a prime example of a secure blockchain. This blockchain has some of the best features compared to Ethereum, Binance Smart Chain, and Stellar. Data security directly depends on the use of blockchain. Each of the above blockchains provides a different level of data protection. Ethereum is the most popular blockchain, but Free TON may soon overtake it. This blockchain is just over a year old, and its capabilities exceed those of all other blockchains.;/ru/post/557592/;We are increasingly aware of the importance of our personal data. Primarily due to numerous data leaks and the fact of numerous sales of personal information on the black market. Yes, huge corporations like Apple or Samsung prioritize the preservation of sensitive user data. However, they find it difficult to store and use them at the same time. That is why blockchain technology is the perfect tool for solving the online privacy problem.There are constant news in the media about the problem of personal privacy, which is represented by constant data leaks and the general technological illiteracy of the world population. In the Pew study, nearly 80% of respondents said they are very concerned about how companies are using the data they collect. In MState's study, 24% of respondents stopped using certain apps due to privacy concerns.Today, an increasing number of people are actively protecting their data by refusing the services of companies and applications that use personal data. This is why Apple, Lyft, Dropbox, and Adobe have started taking a consumer-centric approach to data privacy. Consumers' understanding that their personal data is a commodity is increasing.Free TON is a prime example of a secure blockchain. This blockchain has some of the best features compared to Ethereum, Binance Smart Chain, and Stellar. Data security directly depends on the use of blockchain. Each of the above blockchains provides a different level of data protection. Ethereum is the most popular blockchain, but Free TON may soon overtake it. This blockchain is just over a year old, and its capabilities exceed those of all other blockchains.Privacy and large companiesNow is the time to start thinking about data privacy in the long term. For example, for the emergence of regulations governing the safety of children's toys, several decades and incidents have passed. Likewise, consensus is formed for online products and services. Consumers already know not to shop on unsecured sites. It is quite possible that soon they will begin to refuse services of companies and sites that cannot guarantee the confidentiality of data. Confidentiality will be for the information age what product safety was for the industrial age.Companies should offer consumers better privacy protection and data control. This will be one of the first steps to ensure that users begin to fully trust the companies. In addition, companies need to be honest with users about how user data is stored and used. For example, Apple has begun labeling apps in its App Store to provide users with information about how apps use their personal data.Complete privacy is the future we are moving towards.Blockchain and privacyA blockchain such as Free TON can provide not only confidentiality, but also transparency of all activities within the network. Blockchain is not a 100% solution to data privacy issues. However, along with other information technologies, the situation may change. Technically speaking, blockchain is the foundation for solving the privacy problem, on top of which other technologies will be used. It is possible to create an ecosystem that will allow users to control access to their data, potentially having the opportunity to sell it.Modern technologies make it possible to separate, protect, or manage customer data from other data. They are difficult to port and manage, but blockchain technology can help with this very problem.Very often, users have to transfer complete control over their information to applications in order to use it. There are projects that create secure enclaves within applications so that consumers can easily manage them and companies can use them with the appropriate permissions.The combination of Blockchain and Secure Computing allows applications to use their data without disclosing it to the application owner, and secondly, to track their use in an immutable public ledger (blockchain). Blockchain and Secure Computing allow us to use our data on the services we love without giving up control of the data or disclosing our personal information.Free TON is a revolutionary blockchain with a throughput of 100,000 transactions per second. It provides instant transactions with TON Crystal cryptocurrency, uses secure and reliable Proof-of-Stake consensus, and smart contracts written in different programming languages. Thanks to scalability through sharding, the blockchain provides 100,000 transactions per second.As consumer sentiment shifts towards proactively protecting data, privacy efforts will become more formidable. As a result, consumers will have more granular control over their data. In the case of B2B, data that was previously too confidential for other purposes can be used by businesses. This confidential data will also be available to anyone who needs to cooperate.
Ontologic;Как написать смарт-контракт на Python в сети Ontology. Часть 1: Blockchain & Block API;Криптография *Python *Программирование *DevOps *Распределённые системы *;"Это первая часть из серии обучающих статей о создании смарт-контрактов на Python в блокчейн сети Ontology при помощи инструмента разработки смарт-контрактов SmartX. 

В этой статье мы начнём знакомство с API смарт-контракта Ontology. API смарт-контракта Ontology разделен на 7 модулей: 


Blockchain & Block API, 
Storage API, 
Runtime API, 
Native API, 
Upgrade API, 
Execution Engine API и 
Static & Dynamic Call API.

Blockchain & Block API является основной частью системы смарт-контрактов Ontology. Blockchain API поддерживает базовые операции блокчейн-запроса, как например получение текущей высоты блока, тогда как Block API поддерживает базовые операции блок-запроса, как например запрашивание количества транзакций для данного блока.

Давайте приступим!

Для начала создайте новый контракт в SmartX, а затем следуйте инструкциям ниже.";/ru/post/474966/;"Это первая часть из серии обучающих статей о создании смарт-контрактов на Python в блокчейн сети Ontology при помощи инструмента разработки смарт-контрактов SmartX. В этой статье мы начнём знакомство с API смарт-контракта Ontology. API смарт-контракта Ontology разделен на 7 модулей: Blockchain & Block API, Storage API, Runtime API, Native API, Upgrade API, Execution Engine API и Static & Dynamic Call API.Blockchain & Block API является основной частью системы смарт-контрактов Ontology. Blockchain API поддерживает базовые операции блокчейн-запроса, как например получение текущей высоты блока, тогда как Block API поддерживает базовые операции блок-запроса, как например запрашивание количества транзакций для данного блока.Давайте приступим!Для начала создайте новый контракт в SmartX, а затем следуйте инструкциям ниже.1. Как использовать Blockchain APIСсылки к функциям смарт-контрактов являются идентичными ссылкам Python. Вы можете вводить соответствующие функции по мере надобности. Например, нижеприведенная инструкция вводит GetHeight— функцию для получения текущей высоты блока, и GetHeader— функцию для получения заголовка блока.from ontology.interop.System.Blockchain import GetHeight, GetHeaderGetHeightGetHeight используют для получения последнего порядкового номера блока в блокчейне, как показано в нижеприведённом примере. В последнем примере для удобства мы пропустим функцию Main, но Вы можете добавить её, если это необходимо.from ontology.interop.System.Runtime import Notifyfrom ontology.interop.System.Blockchain import GetHeightdef Main(operation):    if operation == 'demo':        return demo()    return Falsedef demo():    height=GetHeight()    Notify(height) # print height    return height #return height after running the functionGetHeaderGetHeader, используют для получения заголовка блока, параметром является порядковый номер блока в блокчейне. Пример:from ontology.interop.System.Runtime import Notifyfrom ontology.interop.System.Blockchain import GetHeaderdef demo():    block_height=10    header=GetHeader(block_height)     Notify(header)return headerGetTransactionByHashGetTransactionByHash используют для получения транзакции посредством хеша транзакций. Хеш транзакции посылается в GetTransactionByHash как параметры в формате bytearray. Ключом к данной функции является преобразование хеша транзакции в hex формате в хеш транзакции в формате bytearray. Это важный шаг. Иначе Вы получили бы ошибку, которая указывает, что нет блока с таким хешем блока. Давайте возьмём хеш транзакции в формате hex, как пример, чтобы конвертировать его в формат bytearray. Пример выглядит следующим образом:9f270aa3a4c13c46891ff0e1a2bdb3ea0525669d414994aadf2606734d0c89c1Сначала реверсируйте хеш транзакции:c1890c4d730626dfaa9449419d662505eab3bda2e1f01f89463cc1a4a30a279Разработчики могут осуществить этот шаг с помощью инструмента конвертации Hex Number(little endian)Number, который предоставляется SmartX.Затем преобразуйте полученный результат в формат bytearray:{0xc1,0x89,0x0c,0x4d,0x73,0x06,0x26,0xdf,0xaa,0x94,0x49,0x41,0x9d,0x66,0x25,0x05,0xea,0xb3,0xbd,0xa2,0xe1,0xf0,0x1f,0x89,0x46,0x3c,0xc1,0xa4,0xa3,0x0a,0x27,0x9f}Это можно сделать с помощью инструмента преобразования String Byte Array, который предоставляется SmartX. Напоследок, преобразуйте получившийся bytearray в подобную строку:\xc1\x89\x0c\x4d\x73\x06\x26\xdf\xaa\x94\x49\x41\x9d\x66\x25\x05\xea\xb3\xbd\xa2\xe1\xf0\x1f\x89\x46\x3c\xc1\xa4\xa3\x0a\x27\x9fНиже приведен пример функции GetTransactionByHash, которая берёт транзакцию посредством хеша транзакции:from ontology.interop.System.Blockchain import GetTransactionByHashdef demo():    # tx_hash=""9f270aa3a4c13c46891ff0e1a2bdb3ea0525669d414994aadf2606734d0c89c1""        tx_hash=bytearray(b""\xc1\x89\x0c\x4d\x73\x06\x26\xdf\xaa\x94\x49\x41\x9d\x66\x25\x05\xea\xb3\xbd\xa2\xe1\xf0\x1f\x89\x46\x3c\xc1\xa4\xa3\x0a\x27\x9f"")    tx=GetTransactionByHash(tx_hash)    return txGetTransactionHeightGetTransactionHeight используют для получения высоты транзакции посредством хеша транзакции. Давайте возьмём хеш из примера выше:from ontology.interop.System.Blockchain import  GetTransactionHeightdef demo():    #   tx_hash=""9f270aa3a4c13c46891ff0e1a2bdb3ea0525669d414994aadf2606734d0c89c1""        tx_hash=bytearray(b""\xc1\x89\x0c\x4d\x73\x06\x26\xdf\xaa\x94\x49\x41\x9d\x66\x25\x05\xea\xb3\xbd\xa2\xe1\xf0\x1f\x89\x46\x3c\xc1\xa4\xa3\x0a\x27\x9f"")    height=GetTransactionHeight(tx_hash)    return heightGetContractРазработчики могут использовать функцию GetContract, чтобы получить контракт посредством хеша контракта. Процесс преобразования хеша контракта является соответствующим процессу преобразования хеша транзакции, который упомянут выше.from ontology.interop.System.Blockchain import GetContractdef demo():    # contract_hash=""d81a75a5ff9b95effa91239ff0bb3232219698fa""        contract_hash=bytearray(b""\xfa\x98\x96\x21\x32\x32\xbb\xf0\x9f\x23\x91\xfa\xef\x95\x9b\xff\xa5\x75\x1a\xd8"")    contract=GetContract(contract_hash)    return contractGetBlockGetBlock используют для получения блока. Существует два пути, чтобы получить конкретный блок.1. Получить блок по высоте блока:from ontology.interop.System.Blockchain import GetBlockdef demo():    block=GetBlock(1408)    return block2. Получить блок по хешу блока:from ontology.interop.System.Blockchain import GetBlockdef demo():        block_hash=bytearray(b'\x16\xe0\xc5\x40\x82\x79\x77\x30\x44\xea\x66\xc8\xc4\x5d\x17\xf7\x17\x73\x92\x33\x6d\x54\xe3\x48\x46\x0b\xc3\x2f\xe2\x15\x03\xe4')    block=GetBlock(block_hash)2. Как использовать Block APIСуществуют три доступные функции в Block API: GetTransactions, GetTransactionCount, и GetTransactionByIndex. Мы разберём их одну за другой.GetTransactionCountGetTransactionCount используют для получения количества транзакций для данного блока.from ontology.interop.System.Blockchain import GetBlockfrom ontology.interop.System.Block import GetTransactionCountdef demo():    block=GetBlock(1408)    count=GetTransactionCount(block)    return countGetTransactionsРазработчики могут использовать функцию GetTransactions, чтобы получить все транзакции в данном блоке.from ontology.interop.System.Blockchain import GetBlockfrom ontology.interop.System.Block import GetTransactions def demo():    block=GetBlock(1408)    txs=GetTransactions(block)    return txsGetTransactionByIndexGetTransactionByIndex используют для получения конкретной транзакции в данном блоке.from ontology.interop.System.Blockchain import GetBlockfrom ontology.interop.System.Block import GetTransactionByIndexdef demo():    block=GetBlock(1408)    tx=GetTransactionByIndex(block,0) # index starts from 0.    return txПолное руководство можно найти на нашем GitHub.ПослесловиеBlockchain & Block API является незаменимой частью смарт-контрактов, поскольку Вы можете использовать их, чтобы запросить данные блокчейна и данные блока в смарт-контрактах. В следующих статьях мы обсудим, как использовать остальные API и выясним их взаимодействие с блокчейном Ontology.Статья была переведена редакцией Hashrate&Shares специально для OntologyRussia. клик  Вы разработчик? Присоединяйтесь к нашему техническому сообществу на Discord. Кроме того, загляните в Центр разработчиков на нашем сайте, там вы можете найти инструменты разработчика, документацию и многое другое.OntologyOntology website GitHub / DiscordTelegram English / RussianTwitter  / Reddit"
kristencarter7519;5 Thought-Provoking Use Cases Of Blockchain In Diverse Industries;Децентрализованные сети Криптография *Habr Инфографика Криптовалюты;Blockchain is a decentralized technology that maintains a record of all transactions occurring over a peer-to-peer network. Due to Blockchain's several different high-level use cases, numerous industries described Blockchain as the 'magic beans.' Blockchains store the record in a decentralized system that is interconnected. This technology lessens vulnerability and enhances transparency in all industrial sectors as information is stored digitally, and it does not have any centralized point to carry out the transactions.Do You Know?;/ru/post/524064/;"Blockchain is a decentralized technology that maintains a record of all transactions occurring over a peer-to-peer network. Due to Blockchain's several different high-level use cases, numerous industries described Blockchain as the 'magic beans.' Blockchains store the record in a decentralized system that is interconnected. This technology lessens vulnerability and enhances transparency in all industrial sectors as information is stored digitally, and it does not have any centralized point to carry out the transactions.Do You Know?By 2022, worldwide spending on blockchain solutions may reach $11.7 billion.By 2024, worldwide blockchain technology market revenue is predicted to reach $20 billion.Blockchain Use CasesBlockchain Technology FeaturesWell, this technology includes various features. Let's have a look at the prominent features of the Blockchain. DecentralizedEnhanced SecurityCross-border paymentsReal-time IoT operating systemsAnti-money laundering tracking systemSupply chain and logistics monitoringVoting mechanismFamous Companies Using Blockchain TechnologySeveral industries use Blockchain technology to enhance business growth. Let's view famous companies that are using Blockchain Technology. Healthcare: BurstIQ, Medicalchain, Factom, EncrypGenFintech: Deutsche, BNP Paribas, Barclays, ICICIRetail: IBM's Food Trust, Walmart, OpenBazaar, Unilever Travel & Tourism: Lufthansa, Delta Airlines, British AirwaysIT: IBM, Microsoft, Apple, GoogleDue to COVID 19 pandemic, most people preferring online shopping; this benefited the eCommerce sector up to much extent. Visualizing this other industry also started focusing on eCommerce services. Well, Blockchain in eCommerce is also benefiting the users, and that's why now other businesses are preferring to avail eCommerce web development service to start with other beneficial projects. Ending WordsBlockchain has helped various industries, and even by using this technology, several industrial sectors have gained profit, seeing these other sectors are also looking to adopt this advanced technology.Well, if you want to adopt Blockchain technology, then I will suggest you avail of blockchain development service from the reputed IT company. This will help you fulfill your business requirement."
vlsergey;Blockchain;Информационная безопасность *Криптография *;"Данный текст будет являться новой главой для учебного пособия по защите информации кафедры радиотехники и систем управления МФТИ (ГУ). Полностью учебник доступен на github. На хабре я же планирую выкладывать новые «большие» куски, во-первых, чтобы собрать полезные комментарии и замечания, во-вторых, дать сообществу больше обзорного материала по полезным и интересным темам.

Когда у вас есть знания о том, что такое криптографически стойкая хеш-функция, понять, что такое blockchain («цепочка блоков») очень просто. Blockchain – это последовательный набор блоков (или же, в более общем случае, ориентированный граф), каждый следующий блок в котором включает в качестве хешируемой информации значение хеш-функции от предыдущего блока.

Технология blockchain используется для организации журналов транзакций, при этом под транзакцией может пониматься что угодно: финансовая транзакция (перевод между счетами), аудит событий аутентификации и авторизации, записи о выполненных ТО и ТУ автомобилей. При этом событие считается случившимся, если запись о нём включена в журнал.

В таких системах есть три группы действующих лиц:


источники событий (транзакций)
источники блоков (фиксаторы транзакций)
получатели (читатели) блоков и зафиксированных транзакций.

В зависимости от реализации эти группы могут пересекаться. В системах типа BitCoin, например, все участники распределённой системы могут выполнять все три функции. Хотя за создание блоков (фиксацию транзакций) обычно отвечают выделенные вычислительные мощности, а управляющими их участников называют майнерами (см. раздел про децентрализованный blockchain далее).

Основное требование к таким журналам таково:


Невозможность модификации журнала: после добавления транзакции в журнал должно быть невозможно её оттуда удалить или изменить.";/ru/post/335994/;"Данный текст будет являться новой главой для учебного пособия по защите информации кафедры радиотехники и систем управления МФТИ (ГУ). Полностью учебник доступен на github. На хабре я же планирую выкладывать новые «большие» куски, во-первых, чтобы собрать полезные комментарии и замечания, во-вторых, дать сообществу больше обзорного материала по полезным и интересным темам.Когда у вас есть знания о том, что такое криптографически стойкая хеш-функция, понять, что такое blockchain («цепочка блоков») очень просто. Blockchain – это последовательный набор блоков (или же, в более общем случае, ориентированный граф), каждый следующий блок в котором включает в качестве хешируемой информации значение хеш-функции от предыдущего блока.Технология blockchain используется для организации журналов транзакций, при этом под транзакцией может пониматься что угодно: финансовая транзакция (перевод между счетами), аудит событий аутентификации и авторизации, записи о выполненных ТО и ТУ автомобилей. При этом событие считается случившимся, если запись о нём включена в журнал.В таких системах есть три группы действующих лиц:источники событий (транзакций)источники блоков (фиксаторы транзакций)получатели (читатели) блоков и зафиксированных транзакций.В зависимости от реализации эти группы могут пересекаться. В системах типа BitCoin, например, все участники распределённой системы могут выполнять все три функции. Хотя за создание блоков (фиксацию транзакций) обычно отвечают выделенные вычислительные мощности, а управляющими их участников называют майнерами (см. раздел про децентрализованный blockchain далее).Основное требование к таким журналам таково:Невозможность модификации журнала: после добавления транзакции в журнал должно быть невозможно её оттуда удалить или изменить.Для того чтобы понять, как можно выполнить требование на запрет модификации, стоит разобраться со следующими вопросами:Каким образом гарантируется, что внутри блока нельзя поменять информацию?Каким образом система гарантирует, что уже существующую цепочку блоков нельзя перегенерировать, тем самым исправив в них информацию?Ответ на первый вопрос прост: нужно снабдить каждый блок хеш-суммой от его содержимого. И эту хеш-сумму включить в качестве дополнительной полезной информации (тоже хешируемой) в следующий блок. Тогда для того, чтобы поменять что-то в блоке без разрушения доверия клиентов к нему, нужно будет это сделать таким образом, чтобы хеш-сумма от блока не поменялась. А это как раз практически невозможно, если у нас используется криптографически стойкая хеш-функция. Либо поменять в том числе и хеш-сумму блока. Но тогда придётся менять и значение этой хеш-суммы в следующем блоке. А это потребует изменений, в свою очередь, в хеш-сумме всего второго блока, а потом и в третьем, и так далее. Получается, что для того, чтобы поменять информацию в одном из блоков, нужно будет перегенерировать всю цепочку блоков, начиная с модифицируемого. Можно ли это сделать?Тут нужно ответить на вопрос, как в подобных системах защищаются от возможности перегенерации цепочки блоков. Мы рассмотрим три варианта систем:централизованный с доверенным центромцентрализованный с недоверенным центромдецентрализованный вариант с использованием доказательства работыЦентрализованный blockchain с доверенным центромЕсли у нас есть доверенный центр, то мы просто поручаем ему через определённый промежуток времени (или же через определённый набор транзакций) формировать новый блок, снабжая его не только хеш-суммой, но и своей электронной подписью. Каждый клиент системы имеет возможность проверить, что все блоки в цепочке сгенерированы доверенным центром и никем иным. В предположении, что доверенный центр не скомпрометирован, возможности модификации журнала злоумышленником нет.Использование технологии blockchain в этом случае является избыточным. Если у нас есть доверенный центр, можно просто обращаться к нему с целью подписать каждую транзакцию, добавив к ней время и порядковый номер. Номер обеспечивает порядок и невозможность добавления (удаления) транзакций из цепочки, электронная подпись доверенного центра – невозможность модификации конкретных транзакций.Централизованный blockchain с недоверенным центромИнтересен случай, когда выделенный центр не является доверенным. Точнее, не является полностью доверенным. Мы ему доверяем в плане фиксации транзакций в журнале, но хотим быть уверенными, что выделенный центр не перегенерирует всю цепочку блоков, удалив из неё ненужные ему более транзакции или добавив нужные.Для этого можно использовать, например, следующие два метода.Первый метод с использованием дополнительного доверенного хранилища. После создания очередного блока центр должен отправить в доверенное и независимое от данного центра хранилище хеш-код от нового блока. Доверенное хранилище не должно принимать никаких изменений к хеш-кодам уже созданных блоков. В качестве такого хранилища можно использовать и децентрализованную базу данных системы, если таковая присутствует. Размер хранимой информации может быть небольшим по сравнению с общим объёмом журнала.Второй возможный метод состоит в дополнении каждого блока меткой времени, сгенерированной доверенным центром временных меток. Такая метка должна содержать время генерации метки и электронную подпись центра, вычисленную на основании хеш-кода блока и времени метки. В случае, если «недоверенный» центр захочет перегенерировать часть цепочки блоков, будет наблюдаться разрыв в метках времени.Стоит отметить, что этот метод не гарантирует, что «недоверенный» центр не будет генерировать сразу две цепочки блоков, дополняя их корректными метками времени, а потом не подменит одну другой.Децентрализованный blockchainНаибольший интерес для нас (и – наименьший для компаний, продающих blockchain-решения) представляет децентрализованная система blockchain без выделенных центров генерации блоков. Каждый участник может взять набор транзакций, ожидающих включения в журнал, и сформировать новый блок. Более того, в системах типа BitCoin такой участник (будем его назвать «майнером», от англ. to mine — копать) ещё и получит премию в виде определённой суммы и/или комиссионных от принятых в блок транзакций.Но нельзя просто так взять и сформировать блок в децентрализованных системах. Надёжность таких систем основывается именно на том, что новый блок нельзя сформировать быстрее (в среднем) чем за определённое время. Например, за 10 минут (BitCoin). Это обеспечивается механизмом, который получил название доказательство работы.Механизм основывается на следующей идее. Пусть есть криптографически стойкая хэш-функция  и задан некоторый параметр  (от англ. target – цель). , где  — размер выхода хэш-функции в битах. Корректным новым блоком blockchain-сеть будет признавать только такой, значение хэш-суммы которого меньше текущего заданного параметра . В этом случае алгоритм работы майнера выглядит следующий образом:собрать из пула незафиксированных транзакций те, которые поместятся в 1 блок (1 мегабайт для сети Bitcoin) и имеют максимальную комиссию (решить задачу о рюкзаке)добавить в блок информацию о предыдущем блоке;добавить в блок информацию о себе (как об авторе блока, кому начислять комиссии и бонусы за блок);установить  в некоторое значение, например, ;выполнять в цикле:обновить значение ;посчитать значение ;если , добавить в блок  и считать блок сформированным, иначе — повторить цикл.Для каждой итерации цикла вероятность получить корректный блок равна . Так как  обычно мало, то майнерам нужно сделать большое количество итераций цикла, чтобы найти нужный . При этом только один (обычно — первый) из найденных блоков будет считаться корректным. Чем больше вычислительная мощность конкретного майнера, тем больше вероятность, что именно он первым сумеет найти нужный .Зная суммарную вычислительную мощность blockchain-сети, участники могут договориться о таком механизме изменения параметра , чтобы время генерации нового корректного блока было примерно заданное время. Например, в сети Bitcoin параметр  пересчитывается каждые 2016 блоков таким образом, чтобы среднее время генерации блока было 10 минут. Это позволяет адаптировать сеть к изменению количества участников, их вычислительных мощностей и к появлению новых механизмов вычисления хэш-функций.Кроме задания параметра  можно оперировать другими величинами, так или иначе относящимися к мощности вычислений.Hashrate — количество хешей, которые считают за единицы времени конкретный майнер или сеть в целом. Например, в ноябре 2017 года общий hashrate для сети Bitcoin составлял примерно  хэшей в секунду.Difficulty — сложность поиска корректного блока, выражаемая как , где  — некоторая константа сложности, а t — текущая цель (англ. target). В отличие от параметра t, который падает с ростом вычислительной мощности сети, d изменяется вместе с hashrate, что делает его более простым для восприятия и анализа человеком.В случае примерно одновременной генерации следующего блока двумя и более майнерами (когда информация о новом блоке публикуется вторым майнером до того, как ему придёт информация о новом блоке от первого) в направленном графе блоков происходит разветвление. Далее каждый из майнеров выбирает один из новых блоков (например – какой первый увидели) и пытается сгенерировать новый блок на основе выбранного, продолжая «ответвление» в графе. В конце-концов одна из двух таких цепочек становится длиннее (та, которую выбрало большее число майнеров), и именно она признаётся основной.В случае нормального поведения системы на включение конкретных транзакций в блоки это влияет мало, так как каждый из добросовестных майнеров следует одному и тому же алгоритму включения транзакций в блок (например, в сети BitCoin – алгоритму максимизации комиссии за блок). Однако можно предположить, что какой-нибудь злоумышленник захочет «модерировать» распределённый blockchain, включая или не включая в блоки транзакции по своему выбору. Предположим, что доля вычислительных ресурсов злоумышленника (направленных на генерацию нового блока) равна  ( 0% <  < 50%). В этом случае каждый следующий сгенерированный блок с вероятностью  будет сгенерирована мощностями злоумышленника. Это позволит ему включать в блоки те транзакции, которые другие майнеры включать не захотели.Но позволит ли это злоумышленнику не включать что-то в цепочку транзакций? Нет. Потому что после его блока с вероятностью  будет следовать блок «обычного» майнера, который с радостью (пропорциональной комиссии-награде) включит все транзакции в свой блок.Однако ситуация меняется, если мощности злоумышленника составляют более 50% от мощности сети. В этом случае, если после блока злоумышленника был с вероятностью  сгенерирован «обычный» блок, злоумышленник его может просто проигнорировать и продолжать генерировать новые блоки, как будто он единственный майнер в сети. Тогда если среднее время генерации одного блока всеми мощностями , то за время  злоумышленник сможет сгенерировать , а легальные пользователи  блоков, . Даже если с некоторой вероятностью легальные пользователи сгенерируют 2 блока быстрее, чем злоумышленник один, последний всё равно «догонит и перегонит» «легальную» цепочку примерно за время . Так как в blockchain есть договоренность, что за текущее состояние сети принимается наиболее длинная цепочка, именно цепочка злоумышленника всегда будет восприниматься правильной. Получается, что злоумышленник сможет по своему желанию включать или не включать транзакции в цепочки.Правда, пользоваться чужими деньгами злоумышленник всё равно не сможет – так как все блоки транзакций проверяются на внутреннюю непротиворечивость и корректность всех включённых в блок транзакций.Кроме концепции «доказательство работы» используются и другие. Например, в подходе «доказательство доли владения» (англ. proof of stake), используемой в сетях Etherium и EmerCoin, вероятность генерации блока пропорциональна количеству средств на счетах потенциальных создателей нового блока. Это намного более энергоэффективно по сравнению с PoW, и, кроме того, связывает ответственность за надёжность и корректность генерации новых блоков с размером капитала (чем больше у нас средств, тем меньше мы хотим подвергать опасности систему). С другой стороны, это даёт дополнительную мотивацию концентрировать больше капитала в одних руках, что может привести к централизации системы.Механизм внесения изменений в протоколЛюбая система должна развиваться. Но у децентрализованных систем нельзя просто «включить один рубильник» и заставить участников системы работать по новому – иначе систему нельзя назвать полностью децентрализованной. Механизмы и способы внесения изменений могут выглядеть на первый взгляд нетривиально. Например:апологеты системы предлагают изменения в правилах работыавторы ПО вносят изменения в программный код, позволяя сделать две вещи:указать участникам системы, что они поддерживают новое изменениеподдержать новое изменениеучастники системы скачивают новую версию и выставляют в новых блоках транзакций (или самих транзакциях) сигнальные флаги, показывающие их намерение поддержать изменениеесли к определённой дате определённое число блоков содержат сигнальный флаг (обратите внимание на привязку числа голосов к числу сгенерированных блоков), то изменение считается принятым, и большая (по числу новых блоков) часть участников системы в определённую дату включают эти измененияте участники, которые не приняли изменения, или приняли изменения вопреки отсутствию согласия на них большей части участников, в худшем случае начнут генерировать свою цепочку блоков, только её признавая корректной. Основную цепочку блоков они будут считать неверно сгенерированной. По факту это приведёт к дублированию (разветвлению, форку) системы, когда в какую-то дату вместо одного журнала транзакций появляется два, ведущимися разными людьми. Это журналы совпадают до определённой даты, после чего в них начинаются расхождение.Подводя итоги, Сатоши Накамото (псевдоним), автор технологий blockchain и bitcoin, сумел предложить работающий децентрализованный механизм, в котором и само поведение системы, и изменения к этой системе проходят через явный или неявный механизм поиска консенсуса участников. Для получения контроля над системой в целом злоумышленнику придётся получить контроль как минимум над 50% всех мощностей системы (в случае PoW), а без этого можно лишь попытаться ограничить возможность использования системы конкретными участниками.Однако созданная технология не лишена недостатков. Существуют оценки, согласно которым использование метода PoW для системы bitcoin приводит к затратам энергии, сравнимой с потреблением электричества целыми городами или странами. Есть проблемы и с поиском консенсуса – сложный механизм внесения изменений, как считают некоторые эксперты, может привести к проблемам роста (например, из-за ограниченности числа транзакций в блоке), и, в будущем, к отказу использования механизма как устаревшего и не отвечающего будущим задачам.Хотелось бы узнать у сообщества, про какие ещё технологии стоит рассказывать студентам. С одной стороны, им обязательно надо рассказать про базовые вещи — классическую криптографию и криптографию на открытых ключах. Но хочется дать понятие и про современные вещи, которые, возможно, не станут лишним грузом знаний и через пять-десять лет. С текущим содержание учебной программы можно ознакомиться здесь.История изменений2017-11-17: Добавлено указание лицензии CC-BY2017-11-18: Уточнёна и расширена информация про механизм proof-of-work и связанные определения"
Iambeardier;Blockchain на Go. Часть 4: Транзакции, часть 1;Go *;"Привет, Habr! Представляю вашему вниманию перевод статьи ""Building Blockchain in Go. Part 4: Transactions 1"".

Содержание


Blockchain на Go. Часть 1: Прототип
Blockchain на Go. Часть 2: Proof-of-Work
Blockchain на Go. Часть 3: Постоянная память и интерфейс командной строки
Blockchain на Go. Часть 4: Транзакции, часть 1
Blockchain на Go. Часть 5: Адреса
Blockchain на Go. Часть 6: Транзакции, часть 2
Blockchain на Go. Часть 7: Сеть

Вступление
Транзакции являются сердцем Биткоина, и единственная цель цепи блоков — это хранить транзакции безопасным и надежным способом, чтобы никто не смог модифицировать их после создания. В этой статье мы начинаем работу над реализацией механизма транзакций. Но поскольку это довольно большая тема, я разбил ее на две части: в этой части мы реализуем общий механизм, а во второй части мы детально разберем весь остальной функционал.";/ru/post/351752/;"Привет, Habr! Представляю вашему вниманию перевод статьи ""Building Blockchain in Go. Part 4: Transactions 1"".СодержаниеBlockchain на Go. Часть 1: ПрототипBlockchain на Go. Часть 2: Proof-of-WorkBlockchain на Go. Часть 3: Постоянная память и интерфейс командной строкиBlockchain на Go. Часть 4: Транзакции, часть 1Blockchain на Go. Часть 5: АдресаBlockchain на Go. Часть 6: Транзакции, часть 2Blockchain на Go. Часть 7: СетьВступлениеТранзакции являются сердцем Биткоина, и единственная цель цепи блоков — это хранить транзакции безопасным и надежным способом, чтобы никто не смог модифицировать их после создания. В этой статье мы начинаем работу над реализацией механизма транзакций. Но поскольку это довольно большая тема, я разбил ее на две части: в этой части мы реализуем общий механизм, а во второй части мы детально разберем весь остальной функционал.В данной статье мы будем практически полностью редактировать весь наш предыдущий код, поэтому не имеет смысла описывать каждое изменение, все изменения вы можете посмотреть тут.Ложки нетЕсли Вы когда-то разрабатывали веб-приложение, то для реализации платежей, вероятно, создавали в базе данных две эти таблицы: учетные записи и транзакции. Учетная запись хранила информацию о пользователе, включая его персональную информацию и баланс, а транзакция хранит информацию о переводе денег с одной учетной записи на другую. В Биткоине платежи осуществляются совершенно по-другому:Нет аккаунтов.Нет балансов.Нет адресов.Нет монет.Нет отправителей и получателей.Поскольку блокчейн является публичной и открытой базой данных, мы не хотим хранить конфиденциальную информацию о владельцах кошельков. Монеты не хранятся на счетах. Транзакции не переводят деньги с одного адреса на другой. Нет полей и атрибутов, которые содержат баланс счета. Есть только транзакции. Но что внутри?Биткоин транзакцияТранзакция представляет собой комбинацию входов и выходов:type Transaction struct {	ID   []byte	Vin  []TXInput	Vout []TXOutput}Входы новой транзакции ссылаются на выходы предыдущей транзакции (есть исключение, о котором мы поговорим ниже). Выходы — место, где хранятся монеты. Следующая диаграмма демонстрирует взаимосвязь транзакций:Заметьте:Есть выходы, которые не связаны с входами.В одной транзакции входы могут ссылаться на выходы нескольких транзакций.Вход всегда должен ссылаться на выход.В этой статье мы будем использовать слова «деньги», «монеты», «потратить», «отправить», «учетная запись» и т.д. Но в Биткоине таких концепций нет. Транзакции — это просто заблокированное скриптом значение, которое может разблокировать лишь тот, кто его заблокировал.Выходы транзакцийНачнем с выходов:type TXOutput struct {	Value        int	ScriptPubKey string}Фактически, это выходы, которые хранят «монеты» (обратите внимание на полеValue выше). Средства блокируются особым пазлом, которая хранится в ScriptPubKey. Внутри Bitcoin использует скриптовый язык Script, который используется для определения логики блокировки и разблокировки выходов. Язык довольно примитивен (это делается намеренно, чтобы избежать возможных взломов), но мы не будем обсуждать его подробно. Вы можете прочитать подробнее о нем здесь.В Биткоине поле значений хранит количество сатоши, а не количество BTC. 1 сатоши = 0.00000001 BTC. Таким образом, это самая маленькая единица валюты в Биткойне (как, к примеру, цент). Поскольку у нас нет адресов, пока что мы будем избегать всей связанной с сценариями логики. Для начала ScriptPubKey будет хранить произвольную строку (пользовательский адрес кошелька).Кстати, наличие такого языка сценариев означает, что Биткоин можно использовать как платформу смарт-контрактов. Одна важная вещь которую нужно знать о выходах, это то, что они неделимы, а это означает, что вы не можете ссылаться на часть своего значения. Когда выход ссылается на новую транзакцию, он расходуется полностью. И если его значение больше, чем требуется, генерируется разница и новое значение отправляется обратно отправителю. Это похоже на реальную ситуацию в мире, когда вы платите, скажем, $5 долларов за то, что стоит $1, и получаете сдачу $4.Входы транзакцийРассмотрим вход:type TXInput struct {	Txid      []byte	Vout      int	ScriptSig string}Как упоминалось ранее, вход ссылается на предыдущий выход: Txid хранит идентификатор такой транзакции, а Vout хранит индекс выхода данной транзакции. ScriptSig — это скрипт, который предоставляет данные, которые будут в дальнейшем использоваться в скрипте ScriptPubKey. Если данные верны, выход можно разблокировать, а его значение можно использовать для генерации новых выходов; если же это не так, вход не может ссылаться на выход. Этот механизм гарантирует, что пользователи не могут тратить монеты, принадлежащие другим людям.Опять же, поскольку у нас все еще нет адресов, ScriptSig сохранит только произвольный пользовательский адрес кошелька. Мы создадим открытый ключ и проверку подписи в следующей статье.Подведем итог. Выходы — это место, в котором хранятся «монеты». Каждый выход имеет сценарий разблокировки, который определяет логику разблокировки выхода. Каждая новая транзакция должна иметь как минимум один вход и выход. Вход ссылается на результат предыдущей транзакции и предоставляет данные (поле ScriptSig), которые используются в сценарии разблокировки выхода, чтобы разблокировать его и использовать его значение для создания новых выходов.Но что пришло первым: входы или выходы?ЯйцоВ Биткоине, яйцо появилось до цыпленка. Логика inputs-referencing-outputs представляет собой классическую ситуацию «курица или яйцо»: входы производят выходы, а выходы позволяют создавать входы. И в Биткоине выходы всегда появляются перед входами.Когда майнер начинает майнить блок, он добавляет к нему coinbase транзакцию. Транзакция coinbase — это особый тип транзакции, который не требует ранее существующих выходов. Он создает выходы (т. е. «Монеты») из ниоткуда. Яйцо без курицы. Это награда, которую майнеры получают за добычу новых блоков.Как вы знаете, в начале цепи есть блок генезиса. Именно этот блок генерирует самый первый выход в цепочке блоков. И никаких предыдущих выходов не требуется, поскольку нет предыдущих транзакций и нет никаких выходов.Давайте создадим coinbase транзакцию:func NewCoinbaseTX(to, data string) *Transaction {	if data == """" {		data = fmt.Sprintf(""Reward to '%s'"", to)	}	txin := TXInput{[]byte{}, -1, data}	txout := TXOutput{subsidy, to}	tx := Transaction{nil, []TXInput{txin}, []TXOutput{txout}}	tx.SetID()	return &tx}В coinbase транзакции имеется только один вход. В нашей реализации Txid пуст, а Vout равен -1. Кроме того, транзакция coinbase не хранит скрипт в ScriptSig. Вместо этого там хранятся произвольные данные.В биткойне самая первая coinbase транзакция содержит следующее сообщение: “The Times 03/Jan/2009 Chancellor on brink of second bailout for banks”. Вы сами можете на это посмотреть. subsidy — это сумма вознаграждения. В Биткоине это число не хранится нигде и рассчитывается только на основе общего количества блоков: количество блоков делится на 210000. Майнинг блока генезиса приносит 50 BTC, и каждые 210000 блоков награда уменьшается вдвое. В нашей реализации мы будем хранить вознаграждение как константу (по крайней мере на данный момент).Сохранение транзакций в цепиС этого момента каждый блок должен хранить как минимум одну транзакцию, и должно стать невозможным майнить блоки без транзакции. Теперь, удалим поле date из Block и вместо этого теперь будем хранить транзакции.type Block struct {	Timestamp     int64	Transactions  []*Transaction	PrevBlockHash []byte	Hash          []byte	Nonce         int}NewBlock и NewGenesisBlock также должны быть соответствующим образом измененыfunc NewBlock(transactions []*Transaction, prevBlockHash []byte) *Block {	block := &Block{time.Now().Unix(), transactions, prevBlockHash, []byte{}, 0}	...}func NewGenesisBlock(coinbase *Transaction) *Block {	return NewBlock([]*Transaction{coinbase}, []byte{})}Теперь создадим функцию CreateBlockchainfunc CreateBlockchain(address string) *Blockchain {	...	err = db.Update(func(tx *bolt.Tx) error {		cbtx := NewCoinbaseTX(address, genesisCoinbaseData)		genesis := NewGenesisBlock(cbtx)		b, err := tx.CreateBucket([]byte(blocksBucket))		err = b.Put(genesis.Hash, genesis.Serialize())		...	})	...}Теперь функция принимает адрес, который получит вознаграждение за добычу блока генезиса.Proof-of-WorkАлгоритм Proof-of-Work должен рассматривать транзакции, хранящиеся в блоке, чтобы гарантировать согласованность и надежность цепи как хранилища транзакции. Итак, теперь мы должны изменить метод ProofOfWork.prepareData:func (pow *ProofOfWork) prepareData(nonce int) []byte {	data := bytes.Join(		[][]byte{			pow.block.PrevBlockHash,			pow.block.HashTransactions(), // This line was changed			IntToHex(pow.block.Timestamp),			IntToHex(int64(targetBits)),			IntToHex(int64(nonce)),		},		[]byte{},	)	return data}Вместо pow.block.Data теперь мы добавим pow.block.HashTransactions ():func (b *Block) HashTransactions() []byte {	var txHashes [][]byte	var txHash [32]byte	for _, tx := range b.Transactions {		txHashes = append(txHashes, tx.ID)	}	txHash = sha256.Sum256(bytes.Join(txHashes, []byte{}))	return txHash[:]}Повторюсь, мы используем хеширование как механизм обеспечения уникального представления данных. Мы хотим, чтобы все транзакции в блоке были однозначно идентифицированы с помощью одного хеша. Чтобы достичь этого, мы получаем хеши каждой транзакции, объединяем их и получаем хеш объединенных комбинаций.Биткоин использует более сложную технику: он представляет все транзакции, содержащиеся в блоке как дерево хешей, и использует корневой хеш дерева в системе Proof-of-Work. Такой подход позволяет быстро проверить, содержит ли блок определенную транзакцию, имеющую только корневой хеш и без загрузки всех транзакций.  Проверим правильность работы:$ blockchain_go createblockchain -address Ivan00000093450837f8b52b78c25f8163bb6137caf43ff4d9a01d1b731fa8ddcc8aDone!Отлично! Мы получили свою первую награду. Но как нам проверить баланс?Непотраченные выходыНам нужно найти все непотраченные выходы (UTXO). Это означает, что эти выходы не ссылались ни на какие входы. На приведенной выше диаграмме это:tx0, output 1;tx1, output 0;tx3, output 0;tx4, output 0.Конечно, когда мы проверяем баланс, нам не нужны они все, нужны только те, которые могут быть разблокированы ключом, которым мы владеем (в настоящее время у нас нет реализованных ключей и вместо них будут использоваться пользовательские адреса). Для начала, давайте определим методы блокировки-разблокировки на входах и выходах:func (in *TXInput) CanUnlockOutputWith(unlockingData string) bool {	return in.ScriptSig == unlockingData}func (out *TXOutput) CanBeUnlockedWith(unlockingData string) bool {	return out.ScriptPubKey == unlockingData}Здесь мы просто сравниваем поля из ScriptSig с unlockingData. В следующей статье мы их улучшим, после того, как реализуем адреса, основанные на закрытых ключах.Следующий шаг — поиск транзакций с непотраченными выходами — это уже более сложно:func (bc *Blockchain) FindUnspentTransactions(address string) []Transaction {  var unspentTXs []Transaction  spentTXOs := make(map[string][]int)  bci := bc.Iterator()  for {    block := bci.Next()    for _, tx := range block.Transactions {      txID := hex.EncodeToString(tx.ID)    Outputs:      for outIdx, out := range tx.Vout {        // Was the output spent?        if spentTXOs[txID] != nil {          for _, spentOut := range spentTXOs[txID] {            if spentOut == outIdx {              continue Outputs            }          }        }        if out.CanBeUnlockedWith(address) {          unspentTXs = append(unspentTXs, *tx)        }      }      if tx.IsCoinbase() == false {        for _, in := range tx.Vin {          if in.CanUnlockOutputWith(address) {            inTxID := hex.EncodeToString(in.Txid)            spentTXOs[inTxID] = append(spentTXOs[inTxID], in.Vout)          }        }      }    }    if len(block.PrevBlockHash) == 0 {      break    }  }  return unspentTXs}Поскольку транзакции хранятся в блоках, мы должны проверять каждый блок в цепочке. Начнем с выходов:if out.CanBeUnlockedWith(address) {	unspentTXs = append(unspentTXs, tx)}Если выход был заблокирован по тому же адресу, мы ищем непотраченные выходы, которые мы хотим. Но перед тем, как принять его, нам нужно проверить, был ли на выходе уже указан вход:if spentTXOs[txID] != nil {	for _, spentOut := range spentTXOs[txID] {		if spentOut == outIdx {			continue Outputs		}	}}Мы пропускаем те, на которые уже ссылаются входы (их значения были перенесены на другие выходы, поэтому мы не можем их подсчитать). После проверки выходов мы собираем все входы, которые могут разблокировать выходы, заблокированные с предоставленным адресом (это не относится к coinbase транзакциям, поскольку они не разблокируют выходы):if tx.IsCoinbase() == false {    for _, in := range tx.Vin {        if in.CanUnlockOutputWith(address) {            inTxID := hex.EncodeToString(in.Txid)            spentTXOs[inTxID] = append(spentTXOs[inTxID], in.Vout)        }    }}Функция возвращает список транзакций, содержащих непотраченные выходы. Для расчета баланса нам нужна еще одна функция, которая берет транзакции и возвращает только выходы:func (bc *Blockchain) FindUTXO(address string) []TXOutput {       var UTXOs []TXOutput       unspentTransactions := bc.FindUnspentTransactions(address)       for _, tx := range unspentTransactions {               for _, out := range tx.Vout {                       if out.CanBeUnlockedWith(address) {                               UTXOs = append(UTXOs, out)                       }               }       }       return UTXOs}Готово! Теперь реализуем команду getbalancefunc (cli *CLI) getBalance(address string) {	bc := NewBlockchain(address)	defer bc.db.Close()	balance := 0	UTXOs := bc.FindUTXO(address)	for _, out := range UTXOs {		balance += out.Value	}	fmt.Printf(""Balance of '%s': %d\n"", address, balance)}Баланс счета — это сумма значений всех непотраченных выходов, заблокированных адресом учетной записи.Давайте проверим наш баланс после добычи блока генезиса:$ blockchain_go getbalance -address IvanBalance of 'Ivan': 10Это наши первые монеты!Отправка монетТеперь мы хотим отправить несколько монеты кому-то другому. Для этого нам нужно создать новую транзакцию, поместить ее в блок и обработать его. До сих пор мы реализовали только транзакцию coinbase (которая является специальным типом транзакций), теперь нам нужна общая транзакция:func NewUTXOTransaction(from, to string, amount int, bc *Blockchain) *Transaction {	var inputs []TXInput	var outputs []TXOutput	acc, validOutputs := bc.FindSpendableOutputs(from, amount)	if acc  amount {		outputs = append(outputs, TXOutput{acc - amount, from}) // a change	}	tx := Transaction{nil, inputs, outputs}	tx.SetID()	return &tx}Прежде чем создавать новые выходы, нам для начала нужно найти все непотраченные выходы и убедиться, что в них есть достаточное количество монет. Это метод FindSpendableOutputs. После этого для каждого найденного выхода создается вход, ссылающийся на него. Затем мы создаем два выхода:Тот, который заблокирован с адресом получателя. Это фактическая передача монет на другой адрес.Тот, который заблокирован с адресом отправителя. Это разница. Он создается только тогда, когда непотраченные выходы имеют большее значение, чем требуется для новой транзакции. Помните: выходы неделимы.Метод FindSpendableOutputs основан на методе FindUnspentTransactions, который мы определили ранее:func (bc *Blockchain) FindSpendableOutputs(address string, amount int) (int, map[string][]int) {	unspentOutputs := make(map[string][]int)	unspentTXs := bc.FindUnspentTransactions(address)	accumulated := 0Work:	for _, tx := range unspentTXs {		txID := hex.EncodeToString(tx.ID)		for outIdx, out := range tx.Vout {			if out.CanBeUnlockedWith(address) && accumulated = amount {					break Work				}			}		}	}	return accumulated, unspentOutputs}Метод выполняет обход по всем неизрасходованным транзакциям и накапливает их значения. Когда накопленное значение больше или равно сумме, которую мы хотим передать, обход останавливается и возвращает накопленные значения и выходные индексы, сгруппированные по идентификаторам транзакций. Нам не надо брать больше, чем мы собираемся потратить.Теперь мы можем изменить метод Blockchain.MineBlock:func (bc *Blockchain) MineBlock(transactions []*Transaction) {	...	newBlock := NewBlock(transactions, lastHash)	...}Наконец, создадим команду send:func (cli *CLI) send(from, to string, amount int) {	bc := NewBlockchain(from)	defer bc.db.Close()	tx := NewUTXOTransaction(from, to, amount, bc)	bc.MineBlock([]*Transaction{tx})	fmt.Println(""Success!"")}Отправка монет означает создание транзакции и добавление ее в цепь блоков посредством майнинга блока. Но Биткоин не делает это сразу (как и мы). Вместо этого он помещает все новые транзакции в пул памяти (или mempool), и когда майнер готов к добыче блока, он берет все транзакции из mempool и создает блок-кандидат. Транзакции становятся подтвержденными только тогда, когда блок, содержащий их, добывается и добавляется к цепи блоков.Давайте проверим, как работает отправка монет:$ blockchain_go send -from Ivan -to Pedro -amount 600000001b56d60f86f72ab2a59fadb197d767b97d4873732be505e0a65cc1e37Success!$ blockchain_go getbalance -address IvanBalance of 'Ivan': 4$ blockchain_go getbalance -address PedroBalance of 'Pedro': 6Отлично! Теперь давайте создадим больше транзакций и убедимся, что отправка с нескольких выходов работает правильно:$ blockchain_go send -from Pedro -to Helen -amount 200000099938725eb2c7730844b3cd40209d46bce2c2af9d87c2b7611fe9d5bdfSuccess!$ blockchain_go send -from Ivan -to Helen -amount 2000000a2edf94334b1d94f98d22d7e4c973261660397dc7340464f7959a7a9aaSuccess!Теперь монеты Хелен заблокированы на двух выходах: один выход от Педро и один от Ивана. Отправим кому-нибудь еще:$ blockchain_go send -from Helen -to Rachel -amount 3000000c58136cffa669e767b8f881d16e2ede3974d71df43058baaf8c069f1a0Success!$ blockchain_go getbalance -address IvanBalance of 'Ivan': 2$ blockchain_go getbalance -address PedroBalance of 'Pedro': 4$ blockchain_go getbalance -address HelenBalance of 'Helen': 1$ blockchain_go getbalance -address RachelBalance of 'Rachel': 3Выглядит хорошо! Теперь давайте протестируем исключения:$ blockchain_go send -from Pedro -to Ivan -amount 5panic: ERROR: Not enough funds$ blockchain_go getbalance -address PedroBalance of 'Pedro': 4$ blockchain_go getbalance -address IvanBalance of 'Ivan': 2ЗаключениеУф! Это было нелегко, но теперь у нас есть транзакции! Хотя, некоторые ключевые особенности Биткоин-подобной криптовалюты отсутствуют:Адреса. Пока у нас нет адресов на основе приватного ключа.Награды. Майнить блоки абсолютно невыгодно!UTXO. Получение баланса требует сканирования всей цепочки блоков, что может занять очень много времени, когда есть очень много блоков. Кроме того, это займет очень много времени, если мы захотим подтвердить последующие транзакции. UTXO предназначен для решения этих проблем и для быстрой работы с транзакциями.Mempool. Здесь хранятся транзакции, прежде чем они будут упакованы в блок. В нашей текущей реализации блок содержит только одну транзакцию, и это очень неэффективно.СсылкиFull source codesTransactionMerkle treeCoinbase"
Iambeardier;Blockchain на Go. Часть 5: Адреса;Информационная безопасность *Go *;"Содержание


Blockchain на Go. Часть 1: Прототип
Blockchain на Go. Часть 2: Proof-of-Work
Blockchain на Go. Часть 3: Постоянная память и интерфейс командной строки
Blockchain на Go. Часть 4: Транзакции, часть 1
Blockchain на Go. Часть 5: Адреса
Blockchain на Go. Часть 6: Транзакции, часть 2
Blockchain на Go. Часть 7: Сеть

Вступление
В предыдущей статье мы начали реализацию транзакций, а также ознакомились с принципом ее работы: нет учетных записей, личные данные (например, имя или серия и номер паспорта) не требуются и не хранятся нигде в Bitcoin. Но все же должно быть что-то, что идентифицирует вас как владельца выходов транзакции (т. е. владельца монет, заблокированных на выходах). И это то, для чего нужны адреса в Bitcoin. До сих пор мы использовали произвольные строки в качестве адресов, теперь пришло время реализовать реальные адреса, таким образом, каким они реализованы в Bitcoin.";/ru/post/351834/;"СодержаниеBlockchain на Go. Часть 1: ПрототипBlockchain на Go. Часть 2: Proof-of-WorkBlockchain на Go. Часть 3: Постоянная память и интерфейс командной строкиBlockchain на Go. Часть 4: Транзакции, часть 1Blockchain на Go. Часть 5: АдресаBlockchain на Go. Часть 6: Транзакции, часть 2Blockchain на Go. Часть 7: СетьВступлениеВ предыдущей статье мы начали реализацию транзакций, а также ознакомились с принципом ее работы: нет учетных записей, личные данные (например, имя или серия и номер паспорта) не требуются и не хранятся нигде в Bitcoin. Но все же должно быть что-то, что идентифицирует вас как владельца выходов транзакции (т. е. владельца монет, заблокированных на выходах). И это то, для чего нужны адреса в Bitcoin. До сих пор мы использовали произвольные строки в качестве адресов, теперь пришло время реализовать реальные адреса, таким образом, каким они реализованы в Bitcoin.В этой части мы изменим очень много кода, поэтому я не вижу смысла объяснять все подробно. Посетите эту страницу, чтобы увидеть все изменения, по сравнению с прошлой статьей.Биткоин-адресВот пример Bitcoin-адреса: 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa. Это самый первый Bitcoin-адрес, который якобы принадлежит Сатоши Накамото. Bitcoin-адреса находятся в открытом доступе. Если вы захотите отправить кому-то монеты, вам нужно знать адрес получателя. Но адреса (несмотря на уникальность) не являются идентификатором вас, как владельца «кошелька». Фактически, такие адреса являются открытым ключом. В Bitcoin ваша личность — это пара (или пары) закрытых и открытых ключей, хранящихся на вашем компьютере (или в каком-либо другом месте, к которому у вас есть доступ). Для создания таких ключей используются криптографические алгоритмы, которые гарантируют, что никто другой не сможет получить доступ к вашим монетам без физического доступа к вашим ключам. Давайте рассмотрим, что же это за алгоритмы.Криптосистема с открытым ключомАлгоритмы криптосистем с открытым ключом используют пары ключей: открытые и закрытые. Открытые ключи можно сообщить кому угодно. Закрытые ключи, напротив, не должны раскрываться никому: никто, кроме владельца, не должен иметь к ним доступа, поскольку это личные ключи, которые служат идентификатором владельца. Ваше лицо — это ваши закрытые ключи (в мире криптовалюты, конечно).По сути, Bitcoin-кошелек — это всего лишь пара таких ключей. Когда вы устанавливаете приложение кошелька или используете Bitcoin клиент для создания нового адреса, для вас генерируется пара ключей. Тот, кто контролирует закрытый ключ, контролирует все монеты, которые были на него отправлены.Закрытые и открытые ключи — это просто случайные последовательности байтов, поэтому они не могут быть напечатаны на экране и прочитаны человеком. Вот почему Bitcoin использует алгоритм для преобразования открытых ключей в удобочитаемую строку.Если вы когда-нибудь использовали Bitcoin кошелек в виде приложения, вероятно, для вас была создана мнемоническая фраза. Такие фразы используются вместо закрытых ключей и могут быть использованы для их генерации. Этот механизм реализован в BIP-039.Итак, теперь мы знаем, что идентифицирует пользователей в Bitcoin. Но как Bitcoin проверяет владельца выхода транзакции (и монеты, которые там хранятся)?Электронная цифровая подписьВ математике и криптографии существует концепция электронной цифровой подписи — алгоритмы, которые гарантируют:что данные не были изменены при передаче от отправителя к получателю;что данные были созданы определенным отправителем;что отправитель не может отрицать то, что именно он отправил эти данные.Применяя алгоритм электронной цифровой подписи к данным (т. е. подписывая данные), получается подпись, которую впоследствии можно будет проверить. Подпись данных происходит с использованием закрытого ключа, а для проверки требуется открытый ключ.Чтобы подписать данные, нам понадобится следующее:данные для подписи;закрытый ключ.Алгоритм создает подпись, которая хранится во входах транзакции. Чтобы проверить подпись, необходимо следующее:данные, которые были подписаны;подпись;открытый ключ.Говоря простыми словами, процесс проверки может быть описан так: нам надо убедиться, что подпись получена из этих данных с помощью закрытого ключа, который использовался для генерации открытого ключа.Цифровые подписи не шифруются, а данные получить из нее невозможно. Это похоже на хеширование: вы преобразуете данные при помощи алгоритма и получаете их уникальное представление. Разница между хешем и подписью — это пары ключей, которые позволяют произвести проверку последней.Но такие пары ключей также можно использовать и для шифрования данных: для шифрования используется закрытый ключ, а для расшифровки — открытый. Однако же Bitcoin не использует алгоритмы шифрования.Каждый вход транзакции в Bitcoin подписывается тем, кто создал эту транзакцию. Каждая транзакция в Bitcoin должна быть проверена перед тем, как поместить ее в блок. Верификация означает (помимо других процедур):Проверку того, что входы имеют достаточные права на использование выходов из предыдущих транзакций.Проверку правильности подписи транзакции.Схематически, процесс подписи и проверки данных выглядит так:Давайте рассмотрим полный жизненный цикл транзакции:В самом начале содержится блок генезиса с coinbase транзакцией. В транзакциях coinbase нет реальных входов, поэтому подпись не требуется. Вывод транзакции содержит хешированный открытый ключ (используются алгоритмы RIPEMD16(SHA256(PubKey))).Когда кто-то отправляет монеты, создается транзакция. Входы транзакции будут ссылаться на выходы из предыдущих транзакций. Каждый вход будет хранить открытый ключ (не хешированный) и подпись всей транзакции.Другие узлы в сети Bitcoin, которые получат транзакцию, тоже проверят ее. Помимо прочего, здесь происходит сопоставление хеша открытого ключа на входе транзакции с хешом соответствующего выхода, (это гарантирует, что отправитель тратит только принадлежащие ему монеты); подпись правильная (это гарантирует, что транзакция создана реальным владельцем монет).Когда узел готов к майнингу нового блока, он поместит транзакцию в блок и начнет добывать ее.Когда блок добыт, каждый другой узел в сети получает сообщение о том, что блок добыли и добавляет его в цепь.После того, как блок добавлен в цепь, транзакция завершена, теперь на ее выходы можно ссылаться в новых транзакциях.Эллиптическая криптографияКак мы уже с вами говорили, открытые и закрытые ключи представляют собой последовательности случайных байтов. Мы не хотим генерировать закрытый ключ, принадлежащий кому-то другому, поэтому возникает необходимость в особом алгоритме для генерации последовательностей. Bitcoin использует эллиптические кривые для генерации секретных ключей. Эллиптические кривые — это сложная математическая концепция, которую мы не будем здесь подробно объяснять (если интересно, можете почитать об этом здесь ПРЕДУПРЕЖДЕНИЕ: очень много математики!). Кривая, используемая Bitcoin, может случайным образом выбирать число между 0 и 2??? (что составляет приблизительно 10??, на заметку, атомов в видимой вселенной где-то между 10?? и 10??). Такой предел означает, что почти невозможно сгенерировать один и тот же закрытый ключ дважды.Кроме того, Bitcoin использует (и мы будем) алгоритм ECDSA для подписи транзакций.Base58Теперь давайте вернемся к вышеупомянутому адресу 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa. Теперь мы знаем, что это общепринятое для человека представление открытого ключа. И если мы его декодируем, он будет выглядеть примерно так (как последовательность байтов, записанных в шестнадцатеричной системе):0062E907B15CBF27D5425399EBF6F0FB50EBB88F18C29B7D93Bitcoin использует алгоритм Base58 для преобразования открытых ключей в читаемый человеком формат. Алгоритм очень похож на известный Base64, но он использует более короткий алфавит: некоторые буквы были удалены из алфавита, чтобы избежать гомографические атаки. В связи с этим, в этом алфавите отсутствуют следующие символы: 0 (ноль), О (заглавная буква «о»), I (заглавная «i»), l (строчная «L») а также знаки ""+"" и ""/"".Примерно так выглядит процесс получения адреса из открытого ключа:Следуя этой схеме, ключ, который мы привели выше, разделен на три части:Version            00Public key hash    62E907B15CBF27D5425399EBF6F0FB50EBB88F18Checksum           C29B7D93Хорошо, теперь, когда мы собрали все воедино, пришло время писать код! Я надеюсь, что сейчас все, что было непонятным прояснится. Реализация адресовНачнем со структуры кошелька Wallettype Wallet struct {	PrivateKey ecdsa.PrivateKey	PublicKey  []byte}type Wallets struct {	Wallets map[string]*Wallet}func NewWallet() *Wallet {	private, public := newKeyPair()	wallet := Wallet{private, public}	return &wallet}func newKeyPair() (ecdsa.PrivateKey, []byte) {	curve := elliptic.P256()	private, err := ecdsa.GenerateKey(curve, rand.Reader)	pubKey := append(private.PublicKey.X.Bytes(), private.PublicKey.Y.Bytes()...)	return *private, pubKey}Кошелек — не что иное, как пара ключей. Нам также понадобится тип Wallets, чтобы хранить коллекцию кошельков, сохранять их в файл и выгружать их из него. В конструкторе Wallet создается новая пара ключей. Функция newKeyPair проста, здесь мы используем ECDSA. Затем создается закрытый ключ с использованием кривой, и открытый ключ генерируется при помощи закрытого ключа. Одно замечание: в алгоритмах на основе эллиптической кривой открытые ключи являются точками на кривой. Таким образом, открытый ключ представляет собой комбинацию координат X, Y. В Bitcoin эти координаты объединяются и образуют открытый ключ.Теперь, создадим функцию генерации адреса:func (w Wallet) GetAddress() []byte {	pubKeyHash := HashPubKey(w.PublicKey)	versionedPayload := append([]byte{version}, pubKeyHash...)	checksum := checksum(versionedPayload)	fullPayload := append(versionedPayload, checksum...)	address := Base58Encode(fullPayload)	return address}func HashPubKey(pubKey []byte) []byte {	publicSHA256 := sha256.Sum256(pubKey)	RIPEMD160Hasher := ripemd160.New()	_, err := RIPEMD160Hasher.Write(publicSHA256[:])	publicRIPEMD160 := RIPEMD160Hasher.Sum(nil)	return publicRIPEMD160}func checksum(payload []byte) []byte {	firstSHA := sha256.Sum256(payload)	secondSHA := sha256.Sum256(firstSHA[:])	return secondSHA[:addressChecksumLen]}Разберем по шагам преобразование открытого ключа в адрес Base58:Возьмем открытый ключ и запишем его дважды с помощью алгоритмов хеширования RIPEMD160 (SHA256 (PubKey)).Подготовим версию.Вычислим контрольную сумму путем хеширования результата из шага 2 и SHA256 (SHA256 (payload)). Контрольная сумма — это первые четыре байта полученного хеша.Добавим контрольную сумму в комбинацию version+PubKeyHash.Зашифруем комбинацию version+PubKeyHash+checksum при помощи Base58.В результате вы получите настоящий адрес Bitcoin, вы можете даже проверить его баланс на blockchain.info. Но я больше чем уверен, что на счету этого адреса ничего не будет. Вот почему выбор правильного алгоритма шифрования с открытым ключом настолько важен: учитывая, что закрытые ключи являются случайными числами, вероятность генерации одного и того же числа должна быть как можно меньше. В идеале он не должен повторятся вообще.Обратите внимание, что вам не нужно подключаться к узлу Bitcoin для получения адреса. Алгоритм генерации адресов использует комбинацию алгоритмов, которые уже реализованы во многих стандартных библиотеках популярных языков программирования.Теперь нам нужно изменить входы и выходы для использования адресов:type TXInput struct {	Txid      []byte	Vout      int	Signature []byte	PubKey    []byte}func (in *TXInput) UsesKey(pubKeyHash []byte) bool {	lockingHash := HashPubKey(in.PubKey)	return bytes.Compare(lockingHash, pubKeyHash) == 0}type TXOutput struct {	Value      int	PubKeyHash []byte}func (out *TXOutput) Lock(address []byte) {	pubKeyHash := Base58Decode(address)	pubKeyHash = pubKeyHash[1 : len(pubKeyHash)-4]	out.PubKeyHash = pubKeyHash}func (out *TXOutput) IsLockedWithKey(pubKeyHash []byte) bool {	return bytes.Compare(out.PubKeyHash, pubKeyHash) == 0}Обратите внимание, что мы больше не используем поля ScriptPubKey и ScriptSig, вместо этого ScriptSig разделяется на поля Signature и PubKey, а ScriptPubKey переименован в PubKeyHash. Мы будем реализовывать те же функции блокировки/разблокировки выходов и логику подписей входов, как в Bitcoin, но реализуем мы это при помощи методов.Метод UsesKey проверяет, что вход использует определенный ключ для разблокировки выхода. Обратите внимание, что входы хранят нехешированные открытые ключи, а функция принимает хешированный. IsLockedWithKey  проверяет, был ли использован хеш-ключ открытого ключа для блокировки выхода. Это дополнительная функция для UsesKey, и они обе используются в FindUnspentTransactions для построения соединений между транзакциями.Lock просто блокирует выход. Когда мы отправляем монеты кому-то, нам известен только адрес, поэтому функция принимает адрес как единственный аргумент. Затем адрес декодируется, а хеш-ключ открытого ключа извлекается из него и сохраняется в поле PubKeyHash.Теперь давайте проверим, что все работает правильно:$ blockchain_go createwalletYour new address: 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt$ blockchain_go createwalletYour new address: 15pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h$ blockchain_go createwalletYour new address: 1Lhqun1E9zZZhodiTqxfPQBcwr1CVDV2sy$ blockchain_go createblockchain -address 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt0000005420fbfdafa00c093f56e033903ba43599fa7cd9df40458e373eee724dDone!$ blockchain_go getbalance -address 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXtBalance of '13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt': 10$ blockchain_go send -from 15pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h -to 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt -amount 52017/09/12 13:08:56 ERROR: Not enough funds$ blockchain_go send -from 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt -to 15pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h -amount 600000019afa909094193f64ca06e9039849709f5948fbac56cae7b1b8f0ff162Success!$ blockchain_go getbalance -address 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXtBalance of '13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt': 4$ blockchain_go getbalance -address 15pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5hBalance of '15pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h': 6$ blockchain_go getbalance -address 1Lhqun1E9zZZhodiTqxfPQBcwr1CVDV2syBalance of '1Lhqun1E9zZZhodiTqxfPQBcwr1CVDV2sy': 0Отлично! Пришла пора реализовать подписи транзакций.Реализация подписейТранзакции необходимо подписывать, так как это единственный способ гарантии в Bitcoin надежности транзакций. Если подпись недействительна, транзакция считается недействительной и, следовательно, не может быть добавлена в цепочку.У нас есть все для реализации подписей к транзакциям, кроме одного: данных для подписи. Какую часть транзакции мы должны подписывать? Или же необходимо подписывать сделку в целом? Выбор данных для подписи очень важен. Дело в том, что данные, которые должны быть подписаны, должны содержать информацию, которая идентифицирует данные уникальным образом. Например, нет смысла подписывать только выходные значения, потому что такая подпись не будет учитывать отправителя и получателя.Учитывая, что транзакции разблокируют предыдущие выходы, перераспределяют их значения и блокируют новые выходы, должны быть подписаны следующие данные:Хеши открытых ключей хранящиеся в разблокированных выходах. Это идентифицирует «отправителя» транзакции.Хеши открытых ключей хранящиеся в новых, заблокированных, выходах. Это идентифицирует «получателя» транзакции.Значения новых выходов.В Bitcoin логика блокировки/разблокировки хранится в скриптах, которые хранятся в ScriptSig и ScriptPubKey полей входов и выходов соответственно. Поскольку Bitcoin допускает разные типы таких скриптов, он подписывает все содержимое ScriptPubKey.В связи с этим в Bitcoin происходит подпись не транзакции, а ее обработанной копии со входами, содержащими ScriptPubKey указанного выходаЗдесь описан подробный процесс обработки копии транзакции. Скорее всего, он устарел, но мне не удалось найти более надежный источник информации.Все это выглядит достаточно сложным, давайте начнем писать код. А начнем мы с метода Sign:func (tx *Transaction) Sign(privKey ecdsa.PrivateKey, prevTXs map[string]Transaction) {	if tx.IsCoinbase() {		return	}	txCopy := tx.TrimmedCopy()	for inID, vin := range txCopy.Vin {		prevTx := prevTXs[hex.EncodeToString(vin.Txid)]		txCopy.Vin[inID].Signature = nil		txCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash		txCopy.ID = txCopy.Hash()		txCopy.Vin[inID].PubKey = nil		r, s, err := ecdsa.Sign(rand.Reader, &privKey, txCopy.ID)		signature := append(r.Bytes(), s.Bytes()...)		tx.Vin[inID].Signature = signature	}}Метод принимает закрытый ключ и ассоциативный массив предыдущих транзакций. Как уже упоминалось выше, для подписания транзакции нам необходимо получить доступ к выходам, указанным во входах транзакции, поэтому нам нужны транзакции, которые хранят эти выходы.Давайте внимательнее рассмотрим этот метод:if tx.IsCoinbase() {	return}Coinbase транзакции не подписаны, так как в них нет реальных выходовtxCopy := tx.TrimmedCopy()Мы подписываем обработанную копию, а не всю транзакцию:func (tx *Transaction) TrimmedCopy() Transaction {	var inputs []TXInput	var outputs []TXOutput	for _, vin := range tx.Vin {		inputs = append(inputs, TXInput{vin.Txid, vin.Vout, nil, nil})	}	for _, vout := range tx.Vout {		outputs = append(outputs, TXOutput{vout.Value, vout.PubKeyHash})	}	txCopy := Transaction{tx.ID, inputs, outputs}	return txCopy}Копия будет включать все входы и выходы, а TXInput.Signature и TXInput.PubKey будут равны nil.Затем пройдемся по каждому входу в копии:for inID, vin := range txCopy.Vin {	prevTx := prevTXs[hex.EncodeToString(vin.Txid)]	txCopy.Vin[inID].Signature = nil	txCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHashНа каждом входе Signature устанавливается на nil (просто двойная проверка), а PubKey присваиваем ссылку на выход в PubKeyHash. В настоящий момент все транзакции, кроме текущей, являются «пустыми», то есть поля подписи и PubKey равны нулю. Таким образом, входы подписываются отдельно, хотя это необязательно для нашего приложения, но Bitcoin позволяет транзакциям содержать входы, ссылающиеся на различные адреса.        txCopy.ID = txCopy.Hash()	txCopy.Vin[inID].PubKey = nilМетод Hash сериализует транзакцию и хеширует ее с помощью алгоритма SHA-256. Результатом являются данные готовые для подписи. После получения хеша мы должны сбросить поле PubKey, чтобы не было влияния на наши дальнейшие итерации.        r, s, err := ecdsa.Sign(rand.Reader, &privKey, txCopy.ID)	signature := append(r.Bytes(), s.Bytes()...)	tx.Vin[inID].Signature = signatureМы подписываем txCopy.ID при помощи privKey. Подпись ECDSA представляет собой пару чисел, которые мы объединяем и сохраняем в поле входа Signature.Рассмотрим функцию верификации:func (tx *Transaction) Verify(prevTXs map[string]Transaction) bool {	txCopy := tx.TrimmedCopy()	curve := elliptic.P256()	for inID, vin := range tx.Vin {		prevTx := prevTXs[hex.EncodeToString(vin.Txid)]		txCopy.Vin[inID].Signature = nil		txCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash		txCopy.ID = txCopy.Hash()		txCopy.Vin[inID].PubKey = nil		r := big.Int{}		s := big.Int{}		sigLen := len(vin.Signature)		r.SetBytes(vin.Signature[:(sigLen / 2)])		s.SetBytes(vin.Signature[(sigLen / 2):])		x := big.Int{}		y := big.Int{}		keyLen := len(vin.PubKey)		x.SetBytes(vin.PubKey[:(keyLen / 2)])		y.SetBytes(vin.PubKey[(keyLen / 2):])		rawPubKey := ecdsa.PublicKey{curve, &x, &y}		if ecdsa.Verify(&rawPubKey, txCopy.ID, &r, &s) == false {			return false		}	}	return true}Метод довольно простой. Для начала получим копию транзакции, как в прошлом методе:txCopy := tx.TrimmedCopy()Затем нам понадобится кривая, которая используется для генерации пар ключей:curve := elliptic.P256()Затем пройдемся по всем входам и проверим, что они подписаны:for inID, vin := range tx.Vin {	prevTx := prevTXs[hex.EncodeToString(vin.Txid)]	txCopy.Vin[inID].Signature = nil	txCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash	txCopy.ID = txCopy.Hash()	txCopy.Vin[inID].PubKey = nilЭта часть идентична той, что используется в методе Sign, так как во время проверки нам нужны те же самые данные, что мы и подписывали	r := big.Int{}	s := big.Int{}	sigLen := len(vin.Signature)	r.SetBytes(vin.Signature[:(sigLen / 2)])	s.SetBytes(vin.Signature[(sigLen / 2):])	x := big.Int{}	y := big.Int{}	keyLen := len(vin.PubKey)	x.SetBytes(vin.PubKey[:(keyLen / 2)])	y.SetBytes(vin.PubKey[(keyLen / 2):])Здесь мы распаковываем значения, хранящиеся в TXInput.Signature и TXInput.PubKey, так как сигнатура представляет собой пару чисел, а открытый ключ — это пара координат. Мы конкатенировали их раньше для хранения, и теперь нам нужно их распаковать для использования в функциях crypto/ecdsa.	rawPubKey := ecdsa.PublicKey{curve, &x, &y}	if ecdsa.Verify(&rawPubKey, txCopy.ID, &r, &s) == false {		return false	}}return trueТеперь мы создаем ecdsa.PublicKey, используя открытый ключ, который мы берем из входа, и выполняем ecdsa.Verify, передавая подпись, из входа. Если все входы проверены, мы возвращаем true; если хотя бы один вход не прошел проверку, возвращаем false.Теперь нам нужна функция для получения предыдущих транзакций. Поскольку для этого требуется взаимодействие со всей цепью, мы сделаем его методом Blockchain:func (bc *Blockchain) FindTransaction(ID []byte) (Transaction, error) {	bci := bc.Iterator()	for {		block := bci.Next()		for _, tx := range block.Transactions {			if bytes.Compare(tx.ID, ID) == 0 {				return *tx, nil			}		}		if len(block.PrevBlockHash) == 0 {			break		}	}	return Transaction{}, errors.New(""Transaction is not found"")}func (bc *Blockchain) SignTransaction(tx *Transaction, privKey ecdsa.PrivateKey) {	prevTXs := make(map[string]Transaction)	for _, vin := range tx.Vin {		prevTX, err := bc.FindTransaction(vin.Txid)		prevTXs[hex.EncodeToString(prevTX.ID)] = prevTX	}	tx.Sign(privKey, prevTXs)}func (bc *Blockchain) VerifyTransaction(tx *Transaction) bool {	prevTXs := make(map[string]Transaction)	for _, vin := range tx.Vin {		prevTX, err := bc.FindTransaction(vin.Txid)		prevTXs[hex.EncodeToString(prevTX.ID)] = prevTX	}	return tx.Verify(prevTXs)}FindTransaction находит транзакцию по идентификатору (для этого требуется итерация по всем блокам в цепи); SignTransaction берет одну транзакцию, находит транзакции, на которые она ссылается, и подписывает ее; VerifyTransaction просто проверяет транзакцию.Теперь нам нужно подписать и проверить транзакции. Подписывать мы будем в методе NewUTXOTransaction:func NewUTXOTransaction(from, to string, amount int, bc *Blockchain) *Transaction {	...	tx := Transaction{nil, inputs, outputs}	tx.ID = tx.Hash()	bc.SignTransaction(&tx, wallet.PrivateKey)	return &tx}Проверка транзакции происходит до того, как она будет добавлена в блок:func (bc *Blockchain) MineBlock(transactions []*Transaction) {	var lastHash []byte	for _, tx := range transactions {		if bc.VerifyTransaction(tx) != true {			log.Panic(""ERROR: Invalid transaction"")		}	}	...}Вот и все! Давайте проверим все еще раз:$ blockchain_go createwalletYour new address: 1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR$ blockchain_go createwalletYour new address: 1NE86r4Esjf53EL7fR86CsfTZpNN42Sfab$ blockchain_go createblockchain -address 1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR000000122348da06c19e5c513710340f4c307d884385da948a205655c6a9d008Done!$ blockchain_go send -from 1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR -to 1NE86r4Esjf53EL7fR86CsfTZpNN42Sfab -amount 60000000f3dbb0ab6d56c4e4b9f7479afe8d5a5dad4d2a8823345a1a16cf3347bSuccess!$ blockchain_go getbalance -address 1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avRBalance of '1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR': 4$ blockchain_go getbalance -address 1NE86r4Esjf53EL7fR86CsfTZpNN42SfabBalance of '1NE86r4Esjf53EL7fR86CsfTZpNN42Sfab': 6У нас даже ничего не сломалось, удивительно!Давайте закомментируем вызов bc.SignTransaction (& tx, wallet.PrivateKey) в NewUTXOTransaction, для гарантии того, что неподписанные транзакции нельзя будет майнить:func NewUTXOTransaction(from, to string, amount int, bc *Blockchain) *Transaction {   ...	tx := Transaction{nil, inputs, outputs}	tx.ID = tx.Hash()	// bc.SignTransaction(&tx, wallet.PrivateKey)	return &tx}$ go install$ blockchain_go send -from 1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR -to 1NE86r4Esjf53EL7fR86CsfTZpNN42Sfab -amount 12017/09/12 16:28:15 ERROR: Invalid transactionЗаключениеМы реализовали почти все ключевые особенности Bitcoin и это потрясающе. А в следующей части мы наконец-таки завершим реализацию транзакций.СсылкиFull source codesPublic-key cryptographyDigital signaturesElliptic curveElliptic curve cryptographyECDSATechnical background of Bitcoin addressesAddressBase58A gentle introduction to elliptic curve cryptography"
Waves_Platform;«Non-Blockchain Games Involving Money Must Die»;Блог компании Waves Децентрализованные сети Программирование *Разработка игр *Криптовалюты;"Dmitry Pichulin, known under the nick «deemru», won the game Fhloston Paradise, developed by Tradisys on the Waves blockchain. 

The winner of Fhloston Paradise was supposed to be the player paying the very last stake during a 60-block period, before any other player could pay their stake and reset the counter to zero. The winner would collect all stakes paid by other players.

Dmitry's winning recipe was the bot Patrollo, which he created. The bot paid just eight 1 WAVES stakes for Dmitry and eventually won him 4,700 WAVES ($13,100). In this interview, Dmitry discusses his bot and prospects of blockchain games.";/ru/company/waves/blog/445246/;"Dmitry Pichulin, known under the nick «deemru», won the game Fhloston Paradise, developed by Tradisys on the Waves blockchain. The winner of Fhloston Paradise was supposed to be the player paying the very last stake during a 60-block period, before any other player could pay their stake and reset the counter to zero. The winner would collect all stakes paid by other players.Dmitry's winning recipe was the bot Patrollo, which he created. The bot paid just eight 1 WAVES stakes for Dmitry and eventually won him 4,700 WAVES ($13,100). In this interview, Dmitry discusses his bot and prospects of blockchain games.Could you tell us about yourself? What do you do? When did you get interested in blockchain technology?I'm a developer in the area of information security. I came to the blockchain space with the 2017 hype, mastered the technology and stayed for the sake of technology.What was your main motivation to play the game?It was primarily interest in the tech part. I wanted to figure out how it works, uncover vulnerabilities, stop the game from ending and, of course, troll other players.Why did you choose to participate with a bot? How did you arrive at the idea for Patrollo? Could you provide more details about developing it?It didn't work with vulnerabilities. I deployed the game on the test net, played it with myself, tried various options, but everything turned out to be rock solid. There are no vulnerabilities in the contract. So, it became clear I wasn't going to win that way.How did you look for vulnerabilities? What hypotheses did you have?I had two hypotheses. First, an attack on checks of data types in DataTransaction entries. For instance, I assumed that it would be possible to bypass re-use of transaction IDs because of poor coding. The second hypothesis was an attack on integer overflow. I hoped there would be a way to set a too big or negative block height and try to get to the past.$tx = $wk->txBroadcast( $wk->txSign( $wk->txData( [ 'heightToGetMoney' => -9223372036854775807 ] ) ) );What did you do when you saw that your expectations regarding vulnerabilities didn’t come true?Tradisys said on its Telegram channel that when everything is quiet in the network, the game will last forever, but in a state of uncertainty, caused by node updates or unexpected forks, good bots will have higher chances. On the spot, I accepted the challenge to write a good bot, which I did in a few days. I wrote Patrollo's code in the PHP language, based on my framework WavesKit, in which I try to record all best technics for working with the blockchain. I ran it on the test net, uploaded the code to GitHub, released the bot to the main net and forgot about it.My configuration of Patrollo was supposed to implement two tasks: pay stakes as seldom as possible and operate with maximum reliability.The former was achieved thanks to paying extremely risky stakes – preferably in the very last block. Eventually, I set the bot for the second to last block, but with a 29 second delay. That allowed it to pay only eight stakes throughout the game.Why exactly 29 seconds? How did you arrive at this figure?I arrived at it gradually. First, there was no delay and I noticed that during the second to last block, simultaneous stakes were paid. So, paying stakes didn’t make sense. Then I added a delay — I think, it was 17 seconds, but it didn’t help: simultaneous stakes continued to be paid. So I decided to go for bigger risks to rule out simultaneous stakes. Why 17, 29 etc.? I just like prime numbers. 24, 25, 26, 27, 28, 30 are all composite numbers. And going above 30 seconds would have been too risky.How did you resolve the reliability issue?To a large degree, reliability was accomplished thanks to the mechanism of choosing the working node and, to a lesser degree, by sending a TransferTransaction for a stake in advance, so that the stake in the DataTransaction was definitely linked to a transaction existing on the blockchain.During each lap of the cycle, current height of all nodes set in the configuration was measured, and the node with the largest height was chosen for further interaction. In my opinion, that worked as protection against forks, unavailability, cashing and possible node errors. I'm confident that this simple mechanism eventually led to the victory.What are the main advantages of blockchain games? How promising are public blockchain, and, specifically, Waves, for game development?The main advantages are known, recorded and unchanging rules of the game, as well as equal conditions for access to the game from any place in the world.Non-blockchain games involving money must die.Waves has a reach tech functionality, but there are some nuances – both, typical of any blockchain and specific. So far, either haven't been reflected in the developer's existing instruments thoroughly enough.For instance, if you tried to react to transaction in real time rather than at a distance of five to ten confirmations, you would discover rare, but still extant instances of transactions' jumping from one block to another, disappearance and sudden reappearances in end blocks. All this is critical for speed and reliability of all applications and has to be resolved in a general way until developers achieve a necessary level of reliability by themselves. Certainly, in due course, all that will be resolved, but at this point, there is an entry barrier that's quite high, and a fear of the specifics of truly decentralized blockchains' operation in general.In what way is Fhloston Paradise different from other blockchain games you know?All games like that are long-term. Interest in games of that kind grows commensurately with the size of the prize, which, in turn, increases as time elapses.Ideally, the game wouldn't end at all. When it ends, it is sad…Recently, Fhloston Paradise 2 was launched. Do you plan to take part?Yes, as long as I have time and interest, I'll take the same steps: vulnerabilities analysis, playing with myself on the test net, creating a bot with open source etc.And, finally, tell us about your plans as a developer.I'm interested in resolving unresolved tasks, and in the blockchain space, there many of those. This is a true challenge. And it's been accepted."
memclutter;Blockchain на Go. Часть 1: Прототип;Go *;"Содержание

Blockchain на Go. Часть 1: Прототип
Blockchain на Go. Часть 2: Proof-of-Work
Blockchain на Go. Часть 3: Постоянная память и интерфейс командной строки
Blockchain на Go. Часть 4: Транзакции, часть 1
Blockchain на Go. Часть 5: Адреса
Blockchain на Go. Часть 6: Транзакции, часть 2
Blockchain на Go. Часть 7: Сеть

Блокчейн одна из самых революционных технологий 21 века, до сих пор не реализовавшая весь свой потенциал. По сути, блокчейн это просто распределенная база данных. Что же делает ее уникальной? Это база данных полностью открыта и хранится у каждого участника полной или частичной копией. Новая запись создается только с согласия всех кто хранит базу. Благодаря этому существуют такие вещи как криптовалюта и умные контракты.
В этой серии уроков мы создадим, основанную на блокчейне, упрощенную криптовалюту. В качестве языка используем Go.";/ru/post/348672/;"СодержаниеBlockchain на Go. Часть 1: ПрототипBlockchain на Go. Часть 2: Proof-of-WorkBlockchain на Go. Часть 3: Постоянная память и интерфейс командной строкиBlockchain на Go. Часть 4: Транзакции, часть 1Blockchain на Go. Часть 5: АдресаBlockchain на Go. Часть 6: Транзакции, часть 2Blockchain на Go. Часть 7: СетьБлокчейн одна из самых революционных технологий 21 века, до сих пор не реализовавшая весь свой потенциал. По сути, блокчейн это просто распределенная база данных. Что же делает ее уникальной? Это база данных полностью открыта и хранится у каждого участника полной или частичной копией. Новая запись создается только с согласия всех кто хранит базу. Благодаря этому существуют такие вещи как криптовалюта и умные контракты.В этой серии уроков мы создадим, основанную на блокчейне, упрощенную криптовалюту. В качестве языка используем Go.БлокНачнем с ""блока"" части ""блокчейна"". В блокчейне, блоки хранят полезную информацию. Например, в bitcoin блоки хранят транзакции, суть любой криптовалюты. Помимо полезной информации, в блоке содержится служебная информация: версия, дата создания в виде timestamp и хеш предыдущего блока. В этой статье мы будем создавать упрощенный блок, содержащий только существенную информацию. Опишем его в виде go структуры.type Block struct {    Timestamp     int64    Data          []byte    PrevBlockHash []byte    Hash          []byte}Timestamp это время создания блока, Data это полезная информация, содержащаяся в блоке, PrevBlockHash хранит хэш предыдущего блока, и наконец, Hash содержит хэш блока. В спецификации bitcoin Timestamp, PrevBlockHash и Hash образуют заголовок блока и образуют отдельную от транзакций (в нашем случае это Data) структуру. Мы же смешали их для простоты.Как вычисляется хэши? Вычисление хэшей одна из важных свсойств блокчейна, благодаря ему он считается безопасным. Все потому, что вычисление хэша это довольно сложная операция (именно поэтому майнеры покупали мощные видеокарты, для добычи биткойна). Это было задумано специально, предотвращая от изменения всей цепочки. Обсудим это в следующей статье, а сейчас мы просто соеденим все поля блока и захэшируем результат в SHA-256:func (b *Block) SetHash() {    timestamp := []byte(strconv.FormatInt(b.Timestamp, 10))    headers := bytes.Join([][]byte{b.PrevBlockHash, b.Data, timestamp}, []byte{})    hash := sha256.Sum256(headers)    b.Hash = hash[:]}Далее, создадим ""конструктор"" для нашего блокаfunc NewBlock(data string, prevBlockHash []byte) *Block {    block := &Block{time.Now().Unix(), []byte(data), prevBlockHash, []byte{}}    block.SetHash()    return block}Блок готов!БлокчейнТеперь давайте напишем блокчейн. По сути, блокчейн это база данных определенной структуры: упорядоченный связанный список. Это означает, что блоки хранятся в порядке вставки, при чем каждый блок связан с предыдущем. Такая структура позволяет получить последний блок в цепочке и эффективно получить блок по его хэшу.В Golang эта структура может быть реализована с помощью массива (array) и карты (map): массив будет содержать упорядоченный список хэшей (массивы упорядоченны в Go), а карты будут хранить пары hash -> block (карты не упорядочены). Но для нашего прототипа, мы будем использовать только массивы потому, что нам не требуется получать блок по его хэшу.type Blockchain struct {    blocks []*Block}Это наш первый блокчейн! Никогда не думал, что это так просто :)Добавим возможность добавлять блоки в него.func (bc *Blockchain) AddBlock(data string) {    prevBlock := bc.blocks[len(bc.blocks)-1]    newBlock := NewBlock(data, prevBlock.Hash)    bc.blocks = append(bc.blocks, newBlock)}Чтобы добавить первый блок, нам нужен существующий, но наш блокчейн пуст! Таким образом нам в любом блокчейне должен быть как минимум один блок, который называют genesis блоком. Реализуем метод, создающий такой блок.func NewGenesisBlock() *Block {    return NewBlock(""Genesis Block"", []byte{})}А теперь реализуем функцию создающую блокчейн с genesis блоком.func NewBlockchain() *Blockchain {    return &Blockchain{[]*Block{NewGenesisBlock()}}}Давайте проверим, что блокчейн работает корректноfunc main() {    bc := NewBlockchain()    bc.AddBlock(""Send 1 BTC to Ivan"")    bc.AddBlock(""Send 2 more BTC to Ivan"")    for _, block := range bc.blocks {        fmt.Printf(""Prev. hash: %x\n"", block.PrevBlockHash)        fmt.Printf(""Data: %s\n"", block.Data)        fmt.Printf(""Hash: %x\n"", block.Hash)        fmt.Println()    }}Этот код выведетPrev. hash:Data: Genesis BlockHash: aff955a50dc6cd2abfe81b8849eab15f99ed1dc333d38487024223b5fe0f1168Prev. hash: aff955a50dc6cd2abfe81b8849eab15f99ed1dc333d38487024223b5fe0f1168Data: Send 1 BTC to IvanHash: d75ce22a840abb9b4e8fc3b60767c4ba3f46a0432d3ea15b71aef9fde6a314e1Prev. hash: d75ce22a840abb9b4e8fc3b60767c4ba3f46a0432d3ea15b71aef9fde6a314e1Data: Send 2 more BTC to IvanHash: 561237522bb7fcfbccbc6fe0e98bbbde7427ffe01c6fb223f7562288ca2295d1Наш прототип работает!ЗаключениеМы только что построили очень простой прототип блокчейна: простого массива блоков, каждый из которых связан с предыдущим. Настоящий блокчейн намного сложнее. Наш блокчейн добавляет новые блоки очень легко и быстро, в реальном же блокчейне добавление новых блоков требует определенной работы: выполнение сложных вычислений, перед получением права на добавления блока (этот механизм называется Prof-of-Work). Кроме того, блокчейн — распределенная база, которая не имеет единого центра принятия решения. Таким образом, новый блок должен быть подтвержден и одобрен другими участниками сети (данный механизм называется консенсусом). Ну и собственно у нас пока нет самих транзакций.Все эти свойства мы рассмотрим в будущих статьях.СсылкиИсходный код для статьи."
deemru;Random oracle based on blockchain digital signature;Децентрализованные сети Криптография *Программирование *Криптовалюты;From idea to implementation: modifying the existing elliptic curve signature scheme to be deterministic and providing functions on it to obtain verifiable within the blockchain pseudorandom numbers.;/ru/post/449342/;"From idea to implementation: modifying the existing elliptic curve signature scheme to be deterministic and providing functions on it to obtain verifiable within the blockchain pseudorandom numbers.IdeaIn the autumn of 2018, when first smart contracts were activated on the Waves blockchain, the topic of obtaining pseudorandom numbers in a trusted way arose naturally.Thinking about it, I came to the conclusion that any blockchain is sort of a cage, and getting a trusted source of entropy in an enclosed system is impossible.However, I liked one idea. If a random oracle signs user data with a deterministic algorithm, the user will always be able to verify such a signature by the public key to make sure that the obtained value is unique. The oracle wouldn't be able to make any changes because the algorithm comes up with a single-valued result. Basically, the user fixes the result but doesn't know it until it is published by the oracle. So, you may not trust the oracle at all, but still be able to verify the result of its operation. Then, in case of successful verification, such a signature can be a source of entropy for a pseudorandom number.On the Waves blockchain, the signature scheme EdDSA variant Ed25519 is used. In that scheme, the signature consists of the values R and S. R is dependable on a random value and S is calculated on the basis of a signed message, a private key and the same random number as R. There is no unique dependence, and several valid signatures exist for the same user message.Apparently, this kind of signature by itself cannot be used as a source of pseudorandom numbers because it is indeterminate and, therefore, can easily be manipulated by the oracle.However, as it turns out, it's actually possible to make it deterministic.My high hopes were set for the verifiable random function (VRF), but, after studying its specifics, i have to reject that option. Although VRF offers a determinate version of a signature and its proofs, the algorithm has an odd place that opens a black hole for manipulations by the oracle (this statement is wrong, see Update). Specifically, for calculating the value of k (section 5.1), a private key is used, which remains unknown to the user, so the user cannot verify the correctness of calculating k. As a result, the oracle can use any value of k that it needs and simultaneously run a database for correlations between k and signed data to be able to always re-calculate a correct result for VRF. If you see a VRF-based raffle without revealing the private key, you can show off and point to the need to either reveal the key or remove it from calculating k so it will automatically reveal itself after the first signature. Overall, as said above, this is an odd scheme for the random oracle.Upon some reflection and with support from local analysts, a scheme for VECRO operation was born.VECRO stands for the Verifiable Elliptic Curve Random Oracle. It turned out to be rather simple. To achieve determinacy, we need to fix the value of R before appearance of a message to be signed. If R is fixed and R is part of the message, which additionally guarantees that R is fixed before the message. The value of S is completely determined by a user message and, therefore, can be used as a source of pseudorandom numbers.In a scheme of this kind, how exactly R is fixed is irrelevant and remains in the oracle's zone of responsibility. What is important is that S is completely determined by the user, but its value is not revealed until published by the oracle. This is exactly what we wanted!Speaking of fixating R, note that re-usage of R for signing various messages completely reveals the private key in the EdDSA scheme. For the oracle's owner, it's vital to exclude re-usage of R for signing various user messages. I.e., in any manipulations or collusion, the oracle will always risk losing its private key.So, the oracle will offer two functions to the user: initialization, which fixes the value of R and a signature, which returns the value of S. Meanwhile, the R, S pair is a regular verifiable signature for a user message containing a fixed value of R and the user's random data.One can argue that for blockchain, this is nothing but a regular commit reveal scheme. Basically, that's what it is. But there are a few nuances. First, the oracle uses the same key in all transactions, which, for instance, is convenient for contracts. Second, there is a risk of losing a private key by the oracle because of incorrect performance. For instance, if the oracle facilitates tests of the result, just two tests will be sufficient to figure out the private key and get access to the wallet. Third, a natively verified signature on the blockchain, which is the source of randomness, is just beautiful.For about six months, this idea was germinating, until a motivation to implement it arrived in the form of a grant from Waves Labs. With the great grant comes great responsibility, it means the project to be!ImplementationVECRO was implemented on the Waves blockchain in the request/reply mode using transfer transactions between the user and the oracle. On the oracle's account, a script is set that controls operation strictly in accordance with logic described above. The oracle's transactions are verified by recreation of the entire chain of user interaction. All four transactions are involved in verifying the final value. A smart contract adds all of them to a strict verification thread, checking values step by step and leaving no room for any manipulations.Let's try to put it in simple terms. The oracle doesn't just work under a proposed scheme. Its operation is fully controlled at the blockchain level by a dead-strict smart contract. Any tiny diversion would lead to transaction rejection. So, if the transaction is on the blockchain, users don't have to verify anything, as all verification has already been done by hundreds of the blockchain's nodes.At the moment, one VECRO is operable on Waves' mainnet. You could actually launch yours: it's simple, just look at the configuration example. The current code works on PHP (on WavesKit, which I discussed earlier).To use the oracle, you need to:Fixate R;Send a minimum of 0.005 WAVES to the oracle's alias init@vecr;Receive an R-code in the attachment field in the 1 R-vecr token transfer from the oracle to the user;Get a signature;Send a minimum of 0.005 WAVES to the oracle's alias random@vecr. You are also REQUIRED to enter in the attachment field the received R-code and additional user data;Receive an S-code in the attachment field in the 1 S-vecr token transfer from the oracle to the user;Use the S-code as a source of pseudorandom numbers.Nuances of current implementation:WAVES sent to the oracle are used as fees for the return transaction to the user, up to the maximum of 1 WAVES;R-code is a concatenation of the ‘R’ symbol byte and 32 bytes R value in the base58 coding;R-code in the attachment has to precede user data;S-code is a concatenation of the ‘S’ symbol byte and 32 bytes S value in the base58 coding;S is the result of a modulo division and cannot be used as a proper 256 bit pseudorandom number (it can be considered a 252 bit pseudorandom number at most);The easiest option is the use of S-code's hash as a source for pseudorandom number.Examples of receiving S-code:Initialization: https://wavesexplorer.com/tx/8gc8jwM7JrPNehoDs7NVyos7BsufYktvkwVW1B6FAY6Receiving R-code: https://wavesexplorer.com/tx/9eB25SbzEwvHEbm8pcKj7MGDrYv1u3Fxpj696FkJ96hdRequest of signing R-code and user message with value “ random”: https://wavesexplorer.com/tx/6faoFJobEsugDFYmYmfsbtQYABmckNuE2kevaLh7ifzzReceiving S-code: https://wavesexplorer.com/tx/C5VrFLQcprbA1KXAToaNvMP4Kg2rq43NkwWuADAA7wXXFrom a technical point of view, the oracle is fully operational, you can safely use it. From the point of view of an ordinary user, there is not enough user-friendly GUI, that will have to wait.I will be happy to answer questions and accept comments, thank you.Update (May 8th, 2019)I was wrong on VRF. Yes, it is true that the ECVRF signature cannot be used as a source of a pseudorandom number, but it is not used for this purpose. The signature is needed to prove the uniqueness of the Gamma value (section 5.3, step 6). And the verified value of Gamma will be used as a source of a pseudorandom number (section 5.2, step 5). Thanks to Oleg Taraskin Crittografo for pointing at this moment, I admit my mistake. ECVRF has the full right to live.Unfortunately, there is still no possibility to use ECVRF at the Waves blockchain level, because of the lack of the necessary mathematical functionality in smart contracts.When this functionality or RSA support will become available, new oracles can be created. As for the VECRO scheme, it occupies its niche in any case and allows you to work without any additional functionality."
greebn9k;The Data Structures of the Plasma Cash Blockchain's State;Информационная безопасность *Криптография *Программирование *Криптовалюты;Hello, dear Habr users! This article is about Web 3.0 — the decentralized Internet. Web 3.0 introduces the concept of decentralization as the foundation of the modern Internet. Many computer systems and networks require security and decentralization features to meet their needs. A distributed registry using blockchain technology provides efficient solutions for decentralization.;/ru/post/455988/;"Hello, dear Habr users! This article is about Web 3.0 — the decentralized Internet. Web 3.0 introduces the concept of decentralization as the foundation of the modern Internet. Many computer systems and networks require security and decentralization features to meet their needs. A distributed registry using blockchain technology provides efficient solutions for decentralization.Blockchain is a distributed registry. You can think of it as a huge database that lives forever, never changing over the course of time. The blockchain provides the basis for decentralized web applications and services.However, the blockchain is more than just a database. It serves to increase security and trust between network members, enhancing online business transactions. Byzantine consensus increases network reliability and solves the problem of consistency.The scalability provided by DLT changes existing business networks.Blockchain offers new, very important benefits:Prevents costly mistakes.Ensures transparent transactions.Digitalizes real goods.Enforces smart contracts.Increases the speed ??and security of payments.We have developed a special PoE to research cryptographic protocols and improve existing DLT and blockchain solutions.Most public registry systems lack the property of scalability, making their throughput rather low. For example, Ethereum processes only ~ 20 tx/s.Many solutions were developed to increase scalability while maintaining decentralization. However, only 2 out of 3 advantages — scalability, security, and decentralization — can be achieved simultaneously.The use of sidechains provides one of the most effective solutions. The Plasma ConceptThe Plasma concept boils down to the idea that a root chain processes a small number of commits from child chains, thereby acting as the most secure and final layer for storing all intermediate states. Each child chain works as its own blockchain with its own consensus algorithm, but there are a few important caveats.Smart contracts are created in a root chain and act as checkpoints for child chains within the root chain.A child chain is created and functions as its own blockchain with its own consensus. All states in the child chain are protected by fraud proofs that ensure all transitions between states are valid and apply a withdrawal protocol.Smart contracts specific to DApp or child chain application logic can be deployed in the child chain.Funds can be transferred from the root chain to the child chain.Validators are given economic incentives to act honestly and send commitments to the root chain — the final transaction settlement layer.As a result, DApp users working in the child chain do not have to interact with the root chain at all. In addition, they can place their money in the root chain whenever they want, even if the child chain is hacked. These exits from the child chain allow users to securely store their funds with Merkle proofs, confirming ownership of a certain amount of funds.Plasma's main advantages are related to its ability to significantly facilitate calculations that overload the main chain. In addition, the Ethereum blockchain can handle more extensive and parallel data sets. Time removed from the root chain is also transferred to Ethereum nodes, which have lower processing and storage requirements.Plasma Cash assigns unique serial numbers to online tokens. The advantages of this scheme include no need for confirmations, simpler support for all types of tokens (including Non-fungible tokens), and mitigation against mass exits from a child chain.The concept of “mass exits” from a child chain is a problem faced by Plasma. In this scenario, coordinated simultaneous withdrawals from a child chain could potentially lead to insufficient computing power to withdraw all funds. As a result, users may lose funds.Options for implementing PlasmaBasic Plasma has a lot of implementation options.The main differences refer to:archiving information about state storage and presentation methods;token types (divisible, indivisible);transaction security;consensus algorithm type.The main variations of Plasma include:UTXO-based Plasma — each transaction consists of inputs and outputs. A transaction can be conducted and spent. The list of unspent transactions is the state of a child chain itself.Account-based Plasma — this structure contains each account's reflection and balance. It is used in Ethereum, since each account can be of two types: a user account and a smart contract account. Simplicity is an important advantage of account-based Plasma. At the same time, the lack of scalability is a disadvantage. A special property, «nonce,» is used to prevent the execution of a transaction twice.In order to understand the data structures used in the Plasma Cash blockchain and how commitments work, it is necessary to clarify the concept of Merkle Tree.Merkle Trees and their use in PlasmaMerkle Tree is an extremely important data structure in the blockchain world. It allows us to capture a certain data set and hide the data, yet prove that some information was in the set. For example, if we have ten numbers, we could create a proof for these numbers and then prove that some particular number was in this set. This proof would have a small constant size, which makes it inexpensive to publish in Ethereum.You can use this principle for a set of transactions, and prove that a particular transaction is in this set. This is precisely what an operator does. Each block consists of a transaction set that turns into a Merkle Tree. The root of this tree is a proof that is published in Ethereum along with each Plasma block.Users should be able to withdraw their funds from the Plasma chain. For this, they send an “exit” transaction to Ethereum.Plasma Cash uses a special Merkle Tree that eliminates the need to validate a whole block. It is enough to validate only those branches that correspond to the user's token.To transfer a token, it is necessary to analyze its history and scan only those tokens that a certain user needs. When transferring a token, the user simply sends the entire history to another user, who can then authenticate the entire history and, most importantly, do it very quickly.Plasma Cash data structures for state and history storageIt is advisable to use only selected Merkle Trees, because it is necessary to obtain inclusion and non-inclusion proofs for a transaction in a block. For example:Sparse Merkle TreePatricia TreeWe have developed our own Sparse Merkle Tree and Patricia Tree implementations for our client.A Sparse Merkle Tree is similar to a standard Merkle Tree, except that its data is indexed, and each data point is placed on a leaf that corresponds to this data point's index.Suppose we have a four-leaf Merkle Tree. Let's fill this tree with letters A and D, for demonstration. The letter A is the first alphabet letter, so we will place it on the first leaf. Similarly, we will place D on the fourth leaf.So what happens on the second and third leaves? They should be left empty. More precisely, a special value (for example, zero) is used instead of a letter.The tree eventually looks like this:The inclusion proof works in the same way as in a regular Merkle Tree. What happens if we want to prove that C is not a part of this Merkle Tree? Elementary! We know that if C is a part of a tree, it would be on the third leaf. If C is not a part of the tree, then the third leaf should be zero.All that is needed is a standard Merkle inclusion proof showing that the third leaf is zero.The best feature of a Sparse Merkle Tree is that it provides repositories for key-values inside the Merkle Tree!A part of the PoE protocol code constructs a Sparse Merkle Tree:class SparseTree { //...        buildTree() {    if (Object.keys(this.leaves).length > 0) {      this.levels = []      this.levels.unshift(this.leaves)      for (let level = 0; level  {          let leafHash = currentLevel[leafKey]          let isEvenLeaf = this.isEvenLeaf(leafKey)          let parentLeafKey = leafKey.slice(0, -1)          let neighborLeafKey = parentLeafKey + (isEvenLeaf ? '1' : '0')           let neighborLeafHash = currentLevel[neighborLeafKey]          if (!neighborLeafHash) {            neighborLeafHash = this.defaultHashes[level]          }           if (!nextLevel[parentLeafKey]) {            let parentLeafHash = isEvenLeaf ?              ethUtil.sha3(Buffer.concat([leafHash, neighborLeafHash])) :              ethUtil.sha3(Buffer.concat([neighborLeafHash, leafHash]))            if (level == this.depth - 1) {              nextLevel['merkleRoot'] = parentLeafHash            } else {              nextLevel[parentLeafKey] = parentLeafHash            }          }        })         this.levels.unshift(nextLevel)      }    }  }} This code is quite trivial. We have a key-value repository with an inclusion / non-inclusion proof.In each iteration, a specific level of a final tree is filled, starting with the last one. Depending on whether the key of the current leaf is even or odd, we take two adjacent leaves and count the hash of the current level. If we reach the end, we would write down a single merkleRoot — a common hash.You have to understand that this tree is filled with initially empty values. If we stored a huge amount of token IDs, we would have a huge tree size, and it would be long!There are many remedies for this non-optimization, but we have decided to change this tree to a Patricia Tree.A Patricia Tree is a combination of Radix Tree and Merkle Tree.A Radix Tree data key stores the path to the data itself, which allows us to create an optimized data structure for memory.Here is an implementation developed for our client:buildNode(childNodes, key = '', level = 0) {    let node = {key}    this.iterations++     if (childNodes.length == 1) {      let nodeKey = level == 0 ?        childNodes[0].key :        childNodes[0].key.slice(level - 1)      node.key = nodeKey       let nodeHashes = Buffer.concat([Buffer.from(ethUtil.sha3(nodeKey)),        childNodes[0].hash])      node.hash = ethUtil.sha3(nodeHashes)      return node    }     let leftChilds = []    let rightChilds = []     childNodes.forEach((node) => {      if (node.key[level] == '1') {        rightChilds.push(node)      } else {        leftChilds.push(node)      }    })     if (leftChilds.length && rightChilds.length) {      node.leftChild = this.buildNode(leftChilds, '0', level + 1)      node.rightChild = this.buildNode(rightChilds, '1', level + 1)      let nodeHashes = Buffer.concat([Buffer.from(ethUtil.sha3(node.key)),        node.leftChild.hash,        node.rightChild.hash])      node.hash = ethUtil.sha3(nodeHashes)    } else if (leftChilds.length && !rightChilds.length) {      node = this.buildNode(leftChilds, key + '0', level + 1)    } else if (!leftChilds.length && rightChilds.length) {      node = this.buildNode(rightChilds, key + '1', level + 1)    } else if (!leftChilds.length && !rightChilds.length) {      throw new Error('invalid tree')    }     return node  } We moved recursively and built the separate left and right subtrees. A key was built as a path in this tree.This solution is even more trivial. It is well-optimized and works faster. In fact, a Patricia Tree may be optimized even more by introducing new node types — extension node, branch node, and so on, as done in the Ethereum protocol. But the current implementation satisfies all our requirements — we have a fast and memory-optimized data structure.By implementing these data structures in our client’s project, we have made Plasma Cash scaling possible. This allows us to check a token’s history and inclusion / non-inclusion of the token in a tree, greatly accelerating the validation of blocks and the Plasma Child Chain itself. Links:White Paper PlasmaGit hubUse cases and architecture descriptionLightning Network Paper"
marks;IBM открывает blockchain-лабораторию;Блог компании IBM Высокая производительность *Информационная безопасность *;"Корпорация IBM совместно с некоммерческой организацией Innovate Finance планирует провести изучение потенциала технологии Blockchain с целью разработки новых методов ведения бизнеса в современных условиях. На основе этой технологии создавалась система криптовалюты Bitcoin, успешно функционирующая уже несколько лет. Криптовалюта сейчас превратилась в признанное платежное средство, виртуальную денежную единицу, которая принимается крупными и мелкими предприятиями, корпорациями и сервисами. 

Теперь IBM планирует изучить дополнительные возможности Blockchain, задействуя собственные вычислительные и аналитические мощности. Технология, о которой идет речь, сейчас привлекает внимание банков и финансовых структур, которые изучают Blockchain с целью реализации новых проектов.";/ru/company/ibm/blog/274501/;Корпорация IBM совместно с некоммерческой организацией Innovate Finance планирует провести изучение потенциала технологии Blockchain с целью разработки новых методов ведения бизнеса в современных условиях. На основе этой технологии создавалась система криптовалюты Bitcoin, успешно функционирующая уже несколько лет. Криптовалюта сейчас превратилась в признанное платежное средство, виртуальную денежную единицу, которая принимается крупными и мелкими предприятиями, корпорациями и сервисами. Теперь IBM планирует изучить дополнительные возможности Blockchain, задействуя собственные вычислительные и аналитические мощности. Технология, о которой идет речь, сейчас привлекает внимание банков и финансовых структур, которые изучают Blockchain с целью реализации новых проектов. Представители Innovate Finance уже сообщили, что партнеры проекта смогут получить доступ к высокопроизводительным компьютерным системам, расположенным в вычислительном центре Hartree. О самой технологии Blockchain можно сказать, что она обеспечивает отслеживание передвижения криптовалюты с одного кошелька на другой. Но эта же технология может быть использована и в других целях. «Blockchain, как технология, весьма интересна и перспективна», — считает Арвинд Кришна, вице-президент IBM Research.Генеральный директор Innovate Finance Лоуренс Винтмейер заявил, что если разработка новых стандартов и технологий на основе blockchain будет проводиться эффективно, вскоре станет возможной повсеместная реализация blockchain, включая использование технологии в банках, финансовых структурах, платежных сервисах.Зачем все это? Представители IBM считают, что bitcoin может стать «наличными будущего». В настоящее время корпорация работает над созданием open-source программного обеспечения, при помощи которого партнеры смогут заключать цифровые договоры, которые будут фиксироваться в глобальной сети. За прошедший год исследователи из IBM разработали собственную версию blockchain, возможности которой тестируются для указанной выше цели. На практике это может выглядеть следующим образом. Например, китайский поставщик и покупатель из США договариваются о проведении сделки, а банк США, в котором открыт счет покупателя, проводит оплату поставщику через Интернет.Также в январе IBM повела эксперимент, получивший название Adept. Его цель — отслеживание подключенных к Сети устройств при помощи все той же технологии blockchain.В самой лаборатории команда проекта будет работать над созданием платежных приложений, способов борьбы с противозаконными методами использования криптовалют и т.п. «Я бы хотел расширить банковские услуги на тех 3,2 миллиарда человек, которые станут средним классом в ближайшие 15 лет. Поэтому я бы хотел снизить стоимость бухгалтерских услуг. И у Blockchain для этого есть все возможности», — прокомментировал перспективы проекта Арвинд Кришна.
ChetuMarketing;9 Key Benefits Of Blockchain Technology In Sports Software;Криптография *Криптовалюты;"There are numerous benefits provided by blockchain technology for sports betting software. The nine key benefits are detailed below. 

Security of Blockchain

When this technology is integrated into sports betting software, there is a permanent and unchangeable record in the transaction ledger providing transparency. Sportsbooks must be certain their betting data is delivered safely with all bets resolved correctly and quickly. This technology provides significantly better protection through the use of smart contracts. Decentralized actors handle the wagers with the smart contracts being executed automatically. Publicly written data cannot be altered. The complex system of the past is simplified and performed for much less than the traditional costs. Blockchain Development Services, Blockchain Solutions are paramount not only in sports betting but every aspect of the new business world. Blockchain technology experts integrate cryptocurrency payment solutions, program smart contracts, and engineer blockchain networks and apps.

This provides better protection, flawless bet execution, enhanced data security, and complete information transparency. The use of cryptocurrency significantly decreases the fees for payment processing. This reduces the margins for the sportsbook while offering players an increased chance to win. Once the bets have been resolved with a smart contract, the funds will be in the wallet of the better for almost immediate withdrawal. Any issues for even larger amounts are eliminated due to cryptocurrency payouts.";/ru/post/476578/;There are numerous benefits provided by blockchain technology for sports betting software. The nine key benefits are detailed below. Security of BlockchainWhen this technology is integrated into sports betting software, there is a permanent and unchangeable record in the transaction ledger providing transparency. Sportsbooks must be certain their betting data is delivered safely with all bets resolved correctly and quickly. This technology provides significantly better protection through the use of smart contracts. Decentralized actors handle the wagers with the smart contracts being executed automatically. Publicly written data cannot be altered. The complex system of the past is simplified and performed for much less than the traditional costs. Blockchain Development Services, Blockchain Solutions are paramount not only in sports betting but every aspect of the new business world. Blockchain technology experts integrate cryptocurrency payment solutions, program smart contracts, and engineer blockchain networks and apps.This provides better protection, flawless bet execution, enhanced data security, and complete information transparency. The use of cryptocurrency significantly decreases the fees for payment processing. This reduces the margins for the sportsbook while offering players an increased chance to win. Once the bets have been resolved with a smart contract, the funds will be in the wallet of the better for almost immediate withdrawal. Any issues for even larger amounts are eliminated due to cryptocurrency payouts. Smart ContractsSmart contracts enable trustless transactions. This eliminates the need for a centralized party, enabling the transactions to be processed exactly the way they should be. The betting data is written using blockchain technology which cannot be altered. The additional security in the betting software preserves data integrity while being shared publicly. This prevents tampering and streamlines the data flow. The system rewards bettors contributing data while decreasing the cost for the operators. The savings of the operator can be used for better promotions or friendlier lines. The operators are then able to attract additional bettors to the sportsbook and the betting industry. Honoring the bets can then become paramount. One of the biggest advantages of using new technology for betting software is cryptocurrency. One of the main processors has already made the announcement they will be offering select merchants free processing for cryptocurrency. This is just the beginning of new gaming opportunities and gambling based on cryptocurrency. The expectations are the other processors' will start decreasing their transaction fees even more. This will offer better odds to the player for winning by reducing the margins of the sportsbooks. This will help with the growth of the betting industry. TransparencyThe key concern of sportsbook bettors is gaming results, payoffs and winnings are partially concealed or intentionally hidden. These concerns can be resolved with new technology. Records are verified on a shared ledger. This transparency will increase customer trust so they can bet with confidence. Fraud is eliminated due to completely secure transactions through a distributed ledger. All winnings are calculated automatically and sent to the bettor. The use of cryptocurrency for an alternative method of payment has already been successful. One gambling site already has more Bitcoin transactions than a combination of all exchange platforms. Value is created by the democratization, offering an immutable and secure decentralized structure. Deposits and withdrawals using cryptocurrency are completely transparent because intermediaries including banks are no longer necessary. Sportsbooks require documents to establish and verify accounts. This process is time-consuming and lengthy. New technology resolves these issues because it is anonymous. Transactions can be conducted without revealing personal information. Hackers are hindered from accessing the data of the users. Due to the prohibited betting in numerous locations, gambling enthusiasts suffer. When illegal bookmakers do not pay it can lead to death or assault. A decentralized platform enables bettors to use cryptocurrency. Bets can then be made all over the world with just an internet connection. Smart BettingOne of the biggest issues for the bookmakers and players is liquidity. The player deposits a certain amount of funds in their account so they can make bets. These funds do not earn interest. Payments involve numerous facets including the customer, company and payment gateway. Payment gateways are necessary for processing all withdrawal requests. The payment gateways receive their fees prior to the customer receiving their funds. The customer must then pay the levied tax which results in fewer earnings. These issues are eliminated with blockchain. Cryptocurrencies such as Ethereum and Bitcoin are the answer for the industry of sports betting. The result is higher payouts for the customers and better margins for the operators.When cryptocurrency is used for the sports betting platform, fair and immediate payouts are guaranteed for the bettors. A central authority is no longer required for numerous processes including payments. The technology handles the transactions with everything being secure for all parties. Smart betting is when sports betting platforms use smart contracts. Codes are self-executed for every action meeting the defined criteria. Online betting platforms can use smart contracts so bets can be automatically placed for specific events such as when a penalty kick occurs in football. This will ensure lower costs, transparency and speed while addressing any issues. The costs for financial reporting will decrease roughly seventy percent. PayoutsAn improved forecast for sports betting, transparent networks and more predictive and accurate results are achieved through technology. This improves the reliability of the bookie odds system. Gamblers are currently dependent on betting track records from analytics providers and experts. This data is meant to back up their content but the predictive forecast is missing. Smart contracts offer proof of the betting performance. Bettors can use this information to improve their odds through approved analytics channels and better decisions. A tamper-proof ledger is used to permanently record and track bets and payouts. This enables the bettors to follow their bets by using copy betting. Funds are sent right to a digital wallet and trades are executed automatically through the creation of escrow and a smart contract. Automated measures for risk management are ensured through the facilitation of smart contracts. A wager can only be activated when the liquidity is sufficient for covering the bet. New token and cryptocurrency standards have convertibility built-in. A third-party exchange is not necessary for placing bets or collecting payouts from sports betting platforms. The features for sports betting can be accessed by the players using tailored and specific tokens. This unlocks functionally while enabling the player to place their bets. The expectations are sports betting will be legalized by a ruling anticipated from the Supreme Court. Anonymity Traditional sportsbooks must follow numerous different regulations in all of their dealings. This includes having every user provide several documents to create and verify their accounts. Not only is this process time consuming but it also placed limitations on the number of players. These issues can easily be resolved through the anonymity available with blockchain technology. This feature eliminates the need for users to provide personal information every time they make a transaction. This also helps prevent hackers from gaining access to the personal data of the users. An excellent example is one of the initial sites to use this technology. All the players needed to do to make a bet was to send Bitcoin to the address provided. This means the players did not have to take the time to create an account, visit a website or download any software. Despite the claims of certain sources that there is a link between cryptocurrency and prohibited activity, this technology has the ability to change the sportsbook betting industry. The bettors can simply use their tokens on the betting platform without revealing any information. This is the key to true anonymity. The players no longer have to wait for several days for their winnings to be processed and minimum withdrawal amounts are effectively eliminated. The winnings are received fast with no limitations. The irreversible nature of cryptocurrency transactions eliminates non-payment and fraud issues as well. Accessibility The prohibition of gambling is so many areas leads to suffering for gambling enthusiasts. Unfortunately, many of these enthusiasts turn to illegal bookmakers for their services. Illegal bookmakers are incredibly dangerous because there are times they do not pay the winners. The consequences can be deadly. Everything changes when digital currency can be used on a decentralized platform. Enthusiasts have access to easily trade digital currency all over the world. All that is required is a strong internet connection. The days of waiting for several days to collect a win would be over. Withdrawals become instant with no limitations. Transactions using cryptocurrency are the future of sportsbook betting. The industry would be able to offer memberships for all token holders. Sportsbooks would even be able to develop tokens of their own for use as currency on all different types of platforms. There are already leaders in the gambling industry accepting and creating their own tokens. All the user is required to do to become one of the shareholders of the platform is to purchase the tokens. The best part is the need to even consider placing a sporting bet with an illegal bookmaker is eliminated because bettors across the globe will have new access. International World MarketsAll of the combined technology will have a positive impact on the international world markets. Sports betting markets all over the world involve a maze of off-shore operators, local bookies and betting links run by the mob. The only place sportsbooks and their corresponding mobile apps are legal are in Las Vegas, Nevada. The problem is not every bettor lives in Las Vegas. Placing bets by contacting a sportsbook directly is a good opportunity but it is limited. The online operator’s located off-shore offer much better opportunities. New technology can circumnavigate the entire world. If the United States does not legalize sports betting, the solution is for the sports betting industry to take advantage of new technology. If sports betting is legalized in the United States, the betting range provided by online markets will still be unmatched. When the betting markets of the world are connected through new technology, players will have the ultimate opportunity for sports betting. The industry would require format integration and additional regulations but would also evolve. The evolution of the industry requires new technology. Players are already using the technology of smartphones for discrete gambling from anywhere. There are more participants in the industry due to this convenience. Current technology can update the betting ways of the past while offering even better opportunities. Growing IndustryThe fastest type of entertainment growth in the world are gaming and esports. These industries are consistently evolving. Cycles of new growth are expected for several decades. This is due to the innovators consistently bringing even more value into the industry. The same thing happened throughout history with traditional sports. Esports has already become an industry worth more than one billion. Additional growth is expected in the betting space within the next few years. Asia is not the key area for esports. There are enormous fan bases long established in North America, CIS, Europe and Asia as well. The fans actively invest in engaging, playing and watching esports. Cryptocurrency is providing credibility in the gambling industry by improving the overall experience of sports betting, esports and all different types of gambling. Technology can only become the future of the international markets if it is incorporated into the industry. This technology will be offered to consumers through the innovators. The advantages are profound. The next step in the evolution of this technology is making an investment in digital securities. The future of the industry is exciting and full of new advantages and opportunities due to the possibilities now available with technology.
Pavlov_dog;Bitcoin in a nutshell — Blockchain;Криптография *Python *Программирование *Биллинговые системы *;"Blockchain — это технология, на базе которой построен Bitcoin. И если пару лет назад вся слава доставлась криптовалюте, то сегодня все чаще можно слышать смелые фразы вроде: ""Forget Bitcoin, Long Live Blockchain"". Активно развиваются платформы вроде Ethereum, IPFS или Overstock, которые рассматривают блокчейн не как инструмент для создания еще одной платежной системы, а как совершенно обособленную технологию, сравнимую по своей инновационности разве что с Интернетом.
В этой главе я расскажу вам, что из себя представляет блокчейн Bitcoin. Даже по сравнению с Ethereum, это жуткий анахронизм, но понимание принципов его работы вам сильно поможет, если вы решите разобраться с более сложными проектами.";/ru/post/320176/;"Blockchain — это технология, на базе которой построен Bitcoin. И если пару лет назад вся слава доставлась криптовалюте, то сегодня все чаще можно слышать смелые фразы вроде: ""Forget Bitcoin, Long Live Blockchain"". Активно развиваются платформы вроде Ethereum, IPFS или Overstock, которые рассматривают блокчейн не как инструмент для создания еще одной платежной системы, а как совершенно обособленную технологию, сравнимую по своей инновационности разве что с Интернетом.В этой главе я расскажу вам, что из себя представляет блокчейн Bitcoin. Даже по сравнению с Ethereum, это жуткий анахронизм, но понимание принципов его работы вам сильно поможет, если вы решите разобраться с более сложными проектами.BookBitcoin in a nutshell — CryptographyBitcoin in a nutshell — TransactionBitcoin in a nutshell — ProtocolBitcoin in a nutshell — BlockchainBitcoin in a nutshell — MiningTable of contentBlockchain for dummiesStructureMerkle treeTimestampRaw blockLinksBlockchain for dummiesСам по себе блокчейн — это крайне простая штука. Его проще всего проиллюстрировать на примере книги бухгалтерского учета, в которую записываются все транзакции в сети Bitcoin. Более того, такая книга присутствует у каждого участника сети, а значит любой, при желании, может проверить, была та или иная транзакция в реальности или нет.И если блокчейн целиком — это книга, то отдельные блоки можно представлять как страницы, на которых ""записываются"" транзакции. Кажый блок ""ссылается"" на предыдущий и так до самого первого блока (genesis block). Именно это и создает такую интересную особенность блокчейна, как неизменяемость. Нельзя взять и изменить блок #123 так, чтобы этого никто не заметил. Потому что блокчейн устроен таким образом, что это повлечет изменение блока #124, потом #125 и так далее, до самого верха.StructureПривычным движением руки открываем спецификацию протокола и смотрим на структуру блока.version — версия блокаprev_block — хэш предыдущего блока (parent block)merkle_root — если упрощенно, то это хэш всех транзакций в блокеtimestamp — дата и время создания блокаbits, nonce — про эти параметры я подробно расскажу в главе Bitcoin in a nutshell — Miningtxn_count, txns — число транзакций в блоке и их списокПервые шесть параметров (все кроме txn_count и txns) образуют заголовок блока (header). Именно хэш заголовка называют хэшем блока, то есть сами транзакции непосредственного участия в хэшировании не принимают.Вместо этого они заносятся в особую структуру — дерево Меркла, про которую я расскажу ниже.Merkle treeTechnical sideДерево Меркла — это структура данных, также известная как бинарное дерево хэшей. В случае Bitcoin оно строится следующим образом:Сначала считаются хэши всех транзакций в блоке hash_A = SHA256(SHA256(A))Потом считаются хэши от суммы хэшей транзакций hash_AB = SHA256(SHA256(hash_A + hash_B))Точно также считаем хэши от суммы получившихся хэшей hash_ABCD = SHA256(SHA256(hash_AB + hash_CD)) и далее по рекурсии. Лирическое отступление — так как дерево бинарное, то на кажом шаге должно быть четное число элементов. Поэтому если, например, у нас только три транзакции, то последняя транзакция просто дублируется:Процесс продолжается до тех пор, пока не получится один единственный хэш — он и называется merkle_root (третье поле в header блока)Ниже приведена реализация дерева Меркла, можете проверить ее на каком-нибудь блоке.import hashlib# Hash pairs of items recursively until a single value is obtaineddef merkle(hashList):    if len(hashList) == 1:        return hashList[0]    newHashList = []    # Process pairs. For odd length, the last is skipped    for i in range(0, len(hashList)-1, 2):        newHashList.append(hash2(hashList[i], hashList[i+1]))    if len(hashList) % 2 == 1: # odd, hash last item twice        newHashList.append(hash2(hashList[-1], hashList[-1]))    return merkle(newHashList)def hash2(a, b):    # Reverse inputs before and after hashing    # due to big-endian / little-endian nonsense    a1 = a.decode('hex')[::-1]    b1 = b.decode('hex')[::-1]    h = hashlib.sha256(hashlib.sha256(a1 + b1).digest()).digest()    return h[::-1].encode('hex')ImmutabilityТеперь о том, зачем это нужно в Bitcoin. Я думаю, вы понимаете, что если изменить хотя бы одну транзакцию, то merkle_root также изменится. Поэтому такая структура данных позволяет обеспечить ""неподделываемость"" транзакций в блоке. То есть не может произойти следующей ситуации:Кто-то из майнеров нашел новый блок и начал раскидывать его по сети. В это время злоумышленник перехватывает блок и, например, удаляет из блока какую-нибудь транзакцию, после чего распостраняет уже измененный блок.Для проверки достаточно посчитать merkle_root самостоятельно и сравнить его с тем, что записан в header блока.SPVНо здесь можно резонно возразить, что, во-первых, такие сложности совершенно ни к чему. Достаточно просто посчитать хэш от суммы всех транзакций в блоке txns_hash = SHA256(SHA256(sum(txns))) — он точно также изменится после любых манипуляций с транзакциями. А, во-вторых, что мешает злоумышленнику подменить merkle_root в блоке? На второй вопрос отвечу сразу: на самом деле в блоке вообще нельзя ничего изменить, потому что блок тут же станет невалидным (это вы поймете после прочтения следующей главы Bitcoin in a nutshell — Mining).А дерево Меркла нужно на самом деле для того, чтобы иметь возможность создавать SPV nodes (Simplified Payment Verification). Такие ноды синхронизируют только заголовки блоков, без самих транзакций. В результате блокчейн занимает на порядок меньше места (для красоты возьмем высоту в 500.000 блоков, размер header фиксирован — 80 байт):500.000 * 80 / 1024 / 1024 ? 40 МбТакой блокчейн уже можно без проблем уместить на телефоне, планшете или каком-нибудь IoT. Что в перспективе должно дать большую децентрализацию, безопасность сети и так далее.Суть упрощенной верификации платежей в следующем: пусть у вас есть SPV нода. У меня же есть весь блокчейн целиком и мне нужно вас убедить, что какая-нибудь транзакция действительно была (на картинке это транзакция K). В этом случае, мне достаточно всего лишь предоставить вам несколько хэшей: H_L, H_IJ, H_MNOP, H_ABCDEFGH, они еще называются authentication path.После чего вы сначала считаете H_K = SHA256(SHA256(K)), потом H_KL = SHA256(SHA256(H_K + H_L)) и так до самого верха. Если в итоге вы находите у себя блок с таким же merkle_root, то факт существования транзакции считается подтвержденным.BTW Ральф Меркл даже запатентовал свою структуру данных, о чем свидетельствует патент US4309569 A.TimestampЕще один интересный вопрос. Представим, что где-то в сети появился появился новый блок и ноды начинают передавать его друг-другу. Каждая нода должна убедиться в том, что блок корректен. Для этого она:проверяет синтаксис и структуру блокапроверяет на валидность каждую транзакцию в блокехэширует транзакции и сравнивает merkle rootпроверяет несколько критериев, связанных с майнингом, и так далееНо как можно проверить timestamp? Понятно, что время на разных компьютерах может различаться, так что даже если у нового блока timestamp отличается от вашего текущего времени на час вперед, это еще не значит, что блок ""неправильный"", может у майнера просто часы спешат.Поэтому для проверки timestamp на валидность было придумано два критерия. Во-первых, он должен быть больше, чем среднее арифметическое timestamp-ов предыдущих 11 блоков. Это делается для того, чтобы не получилось так, что блок #123 вышел 12 марта 2011 года, а #124 — 13 февраля 1984. Но в тоже время допускается некоторая погрешность.Во-вторых, timestamp должен быть меньше чем network adjusted time. То есть нода, при получении нового блока, интересуется текущим временем у своих ""соседей"" по сети, считает среднее арифметическое и если block timestamp меньше получившегося значения + 2 часа, то все в порядке.BTW как вы видите, timestamp нового блока может оказаться даже меньше, чем timestamp более раннего блока. Это не такая уж и редкость, например #145045, #145046 и #145047.145044: 2011-09-12 15:46:39     145045: 2011-09-12 16:05:07 145046: 2011-09-12 16:00:05 // ~5 minutes before prior block145047: 2011-09-12 15:53:36 // ~7 & ~12 minutes before 2 prior blocks145048: 2011-09-12 16:04:06 // after 2 prior blocks but still before 145045Raw blockЕсли у вас до сих остались какие-то вопросы по структуре блока, то предлагаю вам посмотреть на них в ""сыром"" виде. Самый очевидный способ это сделать — запустить на пару часов bitcoind --daemon, а потом исследовать уже скачанные блоки. Но, во-первых, не у всех есть время / желание синхронизировать блокчейн. Во-вторых, в Bitcoin блоки хранятся в крайне специфической базе данных LevelDB, еще и довольно странным образом. А так как книга расчитана не только на опытных разработчиков, то я пойду уже проверенным путем и снова использую протокол в его первозданном виде.Для получения блока отправим сообщение getdata, в котором укажем type : MSG_BLOCK и hash : 000000000003ba27aa200b1cecaad478d2b00432346c3f1f3986da1afd33e506 — это хэш блока #100.000. Весь код целиком можете посмотреть здесь.def getdataMessage():    block_hash = '000000000003ba27aa200b1cecaad478d2b00432346c3f1f3986da1afd33e506'    count = struct.pack(""<B"", 1)    inventory = struct.pack(""<L"", 2) # type : MSG_BLOCK    inventory += block_hash.decode('hex')[::-1]    return count + inventoryLinksMastering Bitcoin — The BlockchainDocumentation of the physical Bitcoin blockchainWhat are the keys used in the blockchain levelDBbitcoin-core/leveldb/doc/table_format.txtДеревья Меркла в Эфириуме"
Ragnar_by;Blockchain на Go. Часть 2: Proof-of-Work;Go *;"Привет, Хабр! Представляю вашему вниманию перевод статьи ""Building Blockchain in Go. Part 2: Proof-of-Work"".

Содержание

 Blockchain на Go. Часть 1: Прототип 
Blockchain на Go. Часть 2: Proof-of-Work
 Blockchain на Go. Часть 3: Постоянная память и интерфейс командной строки
Blockchain на Go. Часть 4: Транзакции, часть 1
Blockchain на Go. Часть 5: Адреса 
Blockchain на Go. Часть 6: Транзакции, часть 2
Blockchain на Go. Часть 7: Сеть


Вступление 
 В предыдущей статье мы построили очень простую структуру данных, которая является основой для базы данных блокчейна. Также мы сделали добавление в нее блоков с цепной связью между ними: каждый блок связан с предыдущим. Увы, наша реализация блокчейна имеет один существенный недостаток: добавление блоков в цепочку слишком простое и дешевое. 

Одним из краеугольных камней Биткоина и блокчейна является то, что добавление новых блоков должно быть достаточно сложной работой. И сейчас мы собираемся исправить этот недостаток.";/ru/post/350804/;"Привет, Хабр! Представляю вашему вниманию перевод статьи ""Building Blockchain in Go. Part 2: Proof-of-Work"".Содержание Blockchain на Go. Часть 1: Прототип Blockchain на Go. Часть 2: Proof-of-Work Blockchain на Go. Часть 3: Постоянная память и интерфейс командной строкиBlockchain на Go. Часть 4: Транзакции, часть 1Blockchain на Go. Часть 5: Адреса Blockchain на Go. Часть 6: Транзакции, часть 2Blockchain на Go. Часть 7: СетьВступление  В предыдущей статье мы построили очень простую структуру данных, которая является основой для базы данных блокчейна. Также мы сделали добавление в нее блоков с цепной связью между ними: каждый блок связан с предыдущим. Увы, наша реализация блокчейна имеет один существенный недостаток: добавление блоков в цепочку слишком простое и дешевое. Одним из краеугольных камней Биткоина и блокчейна является то, что добавление новых блоков должно быть достаточно сложной работой. И сейчас мы собираемся исправить этот недостаток.Proof-of-Work(PoW) Ключевая идея блокчейна заключается в том, что для добавления нового блока необходимо проделать некоторую сложную работу. Именно эта сложная работа делает блокчейн надежным и целостным. Кроме того, за эту сложную работу выплачивается вознаграждение (вот так люди получают монеты за майнинг). Этот механизм похож на реальную жизнь: надо упорно работать, чтобы получать вознаграждения и обеспечивать себе жизнь. В блокчейне некоторые участники (майнеры) сети работают над поддержанием сети, добавлением в блокчейн новых блоков и получают вознаграждение за свою работу. В результате их работы блок встраивается в блокчейн надежным способом, что обеспечивает стабильность всей базы данных блокчейна. Стоит отметить, что тот, кто выполнил работу, должен также доказать её выполнение.Этот весь «сделай сложную работу и докажи её»-механизм называется Proof-of-Work (доказательство работы). Он сложен, потому что требует больших вычислительных мощностей: даже высокопроизводительные компьютеры не могут его быстро выполнить. Более того, сложность данной работы постепенно возрастает, для того чтобы в среднем создавалось около 6 блоков в час. В Биткоине цель такой работы — это нахождение хеша блока, который удовлетворяет определенным требованиям. Данный хеш и служит доказательством. Таким образом, поиск доказательства и есть фактическая работа.Необходимо заметить одну вещь: Proof-of-Work алгоритмы должны соответствовать следующему требованию: выполнение работы должно быть сложным, но проверка доказательства должна быть простой. Проверка доказательства обычно передается кому-то стороннему, поэтому у них данная проверка не должна занимать много времени.Хеширование Данная часть посвящена хешированию. Те, кто знаком с этой концепцией, может данную часть пропустить. Хеширование — это процесс получения хеша для некоторых данных. Хеш — это уникальное представление для данных, для которых он был высчитан. Хеш-функция — это функция, которая для данных произвольного размера получает хеш конкретного размера. Некоторые ключевые особенности хеширования: Начальные данные не могут быть восстановлены из хеша. Таким образом, хеширование — это не шифрование Хеш для конкретных данных всегда однозначен и уникален Изменение одного байта в данных приводит к получению совершенно другого хеша Функции хеширования широко применяются для проверки целостности данных. Многие поставщики софта публикуют вместе с софтом его контрольные суммы. После скачивания файла, его надо скормить хеш-функции, а затем сравнить полученный хеш с тем, что опубликовал разработчик софта.В блокчейне хеш используется, чтобы гарантировать целостность блока. Входные данные для хеширующего алгоритма содержат хеш предыдущего блока, что делает невозможным (или, по крайней мере, очень сложным) изменение блока в цепи: придется пересчитывать хеш самого блока, а также хеши всех следующих за ним блоков.HashcashБиткоин использует Hashcash, Proof-of-Work алгоритм, который был разработан для защиты от почтового спама. Алгоритм может быть разделен на следующие шаги: Взять публично известные данные ( для эмейла — это адрес получателя; для биткоина — это заголовок блока Добавить к ним счетчик. Счетчик начинается с нуля Получить хеш от комбинации данные+счетчик Проверить, отвечает ли хеш определенным требованиям Если да, то все готово Если нет, то увеличить счетчик и повторить шаги 3 и 4 Таким образом, это брутфорс алгоритм: изменить счетчик, вычислить хеш, проверить его, увеличить счетчик, снова вычислить хеш и так далее. Именно поэтому алгоритм вычислительно затратный.Теперь рассмотрим требования, которым должен удовлетворять хеш. В оригинальной Hashcash реализации требование звучит как «первые 20 бит хеша должны быть нулевыми». В Биткоине требование время от времени корректируется, потому что по замыслу блок должен генерироваться каждые 10 минут, несмотря на то, что мощность вычислений растет со временем и все больше и больше майнеров присоединяются к сети.Для демонстрации алгоритма, возьмем предыдущий пример («I like donuts») и найдем хеш, который начинается с трех нулевых байтов.ca07ca — это шестнадцатеричное представления счетчика, что соответствует числу 13240266 в десятичной системе счисления. Реализация Итак, с теорией покончено, приступим к коду. Для начала определим сложность майнинга:const targetBits = 24В Биткоине, «target bits» — это поле заголовка блока, которое хранит сложность, на которой блок был добыт. Мы не будем строить корректирующийся алгоритм, поэтому определим сложность, как глобальную константу.24 — это произвольное число, наша цель — это иметь сложность, которая занимает менее 256 бит в памяти. И мы хотим, чтобы разница была достаточно значительной, но не слишком большой, потому что, чем больше разница, тем труднее найти правильный хеш.type ProofOfWork struct {	block  *Block	target *big.Int}func NewProofOfWork(b *Block) *ProofOfWork {	target := big.NewInt(1)	target.Lsh(target, uint(256-targetBits))	pow := &ProofOfWork{b, target}	return pow}Здесь мы создаем создаем ProofOfWork, которая содержит указатель на указатель на блок и указатель на цель. «Цель» — это другое имя для требований, описанных в предыдущей части. Мы используем big integer из-за способа сравнения хеша с целью: мы ковертируем хеш в big integer и проверить, меньше ли оно, чем цель.В функции NewProofOfWork мы проинициализируем big.Int значением 1, а потом сдвинуть на  256-targetBits  битов.  256  — это длина SHA-256 хеша в битах, и данный алгоритм хеширования мы будем использовать. 16-ричное представление target: 0x10000000000000000000000000000000000000000000000000000000000И оно занимает 29 байтов в памяти. А здесь визуальное сравнение с хешами из предыдущих примеров:0fac49161af82ed938add1d8725835cc123a1a87b1b196488360e58d4bfb51e300000100000000000000000000000000000000000000000000000000000000000000008b0f41ec78bab747864db66bcb9fb89920ee75f43fdaaeb5544f7f76caПервый хеш( подсчитан для «I like donuts») больше, чем цель, так что это неверное доказательство работы. Второй хеш ( подсчитан для «I like donutsca07ca») меньше цели, так что это верное доказательство.Можно считать цель как верхнюю границу диапазона: если число ( хеш) меньше, чем граница, то оно подходит, и наоборот. Понижение границы приведет к уменьшению количества подходящих чисел, тем самым повышая сложность поиска подходящего.Теперь нам нужны данные для хеширования. Давайте подготовим их:func (pow *ProofOfWork) prepareData(nonce int) []byte {	data := bytes.Join(		[][]byte{			pow.block.PrevBlockHash,			pow.block.Data,			IntToHex(pow.block.Timestamp),			IntToHex(int64(targetBits)),			IntToHex(int64(nonce)),		},		[]byte{},	)	return data} Этот кусок кода достаточно простой. Мы просто объединяем поля блока с целью и «nonce». nonce — это счетчик из описания Hashcash, это такой криптографический термин. Так, все приготовления выполнены. Теперь реализуем ядро Proof-of-Work алгоритма:func (pow *ProofOfWork) Run() (int, []byte) {	var hashInt big.Int	var hash [32]byte	nonce := 0	fmt.Printf(""Mining the block containing \""%s\""\n"", pow.block.Data)	for nonce < maxNonce {		data := pow.prepareData(nonce)		hash = sha256.Sum256(data)		fmt.Printf(""\r%x"", hash)		hashInt.SetBytes(hash[:])		if hashInt.Cmp(pow.target) == -1 {			break		} else {			nonce++		}	}	fmt.Print(""\n\n"")	return nonce, hash[:]}Сначала мы инициализируем переменные. hashInt — это целочисленное представление для hash. nonce — это счетчик. Затем мы запускаем «бесконечный» цикл: он ограничен константой maxNonce, значение которой равно math.MaxInt64. Это сделано, чтобы избежать возможное переполнение nonce. Хотя сложность нашей PoW реализации слишком мала для переполнения счетчика, на всякий случай лучше иметь такую проверку.В цикле мы делаем следующее:Подготовить данные  Захешировать их Hash256 Конвертировать хеш в big integer Сравнить полученное целое число с цельюТак же легко, как было объяснено ранее. Теперь можно удалить метод SetHash у Block и изменить функцию NewBlock:func NewBlock(data string, prevBlockHash []byte) *Block {	block := &Block{time.Now().Unix(), []byte(data), prevBlockHash, []byte{}, 0}	pow := NewProofOfWork(block)	nonce, hash := pow.Run()	block.Hash = hash[:]	block.Nonce = nonce	return block}Можно заметить, что nonce сохранен как свойство  Block . Это необходимо, потому что nonce требуется для проверки доказательства. Структура  Block  теперь выглядит так:type Block struct {	Timestamp     int64	Data          []byte	PrevBlockHash []byte	Hash          []byte	Nonce         int}А теперь запустим нашу программу и проверим, что все хорошо работает:Mining the block containing ""Genesis Block""00000041662c5fc2883535dc19ba8a33ac993b535da9899e593ff98e1eda56a1Mining the block containing ""Send 1 BTC to Ivan""00000077a856e697c69833d9effb6bdad54c730a98d674f73c0b30020cc82804Mining the block containing ""Send 2 more BTC to Ivan""000000b33185e927c9a989cc7d5aaaed739c56dad9fd9361dea558b9bfaf5fbePrev. hash:Data: Genesis BlockHash: 00000041662c5fc2883535dc19ba8a33ac993b535da9899e593ff98e1eda56a1Prev. hash: 00000041662c5fc2883535dc19ba8a33ac993b535da9899e593ff98e1eda56a1Data: Send 1 BTC to IvanHash: 00000077a856e697c69833d9effb6bdad54c730a98d674f73c0b30020cc82804Prev. hash: 00000077a856e697c69833d9effb6bdad54c730a98d674f73c0b30020cc82804Data: Send 2 more BTC to IvanHash: 000000b33185e927c9a989cc7d5aaaed739c56dad9fd9361dea558b9bfaf5fbeУра! Теперь можно заметить, что каждый хеш начинается с трех нулевых байтов и поиск хешей занимает некоторое время.Осталось еще кое-что сделать: давайте сделаем возможной проверку доказательств работы:func (pow *ProofOfWork) Validate() bool {	var hashInt big.Int	data := pow.prepareData(pow.block.Nonce)	hash := sha256.Sum256(data)	hashInt.SetBytes(hash[:])	isValid := hashInt.Cmp(pow.target) == -1	return isValid}Именно здесь нам понадобится сохраненная nonce.Проверим, что все в порядке:func main() {	...	for _, block := range bc.blocks {		...		pow := NewProofOfWork(block)		fmt.Printf(""PoW: %s\n"", strconv.FormatBool(pow.Validate()))		fmt.Println()	}}Output:...Prev. hash:Data: Genesis BlockHash: 00000093253acb814afb942e652a84a8f245069a67b5eaa709df8ac612075038PoW: truePrev. hash: 00000093253acb814afb942e652a84a8f245069a67b5eaa709df8ac612075038Data: Send 1 BTC to IvanHash: 0000003eeb3743ee42020e4a15262fd110a72823d804ce8e49643b5fd9d1062bPoW: truePrev. hash: 0000003eeb3743ee42020e4a15262fd110a72823d804ce8e49643b5fd9d1062bData: Send 2 more BTC to IvanHash: 000000e42afddf57a3daa11b43b2e0923f23e894f96d1f24bfd9b8d2d494c57aPoW: trueЗаключениеНаш блокчейн еще на шаг ближе к актуальной архитектуре: добавление блоков требует вычислительной работы, поэтому возможен майнинг. Но в нем по-прежнему отсутствуют некоторые важные функции: база данных блокчейна не является постоянной, нет кошельков, адресов, транзакций и нет механизма консесуса. Все эти вещи мы рассмотрим вследующих статьях.СсылкиПервая частьОригинальная статьяИсходные коды для статьиАлгоритм хеширования блокчейнаProof of WorkHashcash"
finr1r;Quorum blockchain: интеграция в Java код;Программирование *Java *;"Здраствуй, Хабр!
Для тех кто интересуется темой блокчейна давно не секрет, что помимо публичных блокчейнов, таких как Ethereum, Bitcoin, Zcash и т.д., существуют также их ""enterprise (private)"" ""братья"", которые в кое чем лучше чем публичные сети, а в кое чем проигрывают им. Среди найболее известных сетей, я думаю, можно назвать Quorum (вендор — J.P. Morgan Chase), Pantheon (вендор — PegaSys) и Hyperledger (находиться под управлением The Linux Foundation). Несмотря на то, что существует довольно много публичных решений, бизнес все более интересуеться именно приватными блокчейнами благодаря тому, что они способны обеспечить нужный уровень приватности, транзакции выполняються быстрее и так далее.";/ru/post/462549/;"Здраствуй, Хабр!Для тех кто интересуется темой блокчейна давно не секрет, что помимо публичных блокчейнов, таких как Ethereum, Bitcoin, Zcash и т.д., существуют также их ""enterprise (private)"" ""братья"", которые в кое чем лучше чем публичные сети, а в кое чем проигрывают им. Среди найболее известных сетей, я думаю, можно назвать Quorum (вендор — J.P. Morgan Chase), Pantheon (вендор — PegaSys) и Hyperledger (находиться под управлением The Linux Foundation). Несмотря на то, что существует довольно много публичных решений, бизнес все более интересуеться именно приватными блокчейнами благодаря тому, что они способны обеспечить нужный уровень приватности, транзакции выполняються быстрее и так далее. Отличия приватных от публичных блокчейнов, а также их преимущества и недостатки — не тема даной статьи. Если вам интересно прочитать об этом то есть, например, такая статья на Medium.В этой статье я хотел бы расказать вам как можно испольовать Quorum блокчейн для разработки своих приложений с поддержкой приватных и публичных транзакций. Для демонстрации возможностей мы напишем небольшое Java/Spring приложение, которое будет принимать запросы на загрузку (deploy) смарт-контрактов, выполнение транзакций и чтения данных из смарт-контракта. Собственно, вот стек технологий который будет использоваться в статье:Java 8Gradle 5.2.1Spring FrameworkWeb3j (библиотека для работы с публичными транзакциями в Ethereum подобных сетях)Web3j-quorum (библиотека для работы с приватными транзакциями в Quorum сети)Немного общей информации о QuorumQuorum — проект с окрытым исходным кодом на GitHub, целью которого является предоставление блокчейна который давал бы возможность выполнять транзакции не только публично но и в приватном режиме тоже. С технической точки зрения Quorum это модернизирований Ethereum, у него есть также и свой модифицированый Geth-клиент чтобы иметь возможность делать приватные транзакции.Важным дополнением также является enclave сервисы, которые отвечают за хранение, шифрование и распространение приватных транзакций между собой. Сейчас существуют 2 таких enclave сервиса:Constellation — написан на Haskell, первый вариант enclave, однако сейчас уже не развиваеться, и скорее всего в будущем от него откажуться в пользу нового;Tessera — новый сервис, написан на Java, поддерживаеться разработчиками из J.P. Morgan Chase, имеет больше возможностей по интеграции с БД и управлением ""чуствительной"" информацией (например, есть вариант итеграции с HashiCorp Vault для управления секретами).Что касаеться транзакций, то с точки зрения интерфейса обычной Ethereum поменялось не многое (и это хорошо). Для того что бы отправить приватную транзакцию, помимо обычной информации о транзакции, нужно ещё указать параметр  privateFor — это масив строк, а строки эти — публичные ключи enclave нод. С помощью этих ключей шифруеться payload транзакции и выполняеться распространение payoad'a между Tessera-нодами внутри блокчейна.Для более глубокого ознакомления с Quorum, о том как он работает, и как поднять блокчейн сеть вы можете найти на официальном сайте (ссылку на документацию, а также ссылку на туториал как запустить тестовый блокчейн я оставлю вконце статьи).Разработка Java приложенияКак пример, я покажу небольшой RESTful API, написаный на Java/Spring, с Gradle в качестве инструмента сборки и управления зависимостями, который будет загружать смарт-контракт в блокчейн, выполнять функцию изменения состояния контракта и считывать состояние из смарт-контракта.Перед тем, как начать непосредствено разработку, я должен кое что прояснить. Несмотря на то, что в Quorum официально есть 2 варианта транзакций, я предпочитаю делить их на 3 вида:Public транзакции — транзакции полностью видны всем учасникам сети (в том числе и payload), enclave-нода не принимает участвие ни в оброботке, ни в хранении транзакции. Публичные транзакции в Quorum не отличаються от транзакций в Ethereum сети;Permissioned транзакции — транзакции по сути являються приватными, но для нескольких учасников сети, то есть в публичной сети мы имеем информацию о транзакции и о статусе ее выполнения, но вместо реального payload в публичной сети мы имеет лишь 64-битную строку-хеш, которая являеться идентификатором на реальный payload в enclave ноде, сама enclave нода отвествена за подпись, шифрование, хранение и распространение payload'a между указаными учасниками транзакции;Private транзакции — отличаються от permissioned тем что транзакция доступна только для ноды, которая эту транзакцию создала, другие учасники сети не могут увидеть payload транзакции.Этой класификацией я буду пользоваться на протяжении всей статьи.Для начала я покажу, как будет выглядеть файл сборки — gradle.build:plugins {    id 'org.springframework.boot' version '2.1.6.RELEASE'    id 'java'}apply plugin: 'io.spring.dependency-management'group = 'com.github'version = '1.0'sourceCompatibility = '1.8'configurations {    compileOnly {        extendsFrom annotationProcessor    }}repositories {    mavenCentral()}test {    testLogging.showStandardStreams = true}dependencies {    implementation 'org.springframework.boot:spring-boot-starter-webflux'    implementation group: 'org.web3j', name: 'quorum', version: '4.0.6'    implementation group: 'org.web3j', name: 'core', version: '4.1.0'    implementation group: 'org.web3j', name: 'codegen', version: '4.1.0'    compileOnly 'org.projectlombok:lombok'    annotationProcessor 'org.projectlombok:lombok'    annotationProcessor 'org.springframework.boot:spring-boot-configuration-processor'    testImplementation 'org.springframework.boot:spring-boot-starter-test'    testImplementation 'io.projectreactor:reactor-test'}task generateWrappers(type: JavaExec) {    group 'Demo'    description 'Generates wrappers for smart-contracts'    classpath = sourceSets.main.runtimeClasspath    main = 'com.github.quorum.utils.WrappersGenerator'}Немного обьяснений:org.web3j.core — зависимость для работы с транзакциями в сети Ethereum и публичными транзакциями в сети Quorumorg.web3j.quorum — зависимость для работы с приватными транзакциями в сети Quorumorg.web3j.codegen — зависимость для генерации wrapper'ов для Solidity смарт-контрактовgenerateWrappers — Gradle-task для генерации Java-wrapper'ов из Solidity смарт котрактовДалее я покажу вам код смарт-контракта, который будет использоваться в этой статье: файл QuorumDemo.sol:pragma solidity 0.5.0;/** * @dev Smart-Contract for demonstration purposes. */contract QuorumDemo {    string public user;    /**     * @dev Rewrite user name in storage.     */    function writeUser(string calldata _user) public {        user = _user;    }}Контракт намерено сделан простым, но его достаточно для целей нашей статьи. Если вы знаете Solidity, то вы можете пропустить объяснения:string public user — публичная переменая типа string и названием user. В отличии от Java, Solidity автоматически генерирует getter для публичных переменных, поэтому реализововать вручную его не нужно.function writeUser(...) — функция смены значения переменой, по сути — setter.Для того, что бы из смарт-контракта создать Java-wrapper, нужно положить файл в папку src/main/solidity/contracts с любым названием, например QuorumDemo.sol.Далее нужно запустить Gradle-task generateWrappers командой:gradle generateWrappersпосле выполнения этой задачи по адресу src/main/java/com/github/quorum/component/wrappers будет создан Java-wrapper, с которым уже можно работать в Java коде.Для того, чтобы бекенд имел возможность подписывать транзакции, нам нужно иметь возможность получить payload транзакции до того, как мы пошлём ее. Для этого было бы хорошо получить его прямо из Java-wrapper класса. Здесь я создал 2 метода внутри врапера. Первый метод просто возращает ABI контракта, который можно использовать для загрузки нового смарт-контракта. Второй метод — это формирование транзакции на изменение состояния смарт-контракта. Вот код этих методов:public static String getBinary() {    return BINARY;}public static String getDataOnWriteUser(final String user) {    final Function function = new Function(            FUNC_WRITEUSER,            Arrays.asList(new Utf8String(user)),            Collections.emptyList()    );    return FunctionEncoder.encode(function);}Вставив их в сгенерированый Java-wrapper, вы сможете получать payload для транзакций.Далее, нам нужен удобный способ отправки транзакций в блокчейн, желательно с одинаковым интерфейсом для приватных и публичных транзакцй. Поэтому я создал интерфейс менеджера транзакций и 2 его реализации: TesseraTransactionManager, для отправки приватных транзакцийGethTransactionManager, для отправки публичных транзакцийДавайте разберём их. Код TesseraTransactionManager:@Slf4jpublic class TesseraTransactionManager implements TransactionManager {    private static final byte ATTEMPTS = 20;    private static final int SLEEP_DURATION = 100;    private final Quorum quorum;    private final String fromAddress;    private final QuorumTransactionManager quorumTxManager;    private final TransactionReceiptProcessor txReceiptProcessor;    public TesseraTransactionManager(            Quorum quorum,            Credentials credentials,            String publicKey,            List privateFor,            Tessera tessera    ) {        this.quorum = quorum;        this.fromAddress = credentials.getAddress();        this.quorumTxManager = new QuorumTransactionManager(quorum, credentials, publicKey, privateFor, tessera);        this.txReceiptProcessor = new PollingTransactionReceiptProcessor(quorum, SLEEP_DURATION, ATTEMPTS);    }    @Override    public TransactionReceipt executeTransaction(            final BigInteger gasPrice, final BigInteger gasLimit, final String to, final String data) {        while (true) {            try {                final EthSendTransaction ethSendTx = sendTransaction(gasPrice, gasLimit, to, data);                if (ethSendTx.hasError() && NONCE_TOO_LOW_ERROR_MESSAGE.equals(ethSendTx.getError().getMessage())) {                    log.warn(""[BLOCKCHAIN] try to re-send transaction cause error {}"", ethSendTx.getError().getMessage());                    continue;                }                return processResponse(ethSendTx);            } catch (TransactionException ex) {                log.error(""[BLOCKCHAIN] exception while receiving TransactionReceipt from Quorum node"", ex);                throw new RuntimeException(ex);            } catch (Exception ex) {                log.error(""[BLOCKCHAIN] exception while sending transaction to Quorum node"", ex);                throw new RuntimeException(ex);            }        }    }    private EthSendTransaction sendTransaction(            final BigInteger gasPrice, final BigInteger gasLimit, final String to, final String data) throws IOException {        final BigInteger nonce = getNonce();        final RawTransaction rawTransaction = RawTransaction.createTransaction(nonce, gasPrice, gasLimit, to, data);        return this.quorumTxManager.signAndSend(rawTransaction);    }    private TransactionReceipt processResponse(final EthSendTransaction transactionResponse)            throws IOException, TransactionException {        if (transactionResponse.hasError()) {            throw new RuntimeException(                    ""[BLOCKCHAIN] error processing transaction request: ""                    + transactionResponse.getError().getMessage()            );        }        final String transactionHash = transactionResponse.getTransactionHash();        return this.txReceiptProcessor.waitForTransactionReceipt(transactionHash);    }    private BigInteger getNonce() throws IOException {        final EthGetTransactionCount ethGetTxCount = this.quorum.ethGetTransactionCount(                this.fromAddress, DefaultBlockParameterName.PENDING).send();        return ethGetTxCount.getTransactionCount();    }}TransactionReceipt executeTransaction(...) — реализация интерфейса, метод для выполнения транзакции в сети и обработки ошибок, если они случаються. Возращает обьект c результатом выполнения транзакции;EthSendTransaction sendTransaction(...) — метод для подписи и отправки транзакций в блокчейн. Возращает обект с статусом транзакции и его хешом;TransactionReceipt processResponse(...) — метод, который ожидает выполнения транзакции и возращает TransactionReceipt после ее выполнения;BigInteger getNonce() — возращает ""nonce"" из сети.И код GethTransactionManager:@Slf4jpublic class GethTransactionManager extends FastRawTransactionManager implements TransactionManager {    private static final byte ATTEMPTS = 20;    private static final int SLEEP_DURATION = 100;    private final TransactionReceiptProcessor txReceiptProcessor;    public GethTransactionManager(Web3j web3j, Credentials credentials) {        this(web3j, credentials, new PollingTransactionReceiptProcessor(web3j, SLEEP_DURATION, ATTEMPTS));    }    public GethTransactionManager(Web3j web3j, Credentials credentials, TransactionReceiptProcessor txReceiptProcessor) {        super(web3j, credentials, txReceiptProcessor);        this.txReceiptProcessor = txReceiptProcessor;    }    @Override    public TransactionReceipt executeTransaction(            final BigInteger gasPrice, final BigInteger gasLimit, final String to, final String data) {        while (true) {            try {                final EthSendTransaction ethSendTx = sendTransaction(gasPrice, gasLimit, to, data, BigInteger.ZERO);                if (ethSendTx != null && ethSendTx.hasError() && NONCE_TOO_LOW_ERROR_MESSAGE.equals(ethSendTx.getError().getMessage())) {                    log.warn(""[BLOCKCHAIN] try to re-send transaction cause error: {}"", ethSendTx.getError().getMessage());                    continue;                }                return this.txReceiptProcessor.waitForTransactionReceipt(ethSendTx.getTransactionHash());            } catch (TransactionException ex) {                log.error(""[BLOCKCHAIN] exception while receiving TransactionReceipt from Quorum node"", ex);                throw new RuntimeException(ex);            } catch (IOException ex) {                log.error(""[BLOCKCHAIN] exception while sending transaction to Quorum node"", ex);                throw new RuntimeException(ex);            }        }    }    @Override    public EthSendTransaction sendTransaction(            final BigInteger gasPrice,            final BigInteger gasLimit,            final String to,            final String data,            final BigInteger value    ) throws IOException {        return super.sendTransaction(gasPrice, gasLimit.add(BigInteger.valueOf(21_000L)), to, data, value);    }}TransactionReceipt executeTransaction(...) — реализация интерфейса, метод для выполнения транзакции в сети и обработки ошибок, если они случаються. Возращает обьект c результатом выполнения транзакции;EthSendTransaction sendTransaction(...) — метод, который вызывает метод супер-класа для отправки транзакции в блокчейн.Обработчик запросов, которые приходять на API:@Slf4j@Componentpublic class RequestHandler {    private final Web3j web3j;    private final Quorum quorum;    private final Tessera tessera;    private final Credentials credentials;    private final BlockchainConfig blockchainConfig;    private String deployedContract;    @Autowired    public RequestHandler(            @Qualifier(""initWeb3j"") Web3j web3j,            Quorum quorum,            Tessera tessera,            Credentials credentials,            BlockchainConfig blockchainConfig    ) {        this.web3j = web3j;        this.quorum = quorum;        this.tessera = tessera;        this.credentials = credentials;        this.blockchainConfig = blockchainConfig;    }    /**     * Deploy new smart-contract.     *     * @param serverRequest     *          - {@link ServerRequest} object with request information     * @return {@link ServerResponse} object with response data     */    public Mono deployContract(final ServerRequest serverRequest) {        return serverRequest                .bodyToMono(APIRequest.class)                .map(this::getTransactionManager)                .map(this::deployContract)                .flatMap(this::generateResponse);    }    private TransactionManager getTransactionManager(final APIRequest apiRequest) {        log.info(""[HANDLER] privateFor = {}"", apiRequest.getPrivateFor());        TransactionManager txManager;        if (isPrivate(apiRequest.getPrivateFor())) {            if (apiRequest.getPrivateFor().size() == 0) {                apiRequest.getPrivateFor().add(this.blockchainConfig.getTesseraPublicKey());            }            txManager = new TesseraTransactionManager(this.quorum, this.credentials, this.blockchainConfig.getTesseraPublicKey(), apiRequest.getPrivateFor(), this.tessera);        } else {            txManager = new GethTransactionManager(this.web3j, this.credentials);        }        return txManager;    }    private boolean isPrivate(final List limitedTo) {        return limitedTo == null || limitedTo.size() == 0 || !limitedTo.get(0).equals(""public"");    }    private APIResponse deployContract(final TransactionManager txManager) {        log.info(""[HANDLER] deploying new smart-contract"");        final String data = QuorumDemo.getBinary();        final TransactionReceipt txReceipt = txManager.executeTransaction(GAS_PRICE, DEPLOY_GAS_LIMIT, null, data);        final APIResponse apiResponse = APIResponse.newInstance(txReceipt);        this.deployedContract = txReceipt.getContractAddress();        log.info(""[HANDLER] contract has been successfully deployed. Result: {}"", apiResponse.getMap());        return apiResponse;    }    private Mono generateResponse(final APIResponse apiResponse) {        return ServerResponse                .ok()                .body(Mono.just(apiResponse.getMap()), Map.class);    }    /**     * Send transaction on update user in smart-contract.     *     * @param serverRequest     *          - {@link ServerRequest} object with request information     * @return {@link ServerResponse} object with response data     */    public Mono updateUser(final ServerRequest serverRequest) {        return serverRequest                .bodyToMono(APIRequest.class)                .map(this::sendTransaction)                .flatMap(this::generateResponse);    }    private APIResponse sendTransaction(final APIRequest apiRequest) {        final TransactionManager txManager = getTransactionManager(apiRequest);        log.info(""[HANDLER] sending new transaction"");        final String data = QuorumDemo.getDataOnWriteUser(apiRequest.getUser());        final TransactionReceipt txReceipt = txManager.executeTransaction(GAS_PRICE, TX_GAS_LIMIT, this.deployedContract, data);        final APIResponse apiResponse = APIResponse.newInstance(txReceipt);        log.info(""[HANDLER] transaction has been successfully executed. Result: {}"", apiResponse.getMap());        return apiResponse;    }    /**     * Read user from smart-contract.     *     * @param serverRequest     *          - {@link ServerRequest} object with request information     * @return {@link ServerResponse} object with response data     */    public Mono getUser(final ServerRequest serverRequest) {        final APIResponse apiResponse = getUser();        return generateResponse(apiResponse);    }    private APIResponse getUser() {        log.info(""[HANDLER] reading user from smart-contract"");        final QuorumDemo quorumDemo = QuorumDemo.load(this.deployedContract, this.web3j, this.credentials, new StaticGasProvider(GAS_PRICE, DEPLOY_GAS_LIMIT));        final String user = readUserFromSmartContract(quorumDemo);        final APIResponse apiResponse = APIResponse.newInstance(user);        log.info(""[HANDLER] user: '{}'"", user);        return apiResponse;    }    private String readUserFromSmartContract(final QuorumDemo quorumDemo) {        try {            return quorumDemo.user().send().getValue();        } catch (Exception ex) {            log.info(""[HANDLER] exception while reading user from smart-contract: {}"", ex);            return null;        }    }}Сейчас обьясню какие методы за что отвечают.Метод Mono deployContract(...) — описывает общую логику загрузки (deploy) смарт-контракта, как публичного так и приватного.Метод TransactionManager getTransactionManager(...) — возращает обьект реализации менеджера транзакций в зависимости от типа транзакций. Для этого в теле запроса будет находиться параметр privateFor, который являеться масивом строк публичный ключей Tessera нод.Метод boolean isPrivate(...) — возращает ""true"", если параметр privateFor или пустой (private транзакция), или имеет список публичных ключей (permissioned транзакция). Возращает ""false"", если параметр privateFor не пустой, и первый елемент масива равен ""public"".Метод APIResponse deployContract(...) — посылает транзакцию загрузки(deploy) в блокчейн.Метод Mono generateResponse(...) — генерирует обьект с ответом к клиенту.Метод Mono updateUser(...) — описывает общую логику выполнения транзакции на изменение состояния смарт-контракта.Метод APIResponse sendTransaction(...) — посылает транзакцию на изменение состояния в блокчейн.Метод APIResponse getUser() — описывает общую логику счытивания информации из смарт-контракта и возращает ответ клиенту.Метод String readUserFromSmartContract(...) — считывает состояние из смарт-контракта и возращает результат.Полный код приложение доступен в GitHub репозитории, ссылка на который будет вконце этой статьи.ПроверкаДля тестирования всех 3 типов транзакций я написал тестовые класы (код находиться в GitHub репозитории). Для этого я развернул блокчейн с 3 Quorum нодами (3 ноды Geth + 3 ноды Tessera). 3 Quorum ноды это минимум нод необходимых для проверки всех типов транзакций. Имейте это ввиду, если захотите попробовать сами.Public транзакцииДля выполнение тестового кейса с публичной транзакцией необходимо выполнить следующую команду:gradle test --tests *.PublicTransactionsTestsЭтот тест кейс пошлёт 3 запроса на API. Первый на деплой смарт-контракта в блокчейн, второй — изменение состояние контракта и третий запрос — считывание информации из смарт-контракта. В результате выполнения теста вы увидите примерно такие логи (адреса в вашей сети будут отличаться, как и хеши транзакций):[HANDLER] privateFor = [public][HANDLER] deploying new smart-contract[HANDLER] contract has been successfully deployed. Result: {contract_address=0xf9425b94e459805da09950f5988071692d925097, transaction_hash=0x31bc179f8cd12c640d1663f3df51ce6da1fbc2875f2b724c3911108fcd19a5d0}[HANDLER] privateFor = [public][HANDLER] sending new transaction[HANDLER] transaction has been successfully executed. Result: {contract_address=null, transaction_hash=0x33ba66d5deec33f3142bfa190a0d37d0ff07c2e66b06037f5b5ff9578154a3ff}[HANDLER] reading user from smart-contract[HANDLER] user: 'Public Test User'В общем, эти логи говорят о том, что все 3 операции прошли успешно. Первые 3 лога — принадлежат запросу на деплой смарт-контракта, следущее 3 лога — принадлежат выполнению транзакции, а последние 2 — считыванию информации из смарт-контракта.То, что в по итогу загрузки контракта мы видим contract_address, а в случае простой транзакции — нет, это вполне нормально, так как во второй раз мы не деплоим контракт, а выполняем транзакцию на уже существующий смарт-контракт.Теперь давайте проверим, что нам показывает Geth, выполняем следущую команду для подключения к IPC интерфейсу процеса Geth клиента:geth attach /path/to/ipcПосле того, как мы ""приатачились"" к процесу, можно пересматривать полностю всю необходимую информацию. Давайте посмотрим на TransactionReceipt транзакции на деплой нового смарт-контракта, выполнив команду (хеш транзакции нужно поставить свой, и взять его из логов теста):web3.eth.getTransactionReceipt('0x31bc179f8cd12c640d1663f3df51ce6da1fbc2875f2b724c3911108fcd19a5d0');В качестве результата видим следущее:Нас интересуют следущие параметры:""contractAddress"" — если не ""null"", то мы понимаем, что это транзакция на деплой смарт-контракта;""status"" — в даном случае оно равно ""0x1"" — что означает, что транзакция прошла успешно.И давайте посмотрим на саму транзакцию. Выполнив команду: web3.eth.getTransaction('0x31bc179f8cd12c640d1663f3df51ce6da1fbc2875f2b724c3911108fcd19a5d0');Результат:Здесь нас интересую следущие параметры:""input"" — это payload транзакции;""v"" — в общем, это параметр для ECDSA, алгоритма цифровой подписи, но нас интересует сейчас другое — значение переменой. Важно оно потому, что у публичных и приватных транзакций оно будет отличаться. ""0x1c"" (""28"" в десятичной системе) и ""0x1b"" (""27"" в десятичной системе) характерны для публичных транзакций, а ""0x25"" (""37"" в десятичной системе) и ""0x26"" (""38"" в десятичной системе) — это коды приватных транзакций.Можете также проверить, что на других нодах информация не отличаеться от той, что мы увидили сейчас.Теперь можно просмотреть на транзакцию изменения состояния смарт-контракта. Выполним команду:web3.eth.getTransactionReceipt('0x33ba66d5deec33f3142bfa190a0d37d0ff07c2e66b06037f5b5ff9578154a3ff');Результат:Нас интересуют следущие параметры:""to"" — видим, что транзакция пошла на только-что задеплоиный смарт-контракт;""status"" — оно равно ""0x1"", что означает, что транзакция прошла успешно.Транзакция:Ничего необычного, но можете проверить информацию на других нодах, это полезно.Private транзакцииДля выполнение тестового кейса с приватной транзакцией, необходимо выполнить следующую команду:gradle test --tests *.PrivateTransactionsTestsТакже, как в тест-кейсе с публичными транзакциями, этот тест-кейс задеплоит новый смарт-контракт, выполнит транзакцию на смену состояния и счытает информацию из переменой в смарт-контракте.В результате програма напишет такие логи:[HANDLER] privateFor = [][HANDLER] deploying new smart-contract[HANDLER] contract has been successfully deployed. Result: {contract_address=0x3e2284d92842f781b83cc7e56fbb074ab15f9a90, transaction_hash=0x8fd619bd9a526f83e29d7b417551e174862f7503ef430eb45793509d05039595}[HANDLER] privateFor = [][HANDLER] sending new transaction[HANDLER] transaction has been successfully executed. Result: {contract_address=null, transaction_hash=0x72a0458a7b313c8a1c18269ae160e140c6a6e41cb2fd087c64cf665b08a6aefb}[HANDLER] reading user from smart-contract[HANDLER] user: 'Private Test User'Изменением, по сравнению с публичными транзакциями, есть параметр privateFor — теперь он имеет значение пустого масива.Давайте проверим TransactionReceipt по транзакции. Команда:web3.eth.getTransactionReceipt('0x8fd619bd9a526f83e29d7b417551e174862f7503ef430eb45793509d05039595');Результат:Из изменений, по сравнению с публичными транзакциями, стоит сказать, что вы не увидите количество газа, потраченое на выполнение транзакции — gasUsed и cumulativeGasUsed имеют значение ""0"".А теперь давайте посмотрим на саму транзакцию. Выполним команду:web3.eth.getTransaction('0x8fd619bd9a526f83e29d7b417551e174862f7503ef430eb45793509d05039595');В результате увидим такое:Что стоит отметить в даной транзакции:Как я уже упоминал в начале этой статьи, вместо реального payload транзакции вы увидите фиксированую строку в 64 байта (128 символов) в поле input. Эта строка — идентификатор на данные в хранилище Tessera, реальные данные вы можете получить по запросу к Tessera.""v"" — вместо кодов ""0x1c"" или ""0x1b"" как в публичных транзакциях, для приватных транзакций вы увидите ""0x26"" или ""0x25"".Теперь давайте проверим TransactionReceipt и саму транзакцию на изменение состояние контракта (команды вы уже знаете). Результат:Ничего нового мы из этой приватной транзакции, в принципе, не узнаем.Permissioned транзакцииТак, как это тоже приватные транзакции, просто приватные они не для 1 ноды, а для нескольких, то результаты выполнения таких транзакций ничем не будут отличаться от приватных транзакций. Разницу можна почуствувать, если попробовать получить информацию из ноды, которая была указана в privateFor и из ноды, чей публичный ключ не прописан в privateFor (сможете получить информацию с первой ноды и не сможете со второй).Что бы запустить тест-кейс с транзакциями приватными для нескольких учасников сети (permissioned транзакции), нужно выполнить следущую команду:gradle test --tests *.PermissionTransactionsTestsЛоги Java API:[HANDLER] privateFor = [wQTHrl/eqa7TvOz9XJcazsp4ZuncfxHb8c1J1njIOGA=][HANDLER] deploying new smart-contract[HANDLER] contract has been successfully deployed. Result: {contract_address=0xf1cc0ba22bd0d18fc9acb22dd57795a3f2fb4ebd, transaction_hash=0x585980bec88aa8a0fe5caffe6d6f24b82d3cd381fcf72fdd8e2102ce67799f01}[HANDLER] privateFor = [wQTHrl/eqa7TvOz9XJcazsp4ZuncfxHb8c1J1njIOGA=][HANDLER] sending new transaction[HANDLER] transaction has been successfully executed. Result: {contract_address=null, transaction_hash=0x47edc0d00fa9447b2da9f5a78f44602f96145497238cb1ce1d879afb351a3cbe}[HANDLER] reading user from smart-contract[HANDLER] user: 'Permissioned Test User'Результаты в Geth-клиенте, на деплой нового смарт-контракта, TransactionReceipt и сама транзакция соотвествено:И транзакция на изменение состояния, TransactionReceipt и сама транзакция:HTTP запросыНесмотря на то, что мы увидели, как публичные транзакции отличаються от приватных с точки зрения Geth-клиента, это не показывает реального ограничения на получение информации. Поэтому для того, чтобы показать вам, что действительно можно ограничить число нод, способных прочитать вашу транзакцию, я сделаю несколько запросов с помощью CURL на 3 ноды, для считывания информации со смарт-контракта (запросы будут касаться сделаных private и persmissioned транзакций).HTTP запросы будут иметь в теле запроса 2 параметра:""endpoint"" — непосредстверно endpoint к Quorum ноде, нужно для подключения к ноде.""contractAddress"" — адрес контракта, с которого будут считываться данные.В моем случае ""endopint"" будет иметь один хост — localhost — но разные порты для 3 Quorum нод: 22000 (с этой ноды делались все транзакции), 22001 (ее публичный ключ был указан в permissioned транзакциях), 22002 (не должна иметь доступ к информации).Начнем с private транзакции (только нода на 22000 порте должна иметь возможность просматривать информацию в смарт-контракте).CURL запрос на ноду которая делала транзакции:curl -X POST \    http://127.0.0.1:8080/user \    -H 'Content-Type: application/json' \    -d '{    ""endpoint"": ""http://127.0.0.1:22000"",    ""contractAddress"": ""0x3e2284d92842f781b83cc7e56fbb074ab15f9a90""}'Как результ мы получили следущее:{""data"":{""user"":""Private Test User""}}Это означает, что нода имет возможность просматривать информацию в смарт-контракте.Теперь давайте просмотрим, что вернет нам нода на 22001 порту. CURL запрос:curl -X POST \    http://127.0.0.1:8080/user \    -H 'Content-Type: application/json' \    -d '{    ""endpoint"": ""http://127.0.0.1:22001"",    ""contractAddress"": ""0x3e2284d92842f781b83cc7e56fbb074ab15f9a90""}'Отлично! В результате мы получили следущее сообщение об ошибке:{""data"":{""status_code"":500,""description"":""Something went wrong""}}В данном случае это означает, что мы не можем прочитать информацию из смарт-контракта — то чего мы добивались!И ещё надо проверить последнюю, 3-ую ноду. CURL запрос:curl -X POST \    http://127.0.0.1:8080/user \    -H 'Content-Type: application/json' \    -d '{    ""endpoint"": ""http://127.0.0.1:22002"",    ""contractAddress"": ""0x3e2284d92842f781b83cc7e56fbb074ab15f9a90""}'Отлично! API возращает ошибку:{""data"":{""status_code"":500,""description"":""Something went wrong""}}Теперь мы убедились, что приватные транзакции действительно ограничивают доступ к данным. Теперь пришло время проверять ""permissioned"" транзакции.Делаем CURL запросы на считывание данных из созданого ""permissioned"" смарт-контракта из ноды, запущеной на порту 22000:curl -X POST \    http://127.0.0.1:8080/user \    -H 'Content-Type: application/json' \    -d '{    ""endpoint"": ""http://127.0.0.1:22000"",    ""contractAddress"": ""0xf1cc0ba22bd0d18fc9acb22dd57795a3f2fb4ebd""}'Результат:{""data"":{""user"":""Permissioned Test User""}}Это означает, что нода имеет доступ на чтение данных из контракта, что не удивительно, так как эта нода их и создавала.Теперь попробуем прочитать информацию из этого смарт-контракта с другой ноды, чей публичный ключ был прописан во время деплоя смарт-контракта, а также в транзакции на модификацию информации. CURL запрос:curl -X POST \    http://127.0.0.1:8080/user \    -H 'Content-Type: application/json' \    -d '{    ""endpoint"": ""http://127.0.0.1:22001"",    ""contractAddress"": ""0xf1cc0ba22bd0d18fc9acb22dd57795a3f2fb4ebd""}'Отлично! В результате выполнения запроса мы действительно смогли прочитать данные:{""data"":{""user"":""Permissioned Test User""}}Теперь нужно только убедиться что нода, чей публичный ключ не был указан во время выполнения транзакции, не сможет прочитать данные. CURL запрос:curl -X POST \    http://127.0.0.1:8080/user \    -H 'Content-Type: application/json' \    -d '{    ""endpoint"": ""http://127.0.0.1:22002"",    ""contractAddress"": ""0xf1cc0ba22bd0d18fc9acb22dd57795a3f2fb4ebd""}'Отлично! Последняя нода действительно не смогла прочитать информацию из смарт-контракта. Как и было задумано.ЗаключениеВ этой статье я хотел показать, как можно использовать Quorum blockchain для разработки Java приложений. Надеюсь что у меня всё получилось, и вы нашли что-то важное и интересное для себя.Ссылки на ресурсы:Документация по QuorumТестовая сеть на QuorumПроект на GitHub Quorum канал в Slack Спасибо за внимание!"
ph_piter;Стек приложений Blockchain;Блог компании Издательский дом «Питер» Профессиональная литература;"Здравствуйте, Хабр!

Надеемся не слишком вас шокировать, признавшись в неподдельном интересе к децентрализованным приложениям. 



Вместе с автором мы убеждены, что «не биткойном единым» полезны описанные технологии, и в качестве доказательства предлагаем перевод интересной статьи, в которой внятно и убедительно описаны перспективы стека Blockchain";/ru/company/piter/blog/277625/;"Здравствуйте, Хабр!Надеемся не слишком вас шокировать, признавшись в неподдельном интересе к децентрализованным приложениям. Вместе с автором мы убеждены, что «не биткойном единым» полезны описанные технологии, и в качестве доказательства предлагаем перевод интересной статьи, в которой внятно и убедительно описаны перспективы стека BlockchainКак-то раз мне выпал случай провести воркшоп на нью-йоркском хакатоне по биткойну, где я рассмотрел биткойн как протокол, рассказал об альтернативных способах использования блокчейна, а также упомянул о вызовах и возможностях, связанных с этой технологией. Одно из основных достоинств работы в сфере венчурных капиталов — это возможность взглянуть на рынки под совершенно новым углом. Ежедневно ты можешь узнать от предпринимателей и представителей корпораций, как готовится наше будущее — ведь они же его и создают. Это завораживает, особенно если ты – настоящий технарь. Мы внимательно отслеживаем все, что происходит с Bitcoin и Blockchain. В некоторых случаях речь идет об идеях, в других – о реальных продуктах, уже имеющихся на рынке. Некоторые из них лопнули, а другие снискали финансирование в миллионы долларов. Имея под рукой всю эту информацию, можно выявить определенные закономерности и тренды и составить впечатление о том, что нас ждет.  Думаю, именно так архитектура интернет-приложений будет выглядеть через 10 лет. Это упрощенная иллюстрация, на ней не видно многих важных находок и проблем. Ниже я постараюсь максимально доходчиво объяснить ее смысл. Чтобы не отвлекаться, мы обсудим каждый элемент стека снизу вверх, а затем я размещу в своем блоге подробную статью по каждому из них.Идея такова, что все компоненты в серых прямоугольниках — децентрализованные, с открытым исходным кодом. Пока назовем их «Разделяемые данные» (Shared Data) и «Уровни протоколов» (Protocol layers). Этими частями системы никто не управляет, поэтому они доступны для любого разработчика или компании. Так, в случае Bitcoin уровнем разделяемых данных будет Blockchain, а протоколом — Decentralized Protocol.Вы заметите, что чем выше вы поднимаетесь по схеме, тем тоньше становятся отдельные уровни. Кроме того, на уровень разделяемых данных и уровень протоколов приходится около 80% всего стека. Современные приложения для Интернета создаются на базе открытых децентрализованных технологий, таких как TCP/IP и HTTP, но если начертить примерно такую схему стека интернет-приложений, как показана выше, то эти открытые децентрализованные протоколы займут, вероятно, всего 15%, а выше них будут только приватные и централизованные технологии. 1. Майнеры и BlockchainЕсли вы хотя бы приблизительно представляете, как работает Bitcoin, то знаете, кто такие майнеры. В сущности, майнеры – это узлы в составе компьютерной сети, вместе верифицирующие все транзакции Bitcoin. Алгоритм оплачивает их работу биткойнами. Поскольку биткойны обладают реальной котировкой, операторам этих машин выгодно, чтобы они работали. Если вам интересно, как устроен майнинг, тема отлично раскрыта в этой статье.Blockchain – общедоступный журнал, в котором содержится перманентная запись обо всех транзакциях Bitcoin, ведут этот журнал сами майнеры. Он не контролируется никакой организацией и доступен для всех. Подробнее о Blockchain можно почитать здесь.2. Наложенные сетиЗдесь начинается самое интересное. Разработчики начинают сооружать сети, работающие параллельно блокчейну для решения таких задач, с которыми биткойновая сеть справиться не может. Правда, при таких задачах блокчейн также используется – например, чтобы ставить метки времени или валидации работы.Один из примеров такого решения — Counterparty. Другой, возможно, Side Chains. Какую бы форму ни имели эти наложенные сети, всех они связаны с блокчейном Bitcoin, а также выгодно используют его сетевые эффекты для достижения гибкости; при этом в них нет необходимости создавать собственную криптовалюту и/или цепочки блоков, как того требуют альтернативные решения вроде Ethereum.3. Децентрализованные протоколыБлагодаря Blockchain, впервые появилась возможность разрабатывать свободные децентрализованные протоколы со встроенной валидацией данных (благодаря наложенным сетям и блокчейну), а также совершать транзакции, которые не контролируются централизованно. Именно здесь начинает распадаться традиционная архитектура IT-бизнеса. Наилучший пример децентрализованного протокола, работающего поверх уровня разделяемых данных – это Bitcoin; мы уже представляем, как он повлиял на деньги и финансы. Такие компании как Ebay, Facebook и Uber очень дорого стоят, так как делают огромную прибыль на сетевых эффектах, связанных с хранением всей пользовательской информации в приватных ячейках и получением процента от всех транзакций. Децентрализованные протоколы, расположенные поверх блокчейна, потенциально позволяют отключать любую отдельную часть стека, поэтому такие сервисы очень ценны для потребителей и инвесторов. Для этого можно, к примеру, создавать общие децентрализованные множества данных, к которым кто угодно может подключаться и начинать одноранговые транзакции по принципу Bitcoin.На самом деле, многие многообещающие команды уже приступили к разработке протоколов, способных разрушить бизнес-модели вышеупомянутых компаний. Пример — Lazooz, протокол для поиска попутчиков в реальном времени; другой пример — OpenBazaar, протокол для свободных децентрализованных одноранговых рынков.4. Свободные и коммерческие APIСреднестатистическому разработчику сложно надстраивать код прямо над протоколом, поэтому можно запросто к ним подключаться. Хорошо ли это в долгосрочной перспективе – сложный вопрос, но я считаю, что это очень важная часть стека. Величайшее достижение этих децентрализованных протоколов связано с тем, что разработчик, обладающий любым набором навыков и квалификацией, может быстро выстраивать на них приложения и экспериментировать с ними.Речь идет либо о коммерческих сервисах, либо о свободных проектах. Хорошие примеры – API Chain.com и Coinbase Toshi для Bitcoin. Они оба предназначены для одних и тех же целей, но Chain – арендуемый коммерческий сервис, а Toshi – свободный.5. ПриложенияЭто часть стека, обращенная к пользователю. В большинстве случаев приложения, выстроенные на такой архитектуре, функционально будут очень напоминать существующие сегодня – точно как Coinbase и PayPal. Но большая разница для пользователей заключается в том, что протоколы в данном случае децентрализованные. Программы смогут обмениваться информацией точно как различные почтовые приложения или биткойновые кошельки.Важная черта этого стека – он растет снизу вверх. Сначала появились майнеры, блокчейн и Bitcoin, а затем – все остальное. Насколько мне известно, важнейшие технологические революции развивались именно таким образом.Таким образом, возникают очень интересные вызовы для разработчиков, предпринимателей и инвесторов: ведь этот стек адаптирует для широкого потребления очень перспективные вещи. Но, в конечном итоге, выигрывает пользователь, поскольку в таких приложениях действуют сниженные или нулевые входные взносы, издержки переключения невелики, все данные находятся в индивидуальном распоряжении, а рыночная мощность превосходит все ожидания."
jasiejames;Nasdaq планирует использование технологии blockchain;Финансы в IT;"У Bitcoin есть проблемы с имиджем. Эта валюта крайне противоречива практически с момента дебюта. Использование Bitcoin на нелегальных рынках, пропажа сотен миллионов долларов с популярной обменной биржи и другие события подобного характера роняют тень на репутацию криптовалюты.

Но все это ни коим образом, не затрагивает базовую технологию, blockchain, в общем представляющую собой децентрализованную базу данных о транзакциях в сети. Nasdaq хочет доказать применимость технологии blockchain, сначала в своей платформе (Private Market), и, если все пойдет хорошо, в конце концов на фондовом рынке.";/ru/post/290460/;У Bitcoin есть проблемы с имиджем. Эта валюта крайне противоречива практически с момента дебюта. Использование Bitcoin на нелегальных рынках, пропажа сотен миллионов долларов с популярной обменной биржи и другие события подобного характера роняют тень на репутацию криптовалюты.Но все это ни коим образом, не затрагивает базовую технологию, blockchain, в общем представляющую собой децентрализованную базу данных о транзакциях в сети. Nasdaq хочет доказать применимость технологии blockchain, сначала в своей платформе (Private Market), и, если все пойдет хорошо, в конце концов на фондовом рынке.Адрес кошелька — уникальный идентификатор внутри системы для получения и отправки средств. Представляет собой 160-битный хэш от открытого ключа ECDSA ключевой пары. Всего 34 символа. Допускаются цифры, буквы нижнего и верхнего регистра. Первый символ внутри сети Bitcoin всегда равен «1?. Оставшиеся 33 символа — это тот хэш от открытого ключа клиента. Транзакция в технологии blockchain — это основа системы, которая представляется в виде записи во встроенное в кошелек NoSQL хранилище. Адреса кошельков не попадают в blockchain до тех пор пока на данный адрес не происходит поступление.Nasdaq хочет использовать blockchain для упрощения верификации транзакций, ускорения процесса торговли и повышения надежности.CoinDesk отмечает, что Nasdaq не первая компания, положительно оценивающая потенциал blockchain. Различные инвестиционные банки, венчурные капиталисты, и специализирующиеся на данных работники финансовой индустрии возлагают большие надежды на технологию. И это не куча параноиков, выступающих за криптовалюты как замену традиционным средствам платежей, а одни из самых умнейших людей в области финансов превозносят достоинства новой технологии.Первым использованием технологии blockchain для Nasdaq будет полностью электронное распределенное решение для учета — ExactEquity. Анонс инструмента планируется чуть позже в этом году.
BitfuryRussia;Crystal Blockchain Analytics: Investigating the Hacks and Theft Cases;Блог компании Bitfury Group Информационная безопасность *Анализ и проектирование систем *Распределённые системы *Криптовалюты;In this report, Bitfury shares analysis completed by its Crystal Blockchain Analytics engineering team on the movement of bitcoin from the Zaif exchange, Bithumb exchange and Electrum wallets.;/ru/company/bitfury/blog/443178/;"In this report, Bitfury shares analysis completed by its Crystal Blockchain Analytics engineering team on the movement of bitcoin from the Zaif exchange, Bithumb exchange and Electrum wallets.Investigation of the Zaif Exchange HackOn September 17, 2018, the Zaif exchange suspended deposits and withdrawals in BTC, BCH and MONA. On September 18, the exchange reported to the police that it had been hacked and funds had been stolen. In their announcement, they shared the following information:Someone gained unauthorized access to the exchange on September 14, 2018 between 5PM and 7 PM local time (8 AM and 10AM UTC). They successfully transferred away 5,966 bitcoin (BTC) and unknown amounts of BCH and MONA. Zaif was alerted to this unauthorized access when a server malfunction was detected on September 17.Crystal Analytics ResearchBitfury’s Blockchain Analytics engineering team investigated the hack, focusing specifically on the movement of stolen bitcoin. A summary of our investigation can be found below.Step 1: Identify the hacker addresses. Because Zaif shared the exact time of unauthorized access, we were able to pinpoint which transactions belong to the hacker. We researched the largest transactions that happened between 7am and 11 am UTC. We shortly discovered a suspicious transaction. The transaction ID is c3b9a4a0831a65523c81e6a04f6ddf5a7a89f344d990e8a13e5278efe57f4280.This transaction has 131 inputs. Using Crystal’s identification software, we were able to determine all of the input addresses were Zaif addresses. The output address is 1FmwHh6pgkf4meCMoqo8fHH3GNRF571f9w. All bitcoin were sent to this address.Identification of the suspicious transaction from Zaif to the hacker.Step 2: Track the stolen funds. After identifying the bitcoin address the stolen bitcoin were sent to, we began monitoring that address. Our goal was to find addresses or known entities that received stolen bitcoin from this address. We did this by using Crystal’s Tracking tool.Address 1FmwHh6pgkf4meCMoqo8fHH3GNRF571f9w had 9 outgoing transactions and we tracked each one. After monitoring these transactions, we discovered that 5,109 addresses had received a portion of stolen funds.Next, we sorted tracking results by the amount settled and found addresses in control of the most significant portion of funds. In some cases, we were able to attribute those addresses to real entities.Transfer of funds from Zaif wallets to the hackerResults: The tracking results indicated that significant part of the funds (30% of total amount) had settled on two bitcoin addresses:3MyE8PRRitpLxy54chtf9pdpjf5NZgTfbZ?—1,007.6 BTC settled on the address.3EGDAa9rRNhxnhRzpyRmawYtcYg1jP8qb7—754.5 BTC settled on the address.These addresses received bitcoin within a very short chain of transactions (average length was 3 transactions). They had not appeared on the blockchain before, so the owner is unknown. It is probable that these addresses belong to the hacker, so we will monitor their activity going forward.A significant portion of bitcoin (1,451.7 BTC or 24%) was sent to Binance within a set of small transactions, to Binance address 1NDyJtNTjmwk5xPNhjgAMu4HDHigtobu1s. Binance confirmed that they own this address in their official Twitter account. Binance allows users to withdraw up to 2 BTC without going through a strict KYC/AML process, so the average sum sent to each Binance deposit address was 1.99–2 BTC.Pattern of Binance depositsVisualization of money flow to a Binance addressFractions of bitcoin were also sent to ChipMixer.com. The mixing service was reached within a rather short chain of transactions. Approximately 60 BTC have been sent to ChipMixer.com. You may see a transaction to ChipMixer.com on the figure below.Visualization of money flow to ChipMixer.comThe remaining bitcoin were split into relatively small amounts. Nearly 13 BTC have been sent to various Huobi addresses. Some of bitcoin reached exchanges such as BTCBox.com, Bitstamp, and Livecoin. Some portions of bitcoin were sent to mixing/gambling services such as CoinGaming.io and Bitcoin Fog. However, these entities were reached within a rather long chain of transactions.The rest of the funds have settled on addresses with unknown owners, and we will keep monitoring them in the future.Investigation of the Bithumb Exchange HackOn Wednesday, June 20, Bithumb officials stated that about $31M was stolen by unknown hackers from the Korean crypto exchange Bithumb. Four days before the hack, the exchange announced that it was transferring all assets to a cold wallet for security reasons.The withdrawal of funds by users was temporarily suspended starting June 15, 2018 at 6:20 PM UTC. We decided to trace the movement of funds in the period of the four days prior to the hack.We started by examining the more than 1 million addresses that belong to Bithumb and compiled a list of all the addresses that received funds during those four days. Only transactions committed from June 15 to June 20 were reviewed.Funds flow to Bithumb cold walletUntil June 19, the movement of funds had two main patterns:Many of the funds moved were accumulated to this address: 1LhWMukxP6QGhW6TMEZRcqEUW2bFMA4Rwx (referred to after this as address “1LhW”)From the 1LhW address, transactions of large volume were sent to the address 18x5Wo3FLQN4t1DLZgV2MoAMWXmCYL9b7M (referred to after this as address “18x5”)The 18x5 address is the exchange’s cold wallet. This is evidenced by its transaction history (rare transactions of large volumes from/to the Bithumb exchange addresses).Balance history of address “18x5”The pattern of fund movement changed on June 19, 2018 at 03:07 PM UTC. At this time, two transactions were initiated from the Bithumb wallets to the addresses:34muFC1sWsvJ5dzWCotNH4rpKSNfkSCYvDand 3DjdVF83hhXKXV8nUFWCF5chrdSAkgE6Ny......with abnormally high commissions of 0.1 BTC. After this moment, there was a period of half an hour in which about 1,050 BTC were withdrawn and deposited in addresses that had not previously appeared in the blockchain. The withdrawal of funds to these addresses (38 addresses) lasted more than a day.After that, the exchange stop using the buffer address 1LhW. Also, after June 19, 2018 at 05:01 PM UTC, the fee amounts for incoming transactions for the address 18x5 changed dramatically?—?first to 0.1 BTC, and then to 0.2 BTC.Soon after this change, a message appeared on the official Exchange account on Twitter, warning users to avoid depositing funds.High transaction fees for the withdrawal of funds from the exchange addresses continued the entire day, sometimes reaching as high as 2 BTC, higher than the output volume.Transaction with abnormally high feeSuch behavior provoked an increase of transaction fees and bitcoin network congestion on June 19–20.All the funds withdrawn from the Bithumb wallets for the period from June 16 to June 20 were received by 39 wallets (we excluded several dozens of change addresses with small amounts from the results of the calculation).One of these 39 addresses is the cold wallet of the exchange(18x5), which received most of the funds. The remaining 38 addresses have unidentified owners. These addresses received 2002.52 BTC within the day on June 19–20. (With transaction fees totaling to 48.126 BTC)Based on the information given above, it is our professional opinion that there are two possible options:The set of 38 addresses to which funds were withdrawn belongs to the hackers. Criminals, having access to the system or the database with private keys, began to make transfers to their addresses starting on June 19, 2018 at 03:07PM UTC. High commissions (0.1 BTC) are logical in this case if you want to quickly withdraw as much as possible.After a while, the exchange noticed the theft and started raising transaction fees when transferring to a cold wallet (sometimes much higher than the transactions of hackers had). By the end of the day on June 20, the exchange managed to solve security problems. The loss in bitcoins was, as stated by Bithumb, 2,016 BTC. This number is very close to the amount we calculated (obtained by a group of unknown addresses), 2,002.52 BTC, which also indicates that this option is likely.All the addresses we considered belong to the exchange. Another possible option is that the theft could have occurred from wallets that are not in our database. Given that Bithumb is cooperating with law enforcement agencies in the investigation of this case, as well as the fact that they recently passed licensing procedure, the possibility that the exchange provided false information is unlikely.Tracking the FundsThese addresses were monitored further and the withdrawal of funds started on August 2. First, there was a large transaction of 1000 BTC. We launched tracking of this transaction and, according to its results, money was sent to two addresses belonging to Yobit exchange within transactions of approximately 30 BTC. The visualization of money flow can be seen in the figure below.Funds flow to Yobit addressThe address 1JwpFNKhBMHytJZtJCe7NhZ8CCZNs69NJ1 on top of the graph, which belongs to Yobit, received 603 BTC. Another Yobit address, 13jHABthiyHHtviHe9ZxjtK8KcEANzhjBT, received 396 BTC via the same chain of transactions.The remaining funds were sent directly to Yobit addresses. Below you may see the list of its addresses and amounts received:1DBRZgDZYnmLWLUpLMgBo1P12v9TnCL8qr?—?100 BTC13rgFLyKYQduTwhJkkD83WDLVNMXs4fwPp?—?100 BTC1A6wuQGYPbEEb9cy76tdSQHmm5fi5wvzHK?—?344 BTC1JquU8Hp6nAhom5c3UDBa9QM5iv1W2Wf2b?—?433 BTCAfter the withdrawal to Yobit, there were 29 BTC left in 3 addresses, possibly belonging to the hacker. They started moving on August 31. The funds were divided into parts?—?approximately two BTC each?—?and were sent to CoinGaming.io. The visualization of money flow can be seen in the figure below:Funds flow to CoinGaming.ioAs a result, CoinGaming.io received 29 BTC from the stolen funds.Considering the movement patterns of the funds, we assume that the 38 addresses we identified belong to the hacker. A majority of the stolen funds were sent to the Yobit exchange.Investigation of the Electrum Theft CaseOn Dec. 27, 2018, the bitcoin wallet Electrum notified users about a phishing attack that was targeting users through malicious servers. At that point, the alleged hacker(s) had already stolen more than 245 BTC.Using Crystal analytics, we investigated the movement of funds from the hack, tracking them to two major exchanges. Below, we present those findings.The phishing attack worked in the following way:First, the alleged hacker managed to add dozens of malicious servers to the Electrum networkThe user initiates a bitcoin transaction using their legitimate wallet;In response, the user receives a push error message?—?a phishing message that requires the user to immediately download the “update” from the malicious site (the GitHub repository);The user clicks on the link and downloads the malicious update;After the user installs a malware version of the wallet, the program asks the victim for a two-factor authentication code (which, under normal circumstances, is requested only for transferring funds);The fake Electrum wallet uses the code to send the user’s funds to a hacker’s wallets.Crystal’s findings showed that the majority of funds were sent to the address: 14MVEf1X4Qmrpxx6oASqzYzJQZUwwG7Fb5.After a few hours, the alleged hacker had transferred all funds to the address 1MkM9Q6xo5AHZkLv2sTGLYb3zVreE6wBkj, where the funds have settled. As of Jan. 11, 2019, 245 BTC remained in 1MkM9Q6xo5AHZkLv2sTGLYb3zVreE6wBkj. However, it’s important to note that on Dec. 27, the alleged hacker sent 5 BTC to the address 1N1Q7fEF6yxnYsMjvH2jtDDzzW6ndLtfEE.In the days since the original hack, the alleged hacker has moved those funds, withdrawing 0.2 BTC on Jan. 3 to a Bitfinex wallet (3Kk8aWoGexBo52bY8TJuMseoxKBnGD5QqH), and withdrawing 0.41 BTC on Jan. 11 to a Binance wallet (13cRSL82a9x2MMCedFQBCJJ2x5vCgLyCXC).On January 18, the alleged hacker became active again by moving funds through chain of transactions. They have now withdrawn 3 BTC to a Bitfinex wallet (33d8Dm2hyJx6NHhHep7KM4QKbjTgWpAQQt).Moreover, the alleged hacker transferred 49 BTC from 1MkM9Q6xo5AHZkLv2sTGLYb3zVreE6wBkj wallet and distributed them within 13 addresses. On Jan. 25, 2019, the alleged hacker has withdrawn funds in bitcoin from all his wallets. Further investigation revealed that the alleged hacker had moved the significant part of bitcoin to the exchange service MorphToken. All the funds that reached Bitfinex were sent there by the MorphToken service.MorphToken provides the ability to check the status of a transaction using its API. Having checked all the wallets in the hacker’s withdrawal chains in this way, we have managed to find out that at least 243 BTC were sent by the alleged hacker to this service. Almost all funds were exchanged for XMR. However, a small amount (0.07 BTC) was transferred to Ethereum.About CrystalCrystal is the all-in-one blockchain investigative tool. Designed for law enforcement and financial institutions, Crystal provides a comprehensive view of the public blockchain ecosystem and uses advanced analytics and data scraping to map suspicious transactions and related entities. Whether it is tracking a bitcoin transaction to a real-world entity, determining relationships between known criminal actors, or surveying suspicious online behavior, Crystal can help move your investigation forward.To learn more, visit crystalblockchain.com.Follow Crystal on Twitter to stay up to date on other investigations: @CrystalPlatform."
cigulev;Финтех и Blockchain: подводим итоги уходящего года и делаем прогноз на следующий;Криптография *Платежные системы *;"До конца года осталось всего несколько дней, а это значит, что пришло время подвести итоги уходящего года и сделать прогнозы на будущий. По уже сложившейся традиции я расскажу о самых интересных событиях, тенденциях и достижениях 2015 года в области финансовых инноваций и блокчейн-технологии. 

Итоги года. Fintech
Для финтех-индустрии подобные годовые отчеты особенно актуальны, ведь те события, которые происходят в течение года, определяют вектор развития отрасли в будущем. За прошедший 2015 год рынок венчурных инвестиций в финтех побил рекорды прошлых лет. Крупнейшие игроки финансовой отрасли решились на крупные сделки. Молодые стартапы анонсировали интересные проекты. Но обо всем по порядку.";/ru/post/273937/;До конца года осталось всего несколько дней, а это значит, что пришло время подвести итоги уходящего года и сделать прогнозы на будущий. По уже сложившейся традиции я расскажу о самых интересных событиях, тенденциях и достижениях 2015 года в области финансовых инноваций и блокчейн-технологии. Итоги года. FintechДля финтех-индустрии подобные годовые отчеты особенно актуальны, ведь те события, которые происходят в течение года, определяют вектор развития отрасли в будущем. За прошедший 2015 год рынок венчурных инвестиций в финтех побил рекорды прошлых лет. Крупнейшие игроки финансовой отрасли решились на крупные сделки. Молодые стартапы анонсировали интересные проекты. Но обо всем по порядку.Запуск целого ряда платежных брендовПортал LTP среди событий года выделяет, то что Google совместно с партнерскими платежными сетями представил Android Pay, долгожданный запуск которого произошел в сентябре 2015 года. Теперь обладатели Android-смартфонов с поддержкой NFC (версия KitKat 4.4 или выше) могут совершать бесконтактные платежи на всей территории США.20 августа в Корее состоялся первый запуск Samsung Pay, а в сентябре сервис также заработал и в США. По информации компании, с момента запуска база пользователей каждый день растет на 25 тысяч человек. Ежедневный оборот при этом составляет более 620 тысяч долларов.На конференции Money20/20 в Лас-Вегасе крупнейший по активам банк США JPMorgan Chase объявил о запуске собственного цифрового кошелька под названием «Chase Pay». Начиная с 2016 года Chase Pay позволит 94 миллионам держателей кредитных, дебетовых и предоплаченных дебетовых карт банка совершать покупки в оффланй-магазинах, интернет-магазинах и приложениях.Игроки технологического сектора входят в финтех17 марта Facebook громко заявил о своем выходе на рынок платежных услуг, добавив возможность отправки персональных платежей через свой мессенджер.Alibaba представила собственную модель умных часов под названием Pay Watch, выпускаемую совместно с китайским производителем спортивных аксессуаров FiiSmart. Устройство стоимостью 110$ позволит компании реализовать ее планы по укреплению позиций на рынке носимых устройств.Компания Tencent вместе с двумя другими крупными акционерами учредила первый в Китае онлайн-банк. WeBank будет оказывать услуги малому и среднему бизнесу с помощью «инновационных финансовых продуктов», основанных на WeChat.Инвестиции в финтехВ 2015 году суммарные инвестиции в финансовые технологии превысили 5 миллиардов долларовВ ходе инвестиционного раунда E стартап SoFi собрал рекордную для финтех-компаний сумму в 1 миллиард долларов. Активным инвестором стал SoftBank Group. Кроме него в раунде также приняли участие Baseline Ventures, DCM Ventures, IVP, Renren, Third Point Ventures и Wellington Management. В ходе раунда С немецкий онлайн-сервис микрокредитования Kreditech собрал около 92 миллионов долларов. Инвесторами проекта стали J.C. Flowers & Co, Amadeus Capital Partners, Blumberg Capital, HPE Growth Capital, Питер Тиль и Ward Partners.Stripe получил $90 млн в ходе раунда С. Среди основных инвесторов стоит отметить Visa, а также такие компании, как Sequoia Capital и American Express. Около 67 миллионов удалось получить производителю мобильных платежных терминалов iZettle в раунде D венчурного финансирования. Активными инвесторами выступили Intel Capital, Zouk Capital и Santander InnoVentures.Производитель платежных терминалов Lightspeed POS привлек 61 миллион долларов в рамках серии C. Кредитная площадка Avant привлекла $325 млн в сентябре 2015 года, в мае сервис для выбора кредитных продуктов для потребителей Affirm получил $275 млн.В четверку наиболее активных игроков венчурного бизнеса входят Digital Currency Group, Sequoia Capital, Blockchain Capital и SV Angel.Из любопытных сделок на российском рынке можно отметить то, что QIWI Venture вложил до $100 тыс. в мобильное приложение Panda Money. Сервис разработан по принципу популярной игры «тамагочи». Пользователь кормит, одевает, развлекает виртуального питомца, а все средства, потраченные на это попадают на счет «игрока» на сайте проекта. Так приложение помогает накопить деньги на любые цели.Основные события на рынке персональных платежейВ мае MasterCard объявил о запуске в США MasterCard Send (не путать с MoneySend), первого в своем роде платежного сервиса, позволяющего совершать внутренние и международных персональные денежные переводы в течение нескольких секунд. Продавцы и коммерческие организации могут использовать платформу MasterCard Send для возврата стоимости товары или начисления бонусов, государственные органы и страховые компании — для совершения социальных и страховых выплат, а рядовые клиенты — для отправки денег друг другу, совместной оплаты счетов и других подобных переводов.Корпорация Apple обсуждает с американскими банками возможность разработки сервиса мобильных переводов, позволяющего пользователям отправлять деньги друг другу со своих смартфонов, наподобие работы приложений Venmo и PayPal. Как и другие мобильные платежные системы, Apple Pay уделяет большое внимание переходу с физических денежных носителей, таких как бумажники, наличные, чеки и карты, на прямые, бесконтактные и мобильные решения. Запуск подобного сервиса будет означать для Apple выход на рынок с высокой конкуренцией, значительная доля которого принадлежит Venmo и PayPal.Основные события на рынке кредитованияGoldman Sachs планирует запуск банковского онлайн-подразделения, основной целью которого будет прямое кредитование малого бизнеса и потребителей. Займы можно будет получить через веб-сайт или приложение.Lending Club совместно с Google объявили о запуске новой пилотной программы по упрощенной выдаче займов с низкой процентной ставкой компаниям-обладателям статуса «партнеров Google».Британский Metro Bank теперь выдает займы через платформу взаимного кредитования Zopa. Подписанный в мае договор, согласно которому банк получит возможность выдавать займы через веб-сервис персонального кредитования, стал первой сделкой такого рода в Соединенном Королевстве.CPA.com и ведущая онлайн-площадка для получения займов Biz2Credit, объявили о начале совместной работы в рамках маркетингового партнерства, предусматривающего совместное оказание услуг клиентам обеих компаний.Основные события на рынке мобильных платежейГлобальная сеть ресторанов McDonald’s подписала партнерское соглашение с ведущей в Китае независимой платежной системой AliPay. Это сотрудничество позволит McDonald’s завершить постепенное оснащение всех 2100 китайских заведений компании к марту 2016 года.Ведущий в мире поставщик платежных технологий, компания Global Payments объявила о запуске в Канаде новой серии мобильных терминалов оплаты под названием Ingenico Companion Mobile Payments. Продукт представляет собой решение под ключ, обеспечивающее продавца возможностью принимать все виды платежей с использованием кредитных и дебетовых карт, а также бесконтактные NFC платежи.Компания OmnyPay объявила о создании уникальной системы платежей, позволяющей продавцам интегрировать в процесс оплаты собственный брендинг, программы лояльности и спецпредложения. По словам основателей OmnyPay, использующие сервис продавцы получают возможность сократить издержки на проведение транзакции и увеличить продажи за счет упрощения процесса оплаты, поддержки всех видов каналов сбыта, контактных и бесконтактных способов оплаты, а также всех современных iOS и Android-устройств.Vector ITC Group подписала партнерское соглашение с компанией Sequent Software, предоставляющей решения в области перевода традиционных платежей на бесконтактный формат. Это сотрудничество поможет Vector ITC улучшить свое приложение Air Wallet за счет добавлению в него токенизации, поддержки технологий NFC и HCE, а также усиления защиты на стороне устройства.Основные события в сфере биометрической аутентификацииBank of America запустил услугу подтверждения личности с помощью отпечатков пальцев и Touch ID в своем мобильном приложении. Эта мера призвана сделать мобильный банкинг более надежным и безопасным.В апреле FIS добавила возможность авторизации в своем приложении мобильного банкинга с помощью технологии TouchID от Apple. Благодаря этому нововведению FIS стала первой компанией, предложившей биометрический доступ к мобильному управлению средствами без использования платежных карт.The Royal Bank of Canada стал первым в Канаде банком, предоставляющим своим клиентам возможность голосовой аутентификации. Новая функция Secure Voice позволяет подтвердить личность клиента с помощью анализа «голосового отпечатка» клиента. Обработка и сравнение голосовых данных требует всего нескольких секунд и возможна прямо во время разговора с менеджером банка. Подобная мера отменяет необходимость использования паролей, PIN-кодов или серии персональных вопросов и ответов.USAA запустил функцию подтверждения личности на основе проверки голоса или распознания лица клиента для входа в аккаунт через мобильное устройство.Ant Financial, дочерняя компания и по совместительству финансовое подразделение Alibaba, работает над технологией распознания лиц с целью ее последующего внедрения в платежную систему AliPay, а также AliPay Wallet.Главные слияния, поглощения и приобретенияVisa приобрела Visa Europe, дочернюю компанию, созданную незадолго до IPO 2008 года. Стоимость сделки составила 23.4 миллиарда долларов. Среди других приобретений Visa стоит отметить покупку TrialPay, лидера в сфере платежных технологий.BBVA приобрела Spring Studio в соответствии со своими планами развития цифрового банкинга. Early Warning приобрела Authentify. Prosper Marketplace приобрела BillGuard.Ведущий производитель банкоматов Diebold поглотил конкурента Wincor Nixdorf за 1.8 миллиарда долларов. Акции сервиса мобильных платежей Square начали котироваться на NASDAQ в ноябре этого года.Подразделение PayPal, ответственное за слияния и приобретения, добилось больших успехов в этом году: компания приобрела PayDiant и Xoom, крупных игроков платежного рынка. Бостонская PayDiant, разработавшая мобильную облачную платформу для совершения платежей, была приобретена в марте, а Xoom, международный сервис денежных переводов, акции которого котируются на бирже NASDAQ, — в ноябре. Кроме этих двух сделок компания также приобрела Modest, чикагский стартап, помогающий продавцам создавать мобильные приложения и интернет-витрины для своих магазинов.Прогнозы на 2016 годНа протяжении 5 последних лет мобильные платежи вызывают достаточно сильный потребительский интерес, но выйти на первое место в следующем году им все же не удастся, уверен Ralf Ohlhausen, директор по стратегическому планированию и развитию PPRO. Тем не менее, для провайдеров мобильных платежных решений 2016 год может стать определяющим. Apple Pay планирует масштабную экспансию европейского рынка, что может оказать существенное влияние на весь рынок мобильных платежей. И несмотря на то, что говорить о создании глобальной платежной системы еще рано, американский гигант Apple Pay сделает все возможное, чтобы ускорить этот процесс, ведь его конкурент — Google — также стремится занять лидирующие позиции на рынке мобильных платежей.Еще одна тенденция — мобильные платежи будут распределены между смартфонами и «умными» гаджетами, такими как «умные» часы, браслеты и кольца, оснащенными платежными модулями.В 2016 году существенное влияние на сферу платежей окажут биометрическая идентификация и токенизация. В настоящее время стандарты, регулирующие использование данной технологии, отсутствуют. Но уже в следующем году ситуация может измениться и процесс токенизации будет стандартизирован.Аутентификации пользователя также измениться. Предпочтение будет отдаваться двухфакторной аутентификации, обеспечивающей более высокий уровень защиты. Популярность будут набирать и такие способы идентификации, как сканирование рисунка вен, сканирование ладоней, распознавание голоса, сердечного ритма и т.д.Говоря о венчурном инвестировании, в 2016 году некоторые эксперты ожидают спад. Объясняется это действующей на рынке закономерностью «бум — спад». В России, по данным исследования Venture Barometer Russia 2015, 88% респондентов ожидают сокращение объемов инвестиций. Тем не менее, 92% опрошенных делали новые инвестиции в 2015 году и 38% в 2016 году собираются увеличить объем своих инвестиций в российские проекты. При этом 90% опрошенных считают, что инвестировать нужно только в те проекты, которые обладают международным потенциалом.В 2016 году продолжится отказ от наличных расчетов. Наиболее популярными методами платежей будут банковские карты и смартфоны. Конечно, в первую очередь это относится к европейским странам. В России 2016 год не станет переломным, наличные останутся наиболее предпочтительным инструментом платежа при совершении розничных транзакций. Так, по данным Банка России, в 2015 году количества наличных денег в обращении не только не уменьшилось, но даже увеличилось с 8315 млрд руб до 8849 млрд руб. Конечно, это не означает, что безналичные платежи в России не используются вовсе. По итогам первого полугодия 2015 года, оборот мобильных платежей составил более 120 млрд рублей.Что же касается электронной коммерции, предпринимателям, которые стремятся выйти на международную арену, стоит задуматься не только об организации эффективной логистики и переводе сайтов, но и о разработке международной стратегии. Важно настроить и локальные способы оплаты. Так, например, на рынках Азии, Латинской Америки и Восточной Европы, где проникновение карт ниже, чем в других регионах, важно сосредоточиться на альтернативных платежных методах.Итоги года. Bitcoin2015 год без преувеличения можно назвать годом Биткоина. Венчурные инвестиции в экосистему криптовалют превысили $1 млрд. Интерес с биткоину и лежащей в его основе технологии блокчейн по всему миру проявляют банки, торговые предприятия, благотворительные организации, правительство.Во всем мире банки и платежные системы изучают возможность применения технологии, лежащей в основе Bitcoin. Постепенно меняется отношение и к самой криптовалюте. В то время как на международной арене проходят споры о месте биткоина и блокчейна в мировой экономике, о его достоинствах и провалах, крупные банки и признанные платежные системы на деле доказывают пользу технологии.В апреле 2015 года правительство Сингапура сделало весьма амбициозное заявление, рассказав о планах превратить страну в азиатский центр финансовых и блокчейн-технологий путем разработки и внедрения законодательной базы, благоприятной для развития финтех и блокчейн-стартапов. После этого различные правительственные учреждения, в том числе общенациональная координационная организация Smart Nations Global Initiative, ведут тесное сотрудничество со стартапами, работающими над проектами, способными модернизировать существующие банковские системы.Потенциал Биткоина изучают в самых разных аспектах, в том числе и с такой нетривиальной точки зрения, как его использование в зонах конфликтов, в пострадавших от войны странах, где финансовая инфраструктура нарушена или вовсе не функционируют. Для этих целей в Бостонском университете создана рабочая группа CFLP по изучению биткоина, блокчейна и способах их применения в сфере денежных переводов.На позитивное свое отношение к криптовалюте, похоже, поменял Центральный банк Индии, выразив интерес к биткоину. В августе 2015 года представитель Банка сделал заявления, касающиеся Bitcoin, в частности, интеграции технологии в финансовую среду. Идея освоения цифровой валюты в Индии в первую очередь примечательна тем, что ранее правительство страны придерживалось позиции нейтрально-негативной. Периодически в обществе даже возникали слухи о запрете биткоина. Но это уже, вероятно, в прошлом, т.к. Резервный банк Индии признал, технология может поспособствовать модернизации финансового сектора.В сентябре 2015 года, практически сразу после открытия R3 — международной группы по изучению блокчейна — в нее были включены сразу 13 банков, в числе которых такие солидные организации как Deutsche Bank, Morgan Stanley, Bank of New York Mellon, Bank of America, HSBC, Citi и Societe Generale. Спустя месяц к ним присоединилось еще 3 крупных банка — шведский банк Nordea, итальянский UniCredit и японский Mizuho. На сегодняшний день в консорциум входит уже более 30 кредитно-финансовых учреждений.Американская транснациональная технологическая компания Microsoft приняла участие в развитие криптовалютных технологий, заключив партнерское соглашение с венчурным стартапом ConsenSys. Компании будут совместно работать над созданием новых продуктов на базе блокчейна Ethereum. Появившиеся в результате этого сотрудничества решения будут предоставляться клиентам облачной платформы Microsoft Azure в виде модели, получившей название «blockchain-as-a-service».Американский банк Goldman Sachs разворачивает активную деятельность в сфере цифровых валют. В декабре 2015 года он подал патентную заявку на создание собственной криптовалюты SETL coin для расчетов по ценным бумагам. Внедрением блокчейна занялся Королевский банк Канады. Крупнейшая немецкая банковская группа Deutsche Bank провела успешный тест блокчейн, проверив возможность его использования для «умных облигаций».Многие компании и организации продолжают внедрять Bitcoin для упрощения процесса оплаты и сбора пожертвований. Так, аргентинское подразделение международной экологической организации Greenpeace в сотрудничестве с платежным оператором BitPagos объявило о начале приема биткоинов в качестве пожертвований. Внимание на Bitcoin обратили в Bill & Melinda Gates Foundation, крупнейшем в мире благотворительном фонде, где цифровую валюту рассматривают как средства разработки новых платежных систем. Крупнейшая платежная система Чехии GoPay в этом году предоставила мерчантам возможность принимать криптовалюту в качестве оплаты.В этом году к международному сообществу присоединился и Сбербанк России, выразивший желание изучать блокчейн. Конечно, речь не идет о выпуске собственной криптовалюты. В планах Сбербанка разработка современных финансовых решений, способных упростить проведение транзакций и повысить надежность банковской системы в целом, а также применение блокчейна для внутренних расчетов и взаиморасчетов между дочерними компаниями и другими банками.Кроме этого в банке рассматривают возможность вступления в R3 CEV — международный блокчейн-консорциум, созданный для стандартизации протоколов применения blockchain и облегчения процесса внедрения новых финансовых решений. Окончательное решение о присоединении к R3 еще не принято, впрочем, и сама идея является прогрессивной для российского рынка.Крупная российская платежная система Qiwi объявила о начале разработки собственной криптовалюты Битрубль. Начать эмиссию цифровых монет компания планирует уже в 2016 году, если, конечно, платежка сможет уладить все спорные моменты с ЦБ РФ. Разрабатываться валюта будет на основе технологии блокчейн. По данным руководства компании, на выпуск битрубля понадобится несколько сотен миллионов рублейИнтерес к биткоину проявил и Яндекс. На форуме Finnopolis FinTech директор Yandex.Money Мария Грачева заявила, что компания рассчитывает на поддержку платежей в биткоинах. Конечно, делать какие-либо выводы об интеграции криптовалюты в сервисы Яндекса нельзя, процесс это длительный и пока еще болезненный для российского рынка, но в том, что погода в российской криптосреде в целом меняется на благоприятную, сомневаться не приходится.Стоимость биткоинаК концу года стоимость биткоина достигла максимального показателя за год ($450), значительно превысив значение, зафиксированное 1 января 2015 года ($314), но оказалась почти вдвое ниже его стоимости в сравнению с ценой, установленной на 1 января 2014 года, когда 1 биткоин стоил $770. Особенно волнительными были последние месяцы, когда курс биткоина сначала потерял в цене, а потом резко возрос. Впрочем, подобные «американские горки», как называют колебания некоторые эксперты, — это неизбежный этап, через который должен пройти Биткоин.Что будет с курсом Bitcoin в будущем?На этот вопрос ответил известный в биткоин-сообществе предприниматель Андреас Антонопулос.На сегодняшний день биткоин прошел через 4 подобных скачка. Всем известно о ноябре 2013 года, когда курс упал с $1000 до $230. Сейчас биткоин равен $450. Но не все знают, что это не самый большой скачок, через который прошел Bitcoin. За 2 года до этого биткоин с 30 долларов обвалился до 25 центов. В относительных показателях это было более значительным событием и намного большим обвалом. Биткоину потребовалось почти 2 года, чтобы оправится от этого. Но это был второй по величине скачок, потому что наибольший скачок был, когда он превратился из тысячной пенни в доллар. Тогда свершилось настоящее рождение биткоина. Равенство этих валют казалось практически недостижимым. Доллар за биткоин — было пределом мечтаний. Ничего подобного раньше не случалось.В будущем будет по крайней мере еще 3-4 скачка, уверен Андреас. Биткоин не будет стабильным, потому что каждый раз, когда к нему опять возвращается внимание, его курс стремительно растет и, поскольку обычно этот курс обычно не удается поддерживать, курс биткоина опять падает. Это «американские горки», и они будут продолжаться еще 3-4 года, как это было с интернетом. Единственное серьезное отличие — у интернета не было биржевой цены, на которую бы все обращали внимание.Схожей точки зрения придерживается и Бобби Ли, CEO китайской биржи BTCC. Предыдущие рыночные паттерны указывают на новое длительное повышение цены биткоина. Резкий рост стоимости Биткоина в течение всего нескольких дней, по мнению ряда экспертов, указывает на формирование нового пузыря, который может быть еще более эффектным, чем предыдущий, когда курс криптовалюты перевалил за $1000.Биткоин-стартапы2015 год стал отправной точкой для многих стартапов, работающих в сфере блокчейна. На самом деле их стало так много, что некоторые эксперты и вовсе прогнозируют «закат стартапов», объясняя свою точку зрения тем, что на всех попросту не хватит денег. По мнению руководителя Digital Currency Group Барри Силберта, в наступающем году многие будут вынуждены сойти со сцены в том числе и потому, что потребительское принятие биткоина происходит не так быстро, как ожидалось. Волатильность курса биткоина также не способствует его повседневному применению.Безусловно, эксперты правы, в их словах есть логика. Но мы настроены не столь критично. Конкуренция и вытеснение — обычные реалии рынка. «В живых» остаются самые сильные и полезные проекты. А неконкурентоспособные стартапы, закрываясь, дают дорогу новым идеям, и те в свою очередь начинают собственную борьбу.Вот несколько блокчейн-стартапов и разработок, привлекших к себе внимание в 2015 году:Австралийский стартап Brighton Peak запустил собственную биткойн-биржу, которая должна стать флагманским продуктом молодой компании. В разработке биржи была задействована технология американской компании AlphaPoint, занимающейся разработкой решений на основе блокчейна для хранения, отслеживания и трейдинга цифровых активов. Технология способна обеспечить обработку 1 млн транзакций в секунду.Криптовалютный сервис Pure Central анонсировал запуск мультивалютной платформы на основе P2P, на которой можно будет получить или выдать кредит в криптовалюте. Заемщики смогут получить кредит в той криптовалюте, в которой им это удобно, под 0,75%. Уже сейчас платформа поддерживает 7 различных криптовалют — биткоины, лайткоины, пиркоины, догкоины, неймкоины, дарккоины и авроракойны. В будущем их число будет расти.Файлообменник Sia запускает облачную платформу для хранения файлов на основе технологии блокчейн. Файлы на этой платформе будут шифроваться алгоритмом Twofish. Данные разбиваются на фрагменты, каждый из которых увеличивается до 4 мегабайт, шифруется и передается одному из многочисленных хостов. При этом вероятность доступа к информации пользователя посторонним лицом практически исключается, так как ни один из хостов, хранящих фрагменты данных, не имеет целого файла.Компания BitReady запустила платформу для обмена долларов на биткоины в процессе покупки товаров. Покупатель выбирает «оплату в биткоинах» и отправляет счет компании BitReady. Она принимает доллары и направляет эквивалентную сумму в биткоинах продавцу от лица покупателя. Комиссия при этом взиматься не будет, утверждают в компании. Тем самым покупатель сможет сэкономить на транзакции до 5%. Стартап берет на себя риски, связанные с использованием биткоина. Кроме этого, BitReady дает возможность приобретать товары за криптовалюту тем, у кого нет криптовалютных сбережений. В настоящее время сервис доступен лишь в нескольких штатах США, но в будущем география будет расширена.Stampery, испанский стартап, созданный для нотариального заверения документов в блокчейне. Сервис может быть полезен всем, кто работает с документами персонального характера: юристам, защитникам интеллектуальной собственности и авторских прав. Все документы, заверенные в Stampery, остаются в распределенной учетной книге и не могут быть изменены или удалены, тем самым подтверждается их подлинность. Вместе с тем стоимость заверение в распределенной сети в разы ниже аналогичных услуг нотариуса. Так, каждый пользователь сможет бесплатно загружать до 10 документов в месяц. Заверение большего числа документов обойдется в 9,9 долларов.BitHappy — первый в мире Bitcoin браузер для электронной коммерции. Стартап создан для продажи и покупки товаров и услуги за биткоины. Для того чтобы продать товар через BitHappy, пользователю понадобится добавить фото и описание товара, указать контактные данные, адрес сайта, на котором выставлен товар, а также указать его стоимость в местной валюте. BitHappy автоматически сконвертирует цену в биткоины по среднему курсу на момент публикации объявления. Выставить товар на продажу сможет любой желающий. BitHappy может использоваться и как дополнительный инструмент продаж в обычных торговых точках.Tixie — устройство, напоминающее электронный будильник, на экране которого отражается текущая цена биткоина, балансы двух кошельков, время и температура воздуха. Новинка не очень полезная, но достаточно забавная, устройство может стать отличным подарком поклоннику криптовалюты. Гаджет создан канадским стартапом Real Coin Tickers (RTC). Как заявляют разработчики: «мы создали устройство, которое превращает взаимодействие с деньгами в уникальное и забавное занятие».Plutus — лондонский стартап, помогающий покупателям расплачиваться в магазине биткоинами, даже если продавец не принимает их. Специальное мобильное приложение позволит оплачивать покупки биткоинами в любом кассовом терминале, оснащенном технологией NFC. Покупатель оплачивает покупку биткоинами, далее биткоины обмениваются на обычную валюту через децентрализованную биржу Plutus DEX, и в конце продавец автоматически получает те деньги, которые он готов принимать.OpenBazaar — децентрализованная альтернатива eBay, сайт-рынок с открытым исходным кодом. В сравнении с традиционными сайтами-рынками контролировать его будет сложнее, т.о. пользователи смогут свободнее распоряжаться своими данными. Кроме того продавцы смогут взаимодействовать с покупателями напрямую, без посредников. Расчеты будут осуществляться в биткоинах.Канадская компания Coinkite запустила новый сервис для массовой рассылки биткоинов «Multisend», который позволит отправлять криптовалюту одновременно на 1000 адресов, отслеживать их и устанавливать предпочтительный объем сбора. Компания представлена на рынке с 2013 года. Ее ежемесячный объем транзакций достигает 400 тысяч BTC.Компания 21 Inc. выпустила «21 Bitcoin компьютер» — компьютер со встроенной аппаратной и программной поддержкой протокола Bitcoin. предприниматели и разработчиком могут продавать и/или покупать электронные товары и услуги непосредственно из командной строки, а также использовать его для майнинга биткойнов через командную строку, создания собственных API, организации собственных онлайн-магазинов электронных товаров и т.д. Все это возможно благодаря встроенному майнинговому чипу и встроенному серверу для микроплатежей.Инвестиции в блокчейнИнвестиции в биткоин-проекты в 2015 году превысили отметку в миллиард долларов. Инвестировать стало проще. Большие финансовые компании — NASDAQ, American Express, MasterCard и Visa — участвуют в работе биткоин-стартапов.Не так давно калифорнийский стартап Purse.io получил финансирование в размере $1 млн. Раунд возглавил Барри Силберт, руководитель Digital Currency Group. Purse.io представляет собой децентрализованную торговую платформу.В октябре 2015 года MasterCard наряду с канадским банком CIBC, венчурным фондом TransAmerica Ventures, страховой компанией New York Life и другими инвесторами вложились в Digital Currency Group. Компания была создана в результате слияния Bitcoin Opportunity Corp, Genesis Global Trading и Grayscale Investments в 2015 году.Компания Bitwage получила $760 тыс. Собранные средства стартап направит на освоение европейского рынка и укрепление своих международных позиций. Напомним, Bitwage — специализированная платформа, позволяющая работодателям начислять зарплату своим сотрудникам в биткоинах. При выдаче получателю, средства могут быть переведены в национальную валюту.В октябре 2015 года член британского парламента Харриет Болдуин от лица правительства Великобритании заявила о готовности правительства инвестировать в исследование и развитие блокчейна ?10 миллионов. По словам Болдуин, на долю Великобритании приходится 42% всех европейских инвестиций в новейшие финансовые технологии, благодаря чему в 2014 году ВВП страны вырос на 20 миллиардов фунтов стерлингов. В сентябре 2015 года Nasdaq, Visa и ряд других ведущих представителей финансовой индустрии вложили $30 млн в биткоин-стартап Chain. Компания занимается созданием инфраструктуры для организации торговли и передачи цифровых активов на основе блокчейна. Помимо Visa и Nasdaq в числе инвесторов оказались Citi Ventures — венчурное подразделение Citigroup, оператора связи Orange, ведущий провайдер финансовых технологий Fiserv и банк Capital One. Еще один инвестор Chain — RRE Ventures в лице основателя Джима Робинсона — вошел в совет директоров Chain.Сервис денежных переводов Abra, построенный на основе блокчейна, получил $12 млн в рамках Серии А инвестиций. В числе инвесторов оказался венчурный фонд American Express. Собранные средства пошли на запуск собственного приложения Abra — Abra Pay.В июле 2015 года голландская биткоин-компания BitFury сообщила, что привлекла $20 млн. В третьем по счету раунде инвестиций участие приняли iTech Capital, Georgian Co-Investment Fund и DRW Venture Capital. Сразу после этого BitFury объявила об открытии нового раунда инвестиций для строительства нового дата-центра в Грузии.Еще одна блокчейн-компания Factom получила $400 тыс. от Kuala Innovations. Разработки Factom направлены на оптимизацию финансовой деятельности и документооборота коммерческих компаний через блокчейн. Factom стал вторым инвестиционным приобретением Kuala в блокчейн секторе.Прогноз на 2016 годКак известно, раз в 4 года объем криптовалюты, который майнеры могут получить каждые 10 минут, уменьшается вдвое. Очередное такое сокращение придется на лето будущего, 2016 года. После деления каждые 10 минут майнеры смогут получить только 12,5 биткоинов.Что еще ожидает биткоин-сообщество в 2016 году? В следующем году будет принято окончательное решение о величине максимального размера блока Bitcoin. Дискуссия на эту тему ведется уже 2 года. Возникла она во время «пузыря» 2013 года, когда ограниченная пропускная способность сети с размером блока 1 Мб стала очевидной.Интерес к Bitcoin не угаснет. Крупные банки и финансовые компании продолжат исследовать биткоин, технологию блокчейн и возможности их применения. Заинтересованность правительства в блокчейне в разных странах также будет расти.Что же касается курса биткоина, в будущем году ожидается его укрепление. Некоторые эксперты делают осторожный прогноз, называя в качестве возможного средний курс в $400. Конечно, давать какие-либо точные прогнозы никто не решается. Также сложно спрогнозировать и потребительский интерес к криптовалюте. Но с учетом возможной стабилизации курса биткоина и выхода множества новых продуктов, способных упростить работу с криптовалютой на бытовом уровне и обещающих значительную экономию на международных транзакциях, перспективы видятся достаточно радужными.Спрос на биткоин будет расти в самых разных сферах. Особенно востребованным он будет на рынке микроплатежей и денежных переводов. По данным компании Wedbush, в течение 10 ближайших лет Биткоин возьмет на себя до 10% онлайн-платежей, 20% микроплатежей и 20% денежных переводов. Если эти прогнозы сбудутся, доля криптовалюты на финансовом рынке может достичь $600 млрд.Статья подготовлена специально для корпоративного блога Web-payment.ru — проекта о платежах, blockchain и e-commerce. Если вам требуется подключить прием платежей или массовые выплаты на сайте, мобильном приложении или даже в офлайне — обращайтесь! Также мы оказываем комплексные услуги по разработке, продвижению и контент-сопровождению. С наступающими праздниками всех!
matbea;Intel исследует потенциал blockchain-технологии;Блог компании Матби Криптовалюты;"Производитель чипов Intel — один из последних крупных производителей, который проводит исследование blockchain-технологии, поместил объявление о приеме на работу разработчиков в области шифрования, в том числе и для работы над децентрализованным реестром.

В основе конкурса заложена тема биткоина как валюты, в то же время, blockchain-технология вызывает большой интерес у центральных банков, учреждений финансовых услуг и технических титанов.

На прошлой неделе Агентство Рейтер сообщило, что IBM провела неофициальные обсуждения со многими центральными банками о создании цифровой платежной системы на базе blockchain-технологии.";/ru/company/matbea/blog/374771/;Производитель чипов Intel — один из последних крупных производителей, который проводит исследование blockchain-технологии, поместил объявление о приеме на работу разработчиков в области шифрования, в том числе и для работы над децентрализованным реестром.В основе конкурса заложена тема биткоина как валюты, в то же время, blockchain-технология вызывает большой интерес у центральных банков, учреждений финансовых услуг и технических титанов.На прошлой неделе Агентство Рейтер сообщило, что IBM провела неофициальные обсуждения со многими центральными банками о создании цифровой платежной системы на базе blockchain-технологии.Intel твердо стоит на ногах, помещая объявление о поиске разработчиков, которые были бы готовы присоединиться к специальной инновационной группе, целью которой является «исследование возможностей аппаратного и программного обеспечения, способствующее прогрессу, использующая надежность и масштабируемость открытого децентрализованного реестра».В рекламном объявлении Intel делает акцент на «фундаментальные технические инновации в сфере биткоина и blockchain-технологии», которые «позволяют не только производить обмен биткоинами, но и способствуют его обороту, также целью разработчиков является исследование цифровых рынков».Фирма приглашает любого, имеющего ученую степень, а также специалистов в информатике, вычислительной технике или смежных областях. Готово предоставить работу в «Хилсборо (Орегон, США)», где они будут заняты решением вопросов по «ультрасовременным, шифровальным алгоритмам на базе открытого децентрализованного реестра».Источник
info_habr;Как мы сделали не blockchain;Блог компании МТС Децентрализованные сети Разработка мобильных приложений *Разработка под Android *Kotlin *;"Как с помощью smart-contract мы построили систему отбора лучших технологических проектов в ИТ МТС? И в какие «ловушки» мы попали, но смогли выбраться, доказав в итоге, что вести распределенный реестр на мобильных устройствах возможно!



Для чего понадобилась система на основе blockchain?
Начнем с самого начала. В МТС есть давняя традиция – выбирать лучший технологический проект, сделанный за год, и награждать его команду. Команда получает призы, уважение и славу. За долгие годы победителями становились различные проекты: от высоконагруженных телеком-систем до систем искусственного интеллекта. 

Выборы лучшего проекта всегда происходили в несколько этапов: 


Команды подают заявки 
Проходит голосование уважаемых технических экспертов 
После экспертов проекты отбирают руководители 
По завершению всех этапов большой начальник выбирает лучший проект. 

Мы решили, что данная схема недостаточно прозрачна для участников и подумали: почему бы не дать возможность выбирать лучший технологический проект абсолютно всем экспертам в компании?";/ru/company/ru_mts/blog/504058/;"Как с помощью smart-contract мы построили систему отбора лучших технологических проектов в ИТ МТС? И в какие «ловушки» мы попали, но смогли выбраться, доказав в итоге, что вести распределенный реестр на мобильных устройствах возможно!Для чего понадобилась система на основе blockchain?Начнем с самого начала. В МТС есть давняя традиция – выбирать лучший технологический проект, сделанный за год, и награждать его команду. Команда получает призы, уважение и славу. За долгие годы победителями становились различные проекты: от высоконагруженных телеком-систем до систем искусственного интеллекта. Выборы лучшего проекта всегда происходили в несколько этапов: Команды подают заявки Проходит голосование уважаемых технических экспертов После экспертов проекты отбирают руководители По завершению всех этапов большой начальник выбирает лучший проект. Мы решили, что данная схема недостаточно прозрачна для участников и подумали: почему бы не дать возможность выбирать лучший технологический проект абсолютно всем экспертам в компании? ? Если мы реализуем такую возможность прямо в телефоне, то будем видеть текущий рейтинг проектов и кто за кого голосует — это обеспечит полную прозрачность процесса. Мы прочитали несколько статей про blockchain, и идея построения системы распределенного реестра прочно осела у нас в головах. А что если и нам применить тут smart-contract?Нас привлекли следующие свойства: открытость – нет единого сервера, где можно манипулировать информацией;информация, помещенная в распределенный реестр, остается там навсегда;информацию нельзя подделать (ну… практически) Не blockchain Сам blockchain применять для таких выборов не стоит. Но что, если взять протоколы для построения консенсуса в распределенных системах и применить их к построению консенсуса в человеческих отношениях?С учетом того, что нам придется работать в открытой сети, нужно защититься от невизантийских атак и от подмены информации на устройствах пользователей. Какие альтернативы Самый известный протокол – это PAXOS. В нем отсутствует явный лидер, и все изменения проходят через двухфазный commit. Вначале каждого изменения происходит Propose. Если он прошел успешно, то посылается Accept (принятие изменений).? Особенностью алгоритма можно назвать то, что он использует глобальные таймеры для определения, какой запрос сформирован раньше и то, что узел, вносящий изменения, должен общаться со всеми узлами сети. Подробнее об алгоритме — здесь.Алгоритм много где применяется, например, в СУБД Cassandra. Данный протокол нам не понравился с точки зрения сложности его реализации под задачу. Но второй вариант нам подошел – это RAFT. Фактически это эволюция протокола PAXOS с явным лидером. Упрощенно протокол можно описать так:·         строится сеть устройств, которые знают друг о друге;·         устройства выбирают среди себя лидера, принимающего «важные решения» (например, о добавлении записи в реестр или изменении состава сети);·         устройство-лидер отвечает за распределение информации по всей сети так, чтобы везде она была идентична;·         как только лидер перестает справляться со своими обязанностями – выбирают нового лидера.Прочитать про протокол можно тут.Наша реализация Что же мы делаем и зачем миру еще один велосипед? ? Практически все пользователи нашего реестра имеют мобильные устройства, которые почти всегда включены и почти всегда в состоянии онлайн, и собственно используют их тоже почти всегда, поэтому мы решили запустить алгоритм распределительного реестра на мобильных устройствах, а не на серверной инфраструктуре, как у других известных реализаций. Давайте посмотрим, в какие «ловушки» мы попали, но смогли выбраться… Ловушка номер 1: «Мой адрес не дом и не улица»«Неожиданно» выяснилось, что для построения P2P-сети, реализующей распределенный реестр с применением протокола RAFT для репликации данных, каждое устройство может общаться друг с другом, а значит является одновременно и клиентом, и сервером. Поэтому нам потребуется публичный «белый» IP-адрес для каждого мобильного телефона (его может и не быть). Количество реальных IPv4 сильно ограничено, поэтому операторы связи применяют технологию NAT (Network Address Translation) в режиме PAT (Port Address Translation), транслируя несколько IP-адресов внутренней сети (которые и раздаются абонентам) в один внешний публичный IP-адрес. Таким образом, исключается возможность принимать входящие соединения из Интернет. Хорошая новость – IPv6 много! ? У нас поддержка IPv6 включена в базовый пакет. Также все современные телефоны поддерживают IPv6, и оператор назначает абоненту публичный «белый» v6-адрес. Наш выбор — IPv6. Ловушка номер 2: Все пошли спатьВ отличие от серверов, мобильные телефоны все-таки иногда выключают. Мы обнаружили это при тестировании первого прототипа. Кроме того, Ipv6-адрес, выдаваемый оператором, публичный, но не статичный, каждая новая сессия связи — новый адрес. Адрес мобильного устройства может измениться в любой момент. И если в сети не останется ни одного телефона с известным нам адресом – она просто перестанет существовать (не к чему подключаться, чтобы ее «нарастить»). Поэтому нам пришлось в какой-то мере нарушить свое правило «никаких серверов». Мы сделали в облаке один специальный узел со статичным известным адресом. Его задача – помнить/актуализировать состав сети и не выключаться. То есть это обычный узел, просто с него никто не голосует, и, обратившись к нему, всегда можно получить актуальный список адресов всех участников сети. Ловушка номер 3: Идентификация и аутентификация ?Надо было как-то решить задачу, чтобы голосовать за проекты могли не все, а те, кому это необходимо. Первая идея была такая: вести базу номеров телефонов экспертов. Но от нее отказались, поскольку не хотели давать приложению права на доступ к этой информации.В итоге сделали все просто: каждый голос, каждую запись в реестре решили снабжать цифровой подписью на модных эллиптических кривых, которая и будет определять подлинность записи. В корпоративной сети разместили WEB-сервис, который по доменной авторизации определял эксперта и генерировал для него уникальный QR-код с открытым и закрытым ключом шифрования (само собой, на клиентской стороне). Эксперт сканировал код из приложения и подключался. После чего на его телефон «накатывалась» текущая актуальная версия реестра и появлялась возможность проголосовать. Ловушка номер 4: Не Android единым ? ?В ходе тестирования почти «внезапно» выяснилось, что некоторые пользователи являются владельцами небезызвестных моделей мобильных устройств, работающих под управлением операционной системы iOS. И стало понятно — программное обеспечение нашего реестра должно выполняться на разных платформах. Мы посмотрели в сторону языка программирования Kotlin, который не только «модный, стильный, молодежный», но еще и мультиплатформенный.Концепт мультиплатформенности в Kotlin подразумевает, что есть часть кода сommon и platform-specific, но поскольку ресурсы нашей команды ограничены, мы поставили перед собой одиозную задачу — использовать единую версию исходного кода под все платформы! Само собой, исполняемый модуль должен быть native под каждую платформу. Кotlin на это оказался способен.Сказано — сделано! Мы имеем один единственный SourceSet с исходным кодом, из которого собираем бинарники под все платформы (!), используя «фитчу» dependsOn. Круто? Очень круто! Ловушка номер 5: Мобильный трафик не бесплатный ?Как же нам наиболее эффективно реализовать взаимодействие между узлами сети так, чтобы не потратить весь трафик абонента и не разрядить батарею мобильного устройства? Мы предполагаем, что сеть может состоять из 1000 и более устройств! Самый очевидный вариант — использовать UDP вместо TCP, например, в процедуре выбора «лидера» или при отправке Heartbeat-ов без данных. UDP более экономный, так как использует простую модель передачи данных, без «рукопожатий» и подтверждений. Отлично! Что еще? Конечно, асинхронный ввод-вывод! Внимательно читаем документацию по Kotlin Native.For all Unix or Windows based targets (including Android and iPhone) we provide the posix platform lib. It contains bindings to platform's implementation of POSIX standard. Затем так же внимательно читаем документацию стандарта POSIX и находим удивительную функцию, позволяющую обрабатывать события сокетов в неблокирующем режиме! Окунувшись с головой в удивительный мир корутин, сокетов и C Interop, мы смогли реализовать очень эффективный транспорт. Супер! А в каком же виде пересылать данные? ?? Конечно же CBOR! Компактный бинарный формат данных, который, по счастливой случайности, реализован в мультиплатформенной бибилиотеке kotlinx.serialization. Просто потрясно! Ловушка номер 6: Сериализация ?На этот раз действительно неожиданно выяснилось, что kotlinx.serialization нет под androidNative (под androidJvm, конечно же, есть). Уважаемые коллеги из JetBrains подтвердили, что на данный момент они не собирают библиотеку под androidNative, и до выпуска Kotlin 1.4 в роадмап места под эту задачу уже нет. ? Что же делать? Если гора не идет к Магомету, Магомет идет к горе!Мы сами собрали kotlinx.serialization под все платформы, в том числе под androidNative! Самое удивительное — все заработало! ? Ловушка номер 7: Где хранить журнал? ? ? Очевидно, в embedded key-value хранилище, но в каком? Мы выбрали libmdbx за компактность кода, скорость, мультиплатформенность, отсутствие WAL-файла. Эта библиотека разрабатывается ребятами из Positive Techlologies и берет начало из легендарной библиотеки LMDB от одного из авторов OpenLDAP Howard Chu. А та, в свою очередь, уходит корнями в реализацию B+tree от Martin Hedenfalk. Кстати, «из коробки» библиотека не собиралась под androidNative. Мы бережно собрали все ошибки, а авторы оперативно предоставили фиксы — за что им отдельная благодарность! Ловушка номер 8: C Interop ?Собрать все это вместе оказалась весьма нетривиальной задачей. Кроме lmdbx и сокетов из posix мы интегрировали библиотеки для формирования\валидации цифровой подписи на эллиптических кривых и вычисления SHA256 с помощью удивительного механизма C Interop. Если простыми словами – из native приложения на Kotlin можно вызвать функцию C-библиотеки, в том числе с указателями на указатели и прочей магией, выглядит это все правда немного странно.Вот, например, вызов getaddrinfo с целью получения sockaddr. Как тебе такое Илон Маск? Линковка С-библиотеки в исполняемый файл Kotlin Native – это отдельный квест, который нам тоже удалось пройти, но не без «костылей». Мы динамически формируем def файл непосредственно в билд-скрипте грэдла, чтобы указывать правильный путь до библиотек относительно корневого каталога проекта и затем подставляем его (def файла) дескриптор в cinterops секцию. В самом же def файле определяется только абсолютный путь, который мало того что может иметь разный формат, если сборка выполняется под разными OS, но собственно на локальных машинах разработчиков, конечно, тоже может отличаться, что очевидно приводит к ошибке во время линковки.Про выборыОсновные выборы мы проводили в течение суток. В тестировании с помощью нашей сети приняли участие чуть больше 20 экспертов. Оценивался 21 проект по 5 категориям, то есть всего в реестр было добавлено более 100 записей с голосами за проекты. ВыводВ результате выполнения этого небольшого исследовательского проекта нам удалось доказать, что вести распределенный реестр на мобильных устройствах – возможно! Это открывает множество возможностей по использованию данной технологии на IoT-устройствах для организации вычислений по принципу Edge-computing. Впереди нас еще ждут испытания на нагрузку, уязвимость к атакам и на отказоустойчивость. Но мы верим, что у нас все получится! Авторы статьи: архитекторы и разработчики R&D Центра МТС Дмитрий Дзюба, Алексей Василенко и Семен Неврев"
cigulev;Как понять нужно ли интегрировать blockchain в ваш продукт?;Блог компании Web-payment.ru Криптография *Анализ и проектирование систем *;"Blockchain технологии в данный момент являются слишком раздутыми. О нем пишут и говорят все: от конференций Sibos и Money20/20 до популярных материалов в изданиях The Economist и Euromoney – кажется, что каждый стремится ухватить свою долю в золотой блокчейн-лихорадке.

Как определить, что у вас реальный случай применения технологии блокчейн? Мы в Web-payment.ru много пишем о технологии распределенного реестра, и по роду деятельности нашего Digital агентства, ориентированного на финтех компании, замечаем, что поднятый вопрос очень актуальный для многих игроков рынка. Эта статья, опубликованная в блоге открытой платформы для создания своих блокчейнов MultiChain, призвана помочь разобраться в этом.";/ru/company/web_payment_ru/blog/301972/;"Blockchain технологии в данный момент являются слишком раздутыми. О нем пишут и говорят все: от конференций Sibos и Money20/20 до популярных материалов в изданиях The Economist и Euromoney – кажется, что каждый стремится ухватить свою долю в золотой блокчейн-лихорадке.Как определить, что у вас реальный случай применения технологии блокчейн? Мы в Web-payment.ru много пишем о технологии распределенного реестра, и по роду деятельности нашего Digital агентства, ориентированного на финтех компании, замечаем, что поднятый вопрос очень актуальный для многих игроков рынка. Эта статья, опубликованная в блоге открытой платформы для создания своих блокчейнов MultiChain, призвана помочь разобраться в этом.Огромное количество приходящих в MultiChain проектов вообще не имеет ничего общего с технологией блокчейн. Все происходит по следующему сценарию. Большая компания узнает о том, что blockchain – это технология будущего. Большая компания находит людей извне, которые работают с банковскими технологиями для обращения криптовалюты биткойн. Большая компания выделяет им бюджет и поручает сделать что-нибудь «блокчейновое». И вскоре эти умельцы приходят к MultiChain и, размахивая деньгами, просят нас помочь им выдумать какой-то сценарий использования. А что не так с теми, у кого действительно есть идея проекта? Очень часто проект может быть замечательно реализован при помощи обычной реляционной базы данных. Это такие железные чудища, как Oracle и SQL Server, а для менее предубежденных – MySQL и Postgres. Так что позвольте начать, расставив все точки над «i»:Если современные реляционные базы данных удовлетворяют вашим требованиям, то нужно быть сумасшедшим, чтобы использовать блокчейн.Почему? Потому что такие продукты, как Oracle и MySQL проверены десятилетиями разработки. Они были установлены на миллионах серверов, обрабатывающих триллионы запросов. Их код был наиболее тщательно тестирован, оптимизирован и отлажен в сравнении с другими на планете Земля. Они, не напрягаясь, обрабатывают тысячи транзакций в секунду.Ну и что у нас с блокчейн? Существуют продукты, которые стали пионерами рынка и отличаются относительной стабильностью. Но несмотря на это, все продукты данной категории, образно выражаясь, все еще сидят в подгузниках. Пытаюсь ли я доказать, что технология блокчейн бесполезна? Никак нет. Но до того, как с разбегу прыгнуть в такой передовой и блестящий блокчейн-проект, вы должны выработать четкое понимание, зачем вы используете блокчейн. Есть несколько условий, которые должны быть выполнены. А если нет, то вам стоит вернуться к этапу проектирования. Может быть, вы могли бы лучше обозначить и детальнее описать проект. Может быть, вам удастся сэкономить для всех тонны времени и средств, потому что технология блокчейн вам вообще не нужна.1. База данныхВот первое правило. Блокчейн – это технология для баз данных общего пользования. Поэтому вам стоит начать с понимания того, зачем вы используете базу данных. Здесь я имею ввиду структурированное хранилище информации. Это может быль традиционная реляционная база данных с одной или более электронными таблицами. Или это могут быть более трендовые базы данных NoSQL, которые работают больше как системы файлов или словари. (В любом случае, в теории базы данных NoSQL являются подмножеством реляционных баз данных.)Регистр для финансовых активов обычно может быть выражен в виде таблицы базы данных, в которой каждая строка представляет один вид активов, принадлежащих одной конкретной сущности. Каждая строка содержит три колонки, содержащие: (а) идентификатор владельца, например, номер счета; (б) идентификатор типа активов, например, «USD» или «AAPL»; (в) количество единиц актива на счету конкретного владельца.Базы данных модифицируются с помощью «транзакций», представляющих собой набор изменений в базе данных, которые должны быть приняты или отклонены. Например, в случае учета активов платеж от одного пользователя к другому представлен транзакцией, которая вычитает соответствующее количество средств из одной строки и добавляет его в другую.2. Множество авторовЭто простое правило. Блокчейн – это технология для баз данных с множеством авторов. Иными словами, должно быть больше одной сущности, которые генерируют транзакции, модифицирующие базу данных. Вы знаете, кто такие эти авторы?В большинстве случаев авторы также будут поддерживать ноды, содержащие копию базы данных, и ретранслировать транзакции другим узлам в пиринговом режиме. Однако транзакции для запуска узла сами также могут быть созданы пользователями, которые не поддерживают ноды. Рассмотрим, например, систему платежей, которая коллективно поддерживается небольшой группой банков, но имеет миллионы конечных пользователей с мобильными устройствами, которые взаимодействуют только с системой выбранного ими банка.3. Отсутствие доверияИ теперь перейдем к третьему правилу. Если несколько сущностей изменяют базу данных, то между ними должно быть определенное недоверие. Другими словами, блокчейн – это технология для баз данных с множеством авторов, не доверяющих друг другу.Можно подумать, что недоверие возникает только между отдельными организациями, такими как банки или компании, участвующие в цепочке поставок. Но недоверие появляется и внутри одной крупной организации, например, между отделами или при совершении операций в различных странах.Что именно я имею в виду говоря об отсутствии доверия? Я говорю о том, что один пользователь не желает, чтобы другой пользователь изменял строки в базе данных, которые «принадлежат» ему самому. Точно так же, когда речь идет о чтении содержимого базы данных, пользователь не будет принимать на веру «правду» другого пользователем, потому что каждый из них имеет различные экономические или политические мотивации.4. Транзакции без посредниковИтак, до сих пор проблема заключалась в том, что к базе данных имеют доступ многочисленные авторы, не доверяющие друг другу. Но имеется хорошо известное решение этой проблемы: доверенный посредник. Это тот, кому доверяют все авторы даже с учетом того, что они не доверяют друг другу. И действительно, в мире полно таких баз данных, и к ним относятся и реестры аккаунтов в банках. Ваш банк контролирует базу данных самостоятельно и следит за тем, чтобы каждая транзакция была валидна и проводилась авторизированным пользователем, средства которого перечисляются со счета на счет. И как бы вежливо вы не просили, ваш банк никогда не позволит вам непосредственно вносить изменения в его базу данных.Блокчейн отсекает необходимость в доверенных посредниках, позволяя множеству не доверяющих друг другу авторов непосредственно вносить изменения в базы данных. Нет никакой инстанции, проверяющей валидность транзакций и аутентичность их источников. Вместо этого определение транзакции расширено и включает в себя доказательство авторизации и доказательство валидности. Таким образом, транзакции могут быть независимо верифицированы и обработаны каждым нодом, который располагает локальной копией базы данных.Но вот вопрос, который вы должны себе задать: хотите ли вы и нуждаетесь ли вы в отказе от посредников? Если взять ваш случай, действительно ли вам мешает центральная организация, которая поддерживает заслуживающую доверия базу данных и действует как посредник в транзакциях? Хорошие причины отказа от доверенного посредника в пользу баз данных блокчейн – это, например, большая экономия средств, более быстрые транзакции, автоматическое согласование счетов или невозможность найти подходящего посредника. 5. Взаимодействие транзакцийИтак, технология blockchain хороша для баз данных с множеством авторов, которые не доверяют друг другу и которые непосредственно изменяют базу данных. Но этого все еще недостаточно. Блокчейн в полной мере окупает себя тогда, когда созданные этими авторами транзакции взаимодействуют между собой.Что я имею ввиду, говоря о взаимодействии? Это когда транзакции, созданные разными авторами, часто зависят друг от друга. К примеру, скажем, Алиса отправляет средства Бобу и затем Боб отправляет средства Чарли. В этом случае транзакция Боба зависит от транзакции Алисы, и нет другого способа проверить транзакцию Боба без предварительной проверки транзакции Алисы. Благодаря этой зависимости вместе эти транзакции принадлежат к единой распределенной базе данных. Развивая данную тему, замечательной особенностью блокчейна является то, что транзакции могут создаваться совместно многими авторами, при этом никто не берет на себя риск. Именно это позволяет решить проблему очередности оплаты без необходимости в доверенном посреднике.Менее наглядный случай взаимодействия – это когда транзакции разных авторов коррелируют между собой, оставаясь независимыми. Одним из примеров может быть распределенная база с личными данными, в которой множество сущностей подтверждает различные аспекты личностей потребителей. Несмотря на то, что каждая из проверок производится отдельно, блокчейн позволяет пользователю объединить все изменения.6. Установка правилЭто не условие, но скорее неизбежное следствие предыдущих условий. Если у нас есть база данных, в которую вносят изменения многие авторы, и эти авторы не доверяют друг другу в полной мере, то эта база данных должна предусматривать правила, в соответствии с которыми проводятся транзакции.Эти требования существенно отличаются от ограничений, которые есть в традиционных базах данных, потому что они касаются законности преобразований, а не состояния базы данных в конкретное время. Каждая транзакция проверяется каждым узлом в данной сети на соответствие этим требованиям. Те транзакции, которые требованиям не соответствуют, отклоняются еще до проведения.Книги для учета активов содержат простой пример этого типа правила, чтобы предотвратить транзакции, создающие активы на пустом месте. Согласно этому требованию, общее количество каждого актива в реестре остается неизменным до и после каждой транзакции.7. Выберите своих валидаторовИтак, мы описали распределенную базу данных, в которой транзакции могут исходить из разных источников, распространяться от одного узла к другому и проверяться каждым узлом независимо. Таким образом, что же делает блокчейн? Здесь работа этой технологии состоит в том, чтобы быть окончательной версией журнала транзакций, заслуживающей доверия, с содержанием которого все узлы согласны, и это можно доказать.Зачем нам нужен этот журнал? Во-первых, это позволяет недавно добавленным узлам вычислить содержание базы данных с нуля и без необходимости доверия другому узлу. Во-вторых, это предусматривает возможность того, что некоторые узлы могут пропустить некоторые транзакции из-за сбоев связи. Без журнала транзакций это стало бы причиной того, что база данных одного узла отличается от других, что противоречит назначению распределенных баз данных.В-третьих, есть возможность того, что две транзакции конфликтуют, и только одна из них может быть принята. Классическим примером этого является двойная трата, при которой одинаковое количество средств отправляется двум разным получателям. В базе данных, функционирующей по пиринговому принципу без центрального администратора, узлы могут иметь разные мнения относительно того, какую транзакцию стоит принять, потому что в данном случае объективного правильного ответа нет. Требуя подтверждения транзакций в блокчейне, мы гарантируем то, что все узлы будут согласны с единым решением.И, наконец, в блокчейнах типа Ethereum точный порядок транзакций играет решающую роль, поскольку каждая транзакция может повлиять на последующую. В этом случае блокчейн определяет хронологию событий, без которых транзакции не могут быть обработаны.Блокчейн – это цепь блоков, в которой каждый блок содержит набор транзакций, подтверждаемых как группа. Но кто несет ответственность за выбор транзакций, которые идут в каждом блоке? Для «частных блокчейнов», которые подходят для корпораций, это закрытая группа валидаторов (майнеров), оставляющих цифровую подпись в создаваемых ими блоках. Этот белый список совмещается со схемой распределенного консенсуса для того, чтобы предотвратить получение контроля над блокчейном меньшинством валидаторов. Независимо от того, какая используется схема консенсуса, узлы-валидаторы имеют гораздо меньше власти, нежели администраторы традиционной централизованной базы данных. Валидаторы не могут подделать транзакцию или модифицировать базу данных в разрез правилам. Когда речь идет об учете активов, это значит, что они не могут потратить деньги других людей или изменить общее количество представленных активов. Тем не менее, все же есть два случая, когда валидаторы могут ненадлежащим образом повлиять на контент базы данных:Цензурирование транзакций. Если достаточное количество валидаторов вступят в сговор, то они могут предотвратить подтверждение конкретной транзакции в блокчейне, постоянно оставляя ее в пуле неподтвержденных транзакций.Предвзятое урегулирования конфликтов. Если две транзакции конфликтуют, то следующий блок валидатор решает, какая транзакция в блокчейне будет принята, а какая в результате этого будет отклонена. Справедливый выбор – это транзакция, которая появилась ранее, но валидаторы могут основывать свой выбор на других факторах, не выказывая этого.Из-за этих проблем при развертывании блокчейн-базы данных вы должны иметь четкое представление о том, кто ваши валидаторы и почему вы доверяете им. В зависимости от случая, валидаторы могут быть выбраны в качестве: (а) одного или нескольких узлов, управляемых с помощью единой организации, (б) основной группы организаций, которые поддерживают цепь, или (с) каждого узла сети.8. Обеспечивайте свои активыЕсли вы дочитали до этого места статьи, то вы могли заметить, что я скорее отношу блокчейны к распределенным базам данных, нежели к «распределенным учетным книгам», что является более привычным. Почему? Потому что как технология блокчейн может быть применена к проблемам, лежащим за границами отслеживания прав собственности на активы. Любая база данных, которая имеет множество не доверяющих друг другу авторов может быть реализована посредством блокчейн без необходимости в доверенном посреднике. Среди примеров можно назвать распределенные календари, форумы и совместные проекты типа «Википедии».В настоящий момент блокчейны в основном представляют интерес для тех, кто отслеживает движение финансовых активов. На мой взгляд, этому есть две причины: (а) финансовый сектор отвечает на (пока очень незначительную) угрозу таких криптовалют, как биткойн, и (б) книга учета активов является наиболее простым и естественным примером распределенной базы данных с взаимозависимыми транзакциями, создаваемыми множеством сущностей, не доверяющих друг другу.Если вы хотите использовать блокчейн для учета активов, необходимо ответить на еще один важный вопрос: какова природа этих активов? Я не имею в виду наличные, облигации или коносаменты, хотя это тоже очень важно. Вопрос скорее в том, кто стоит за активами, представленными в блокчейне? Если в базе есть информация о том, что мне принадлежит 10 единиц чего-то, кто позволит мне претендовать на эти 10 единиц в реальном мире? На кого я могу подать в суд, если не смогу преобразовать то, что у меня есть в блокчейне в традиционные физические активы? (См. пример соглашения об активах)Конечно же, ответ на этот вопрос зависит от конкретного случая применения. К примеру, для денежных активов банки-кастоди могут принимать наличные в традиционной форме и затем зачислять средства на аккаунты пользователей в распределенной системе учета, созданной на базе блокчейна. В сфере финансирования торговли аккредитивы и коносаменты могут быть обеспечены банком импортера и транспортной компании соответственно. Вероятно, что в более отдаленном будущем основной выпуск корпоративных облигаций будет осуществляться непосредственно с помощью блокчейна компанией, стремящейся привлечь средства.ЗаключениеКак я уже упоминал во вступлении, если ваш проект не удовлетворяет хотя бы одному из этих критериев, вам не следует использовать блокчейн. Если не выполнено одно из первых пяти условий, то вам стоит использовать что-либо из следующих решений: (а) обычное файловое хранилище, (б) централизованная база данных, (в) реплицированная база данных, (г) несколько баз данных с подпиской для пользователей.И если первые пять условий выполнены, это еще не все — вам нужно будет обозначить правила вашего приложения в терминах транзакций, разрешенных базой данных. Вы должны быть уверены в своих валидаторах и в своем механизме распределенного консенсуса. И наконец, если вы собираетесь создать распределенную систему учета активов, вы должны знать, кто обеспечит эти активы."
ITinvest_team;Цифровые ценные бумаги: Как Blockchain изменит будущее биржевой торговли;Блог компании ITI Capital Финансы в IT Криптовалюты;В декабре 2015 года американская Комиссия по ценным бумагам (SEC) одобрила заявление компании Overstock.com по выпуску акций через интернет — то есть цифровых акций (digital securities). Как считают многие эксперты и представители медиа, это событие в перспективе может подорвать доминирующее положение финансовых компаний Уолл-Стрит, а также сделать процесс выхода на IPO более доступным для небольших компаний (о том, как он устроен сейчас мы недавно писали).;/ru/company/iticapital/blog/371623/;В декабре 2015 года американская Комиссия по ценным бумагам (SEC) одобрила заявление компании Overstock.com по выпуску акций через интернет — то есть цифровых акций (digital securities). Как считают многие эксперты и представители медиа, это событие в перспективе может подорвать доминирующее положение финансовых компаний Уолл-Стрит, а также сделать процесс выхода на IPO более доступным для небольших компаний (о том, как он устроен сейчас мы недавно писали).Что это такоеЗа прошедший год компания Overstock Inc под руководством своего CEO Патрика Берна (Patrick Byrne) разработала способ по выпуску акций с помощью технологии Blockchain, на основе которой работает криптовалюта биткоин. Под цифровыми акциями понимаются «бездокументарные, зарегистрированные ценные бумаги, права собственности на которые и факт передачи которых удостоверяются путем внесения записи в защищенный доступный публично регистр». Достоверность публичных копий этого регистра может быть математически подтверждены с помощью технологии Blockchain.Как сказано в документации Overstock Inc., компания планирует разместить различные «классические» ценные бумаги (акции и облигации), в том числе и в виде цифровых ценных бумаг. Ранее Overstock уже провела размещение частных облигаций, для чего не требовалось одобрение регулирующих органов. Теперь SEC разрешила компании точно таким же образом выпускать публичные финансовые инструменты.Overstock планирует использовать свою технологию в качестве сервиса, позволяющего различным компаниям выпускать акции и привлекать финансирование без необходимости выхода на традиционный фондовый рынок. Каждой такой компании на первом этапе потребуется отдельное разрешение регулятора, но Overstock имеет право предлагать технологию для выпуска акций третьих компаний еще до того, как таким же образом выпустит собственные.Особенности работыНа текущем этапе можно отметить два интересных момента в описанной схеме работы технологии Overstock. Прежде всего, в документации говорится о том, что в случае возникновения противоречий между копиями децентрализованного регистра сделок, приоритет будет иметь копия, поддерживаемая платформй компании (ATS). В традиционной парадигме Bitcoin подобное невозможно — в ее основе лежит принцип консенсуса, согласно которому решения принимаются большинством, и ни у кого из участников сети нет права решающего голоса.Также доступ к секретным ключам держателей ценных бумаг, помимо самих пользователей будет иметь компания Overstock, платформа ATS и дилер DriveWealth, через которого и планируется размещение ценных бумаг на платформе ATS. Таким образом, в отличие от криптовалют, при использовании цифровых акций ни о какой анонимности покупателя и продавца не может идти и речи.Чем это грозит Уолл-СтритБерн убежден, что его технология «может сделать для финансового рынка то же самое, что интернет сделал для покупателей». Она позволит компаниям получить надежный, безопасный и прозрачный способ автоматического отслеживания того, кто именно владеет их акции в конкретный момент времени. По мнению предпринимателя, его система однажды сможет заменить торговые площадки Нью-Йоркской фондовой биржи и Nasdaq.Для торговли цифровыми акциями Overstock хочет создать отдельную торговую систему (ATS, alternative trading system), которая будет подчиняться правилам SEC. В 2014 году Берн заявлял о намерении создать децентрализованную торговую площадку под названием Medici. С ее помощью будет возможна торговаля криптоакциями, выпущенных самой Overstock и другими компаниями. В мае 2015 года Overstock купила долю в 25% в компании PRO Securities, разрабатывающую одноименную альтернативную торговую систему.По задумке Берна, его проект поможет убрать из процесса покупки акций всевозможных посредников, которые всегда правили бал на рынке. Кроме того, технология Blockchain должна позволить закрыть многие слабые места сегодняшнего финансового рынка. Как сказал Берн в разговоре с изданием Wired: «Сегодня есть множество способов обмануть рынок, мы хотим сделать это невозможным». Важным моментом здесь будет являться тот факт, что покупатель ценных бумаг сможет узнать всю историю их владения.Также для американских и европейских бирж традиционным является схема, при которой поставка купленных ценных бумаг осуществляется на третий день после сделки — она носит название T+3. Технология же Overstock носит название t?, что намекает на тот факт, что регистрация права собственности на приобретенные акции будет осуществляться в тот же день.Возможные проблемыПоявление децентрализованной торговой площадки для торговли цифровыми акциями вызывает опасения у некоторых представителей финансового рынка. Многих из них беспокоит, что в этой схеме отсутствует процесс клиринга, то есть подтверждения транзакции, авторизованной для этого организацией. История биткоин позволяет предположить, что эти опасения не подтвердятся на практике, поскольку технология майнинга позволяет надежно подтверждать транзакции. Кроме того, отсутствие организации, производящей клиринг позволит избавить пользователей от необходимости уплаты соответветсвующих комиссий.Однако не раз и не два на биткоин-биржах случались сбои и различные проблемы, оставлявшие пользователей в конечном итоге без их денег. Криптовалюта сама по себе может быть вполне защищенным инструментом, но владельцы такой валюты могут быть защищены очень слабо. Кроме того, хоть это и довольно забавный момент, процесс передачи криптоакций от держателя к держателю, на самом деле, может быть медленнее, чем на традиционном фондовом рынке. Сегодняшние торговые системы бирж работают очень эффективно и позволяют осуществлять сделки практически мгновенно. В случае распределенной системы на ее полное подтверждение может уйти до нескольких минут — зато в отличие от традиционных рынков с их схемой T+3 в случае цифровых акций их поставка будет осуществляться мгновенно.В настоящий момент довольно трудно предположить судьбу инициатив подобных Overstock, в США и тем более в других странах, например в России. Что касается нашей страны, то сами криптовалюты и технологии, благодаря которым они работают, в нашей стране не запрещены, и законов, наказывающих за использование таких «денежных суррогатов» пока не вводилось. Однако вероятность применения новых финансовых технологий на нашем рынке будет во многом зависеть от того, насколько успешным окажется опыт первопроходцев.
5aava;Уязвимости EOS Blockchain на ZeroNights 2018;Блог компании Digital Security Информационная безопасность *C++ *;В рамках данной статьи будут рассмотрены несколько реальных уязвимостей в EOS blockchain (одном из конкурентов Ethereum) и то, как они были встроены в конкурс New-Generation Secure Slot Machine на ZeroNights 2018. Если вам интересно познакомиться с тем, как обстоят дела с безопасностью в этой сети blockchain, то welcome под кат.;/ru/company/dsec/blog/433552/;"В рамках данной статьи будут рассмотрены несколько реальных уязвимостей в EOS blockchain (одном из конкурентов Ethereum) и то, как они были встроены в конкурс New-Generation Secure Slot Machine на ZeroNights 2018. Если вам интересно познакомиться с тем, как обстоят дела с безопасностью в этой сети blockchain, то welcome под кат.ВступлениеВсе началось с того, что недавно, во время аудита смарт-контрактов Etherium на безопасность, один наш знакомый скидывает нам статейку про уязвимости в смарт-контрактах в сети EOS. Нас это сильно заинтересовало, и мы решили разобраться в уязвимостях более детально. Всё это в итоге и привело к созданию конкурса на ZeroNights 2018 под названием «Однорукий бандит» с уязвимостями в смарт-контракте.Начнем непосредственно с рассмотрения сети блокчейн EOS, как с ним работать, и как у него все устроено внутри. Статей, описывающих технологию, в Интернете много, поэтому, скорее всего, всех технических деталей не будет, но общий смысл мы постараемся передать так, чтобы и обычный пользователь смог получить элементарное представление о механизмах работы blockchain EOS. Описание технологии EOSEOS.io – блокчейн нового поколения от компании Block.one, основанный на концепции PoS (Proof of stake). Из описания самих создателей сети: «EOS — это бесплатное программное обеспечение сети блокчейн с открытым исходным кодом, который предоставляет разработчикам и предпринимателям платформу для создания, развертывания и запуска высокопроизводительных децентрализованных приложений (DAPP).»Если в двух словах попытаться объяснить концепцию, то её хорошо отражает выдержка из статьи на Википедии:Идея proof-of-stake (PoS) заключается в решении проблемы proof-of-work (PoW), связанной с большими тратами электроэнергии. Вместо вычислительных мощностей участников, имеет значение количество криптовалюты, находящейся у них на счету. Так, вместо использования большого количества электроэнергии для решения задачи PoW, у участника PoS ограничен процент возможных проверок транзакций. Ограничение соответствует количеству криптовалюты, находящейся на счету у участника Сеть совсем новая, и первый запуск главной сети (mainnet) состоялся 10 июня 2018 года. Основной крипто-валютой является EOS, а главный портал для разработчиков developers.eos.ioБлокчейн EOS.io поддерживает приложения, созданные пользователями с использованием кода WebAssembly (WASM) – нового веб-стандарта с широкой поддержкой крупных компаний, таких как Google, Microsoft, Apple и других.На данный момент наиболее свежим инструментарием для создания приложений, которые компилируют код в WASM, является clang / llvm с их компилятором C / C ++. Для лучшей совместимости разработчики рекомендуют использовать EOSIO CDT (Contract Development Toolkit) – набор утилит от самих разработчиков для удобной и корректной работы над созданием смарт контрактов. Предыдущий компилятор eosiocpp уже deprecated и не поддерживается, поэтому всем рекомендуется переходить на новый (на момент написания статьи) EOSIO CDT 1.5.В отличие от эфираЭфир в своей концепции использует PoW (Proof of Work), что требует дорогостоящих вычислений и награду получает тот, кто первый решил математическую задачу. То есть те, кто решал параллельно, но не успел решить, попусту затратили электроэнергию. В этой ситуации майнеры воюют между собой за более совершенные технологии и оборудование. Чтобы быстрее генерировать блоки и, тем самым, зарабатывать. В отличие от Эфира в сети ЕОС по концепции PoS создателя нового блока выберет система, и определяется это по количеству личного состояния – доли от общего количества криптовалюты. Таким образом, у кого больше состояние, у того больше шансы быть выбранным системой. Но в отличие от PoW (эфира) вознаграждение за генерацию нового блока отсутствует в принципе, и доход майнеров составляют исключительно комиссии с транзакций.Вывод — криптовалюты на базе PoW могут быть в 1000 раз более энергоэфективными.Разворачиваем среду разработкиТак, с теорией вроде покончили, переходим к практике. А на практике всё выглядит гораздо интереснее. С документацией на момент, когда пытались разобраться летом и начать что-то делать для ZeroNights 2018, было всё совсем плохо, а основной портал для разработки глючил, был наполовину пуст и иногда даже не работал.Тестовые сети еще толком не были запущены, поэтому пришлось разворачивать свою ноду. Кстати, в отличие от мнения в интернете, завести ее оказалось не так сложно. Пользуясь официальной документацией, мы запустили ее из докера developers.eos.io/eosio-nodeos/docs/docker-quickstartРасскажем о основных утилитах, программах для работы с блокчейном EOS, с которыми пришлось иметь дело в момент работы над конкурсом:Nodeos – собственно, служба самой ноды EOSIO; можно конфигурировать и настраивать различные плагины, например CORS, history и другие.Cleos – консольная утилита для работы с нодой, вызовов методов контрактов и взаимодействия с кошельком, ключами, доступами. Самый частый инструмент при работе с EOS.Keosd – консольный кошелек, или точнее тоже служба кошелька, хранилище приватных ключей.Eosio.cdt – Contract Development Toolkit, так называемый набор утилит разработчика для отладки и компиляции контрактов, генерации ABI-файлов и не только.Eos.js – Библиотека Javascript API для удобной работы с нодой и контрактами через веб, встраивается на сайт.Scatter – десктоп кошелек для надежного хранения ваших ключей аккаунтов. Существует веб-библиотека scatter.js, которая взаимодействует с десктопным кошельком Scatter по веб-сокетам и тем самым помогает работе с DAPP приложениями в браузере.Уфф!.. Да, программок много, разобраться в них тоже не совсем легко. Описание всего этого заслуживает отдельного поста и выходит за рамки данной статьи. Но давайте представим, что мы установили ноду на свой сервер и даже научились при помощи cleos вызывать методы контракта, если бы он у нас был. Да, самое главное. Надо бы нам набросать сам смарт-контракт. Писать мы его будем на C++ и, чтобы сделать хоть что-то толковое, пришлось прочитать немало документации.Для понимания контрактов везде приводят пример контракта Hello. Основным файлом является hello.cpp и весь контракт описан в нем#include using namespace eosio;class hello : public eosio::contract {  public:      using contract::contract;      /// @abi action       void hi( account_name user ) {         print( ""Hello, "", name{user} );      }};EOSIO_ABI( hello, (hi) )Если в двух словах постараться объяснить, то тут – всё просто. Подгружаем библиотеку eosio.hpp, затем создаем класс (он же контракт) hello и унаследуем класс contract. Создаем void метод hi и в параметры заносим переменную user c типом account_name, он же uint64_t. В методе выводим “Hello, ” и имя, которое мы укажем при вызове метода. Последняя строчка, где находится EOSIO_ABI –это вспомогательный макрос, который принимает наш класс и общедоступные методы из этого класса, а также участвует в формировании файла .abi, где указываются все общедоступные методы контракта.Изучаем уязвимостиИтак, в рамках той статьи, описывалось несколько уязвимостей – давайте их сейчас рассмотрим подробнее.Numerical Overflow – численное переполнениеПри вызове контракта нода проверяет тип параметра, и если данные, которые мы пытаемся ей скормить, не подходят, то нода начнет ругаться и такое бесчинство не пропустит. НО! Если внутри контракта есть какой-нибудь алгоритм изменения числа, сумма чисел или, допустим, умножение, то число может измениться уже внутри контракта. А это значит, что можно указать такое число, которое нода пропустит, а вот контракт умножит, и число выйдет за рамки допустимого типа данных, что и приведет к переполнению. Что это может дать? К примеру, есть проверка на какой-то числовой параметр, допустим, int Number  0, ""must transfer positive balance"");    // Инициализация переменной amount и умножение на 4    // Вот тут и происходит переполнение, и amount становится отрицательным    int64_t amount = balance * 4;      // Поиск в таблице аккаунта from, откуда следует вычитать    int itr = db_find_i64(_self, symbol, N(table), from);    // Проверка, найден ли аккаунт    eosio_assert(itr >= 0, ""wrong name"");    // Добавляение в переменную fromaccount найденного аккаунта    db_get_i64(itr, &fromaccount, (account));    // Проверка, больше ли отправленного баланс из таблицы     // Например, в игре баланс 0.1 EOS    //  и он будет больше, чем отрицательное значение amount    eosio_assert(fromaccount.balance >= amount, ""overdrawn balance"");    // Функция вычитает     sub_balance(symbol, from, amount);    // Функция отправляет деньги 4 аккаунтам    add_balance(symbol, to.name0, balance);    add_balance(symbol, to.name1, balance);    add_balance(symbol, to.name2, balance);    add_balance(symbol, to.name3, balance);}Взлом скорее всего был осуществлен следующим образом. Злоумышленник предварительно создал 4 аккаунта и вызвал метод batchtransfer напрямую, приблизительно так:cleos push action contractname batchtransfer \'{""symbol "":""EOS"", ""from"":”attacker”, ""to"":{ “name0”:”acc0”, “name1”:”acc1”, “name2”:”acc2”, “name3”:”acc3”}, ""balance"":""111111111111111111 EOS""}' -p attacker@activeОговорюсь сразу, это лишь предположение; как точно произвели взлом – мы не знаем, и если будут другие мысли по этому поводу или более точная информация, то пишите в комментариях.Autherization check, проверка на авторизациюОтсутствие проверки метода контракта require_auth() на авторизации пользователя приведет к тому, что любой человек, не обладающий нужными правами, сможет воспользоваться привилегированными методами контракта, например, вывод денег с контракта.Отсутствие проверки прав вызова методаПри отправке на контракт денег (EOS) можно указать в специальном макросе, что будет происходить дальше и что делать. Скажем, при получении денег будет вызываться некий алгоритм, например, запускаться рулетка или еще что-нибудь, а также проверка:if( code == self || code == N(eosio.token) || action == N(onerror) ) { \     TYPE thiscontract( self ); \         switch( action ) { \         EOSIO_API( TYPE, MEMBERS ) \     }}// Отсутствует проверка на action == N(transfer)В этой проверке нет ограничения вызова метода transfer, из-за чего можно метод трансфер вызвать напрямую, без пересылки денег на контракт. А это означает запуск механизма с дальнейшим выигрышем, не тратя ни копейки. Конкурс на ZeroNights 2018Идея конкурса родилась сама по себе: раз всё связано с играми и тремя уязвимостями, следовательно, будем делать игру на механизме смарт-контракта в блокчейне EOS.io. Игра должна быть максимально простой, но интересной.Игровой автомат «Однорукий бандит»! Всегда удивляли люди, жаждущие легкой наживы — помните, халявы в мире не бывает, или почти не бывает. Тут, кстати, она вполне есть, вернее, появится, когда в ход пойдут уязвимости.ФронтендФронтенд игры решили сделать модным, красивым и трехмерным. Спасибо vtornik23, за то, что не отказался поучаствовать и помог нам сделать полностью фронтенд на Unity3d движке. Трехмерный игровой аппарат «однорукий бандит»; отправив на него 1 ЕОС и дернув за шикарный рычаг, игрок получает возможность запустить колесо фортуны и сорвать куш!Уязвимости контрактаПо задумке игры, выигрышем считалось выпадение трёх матрёшек ZeroNights, что в числовом коэффициенте будет либо 777, либо 0.Шансы на выигрыш приравнивались к 0.02%, и некий невнимательный программист попытался усложнить алгоритм рандома, добавив в него всего лишь умножение (multiplication overflow) на количество присланных денег, и поленился обдумывать условия детальнее, поэтому просто написал if (result == 777 || result < 1 ), что дает возможность подсунуть отрицательное значение.     int rnd = random(999);     int result = rnd * price.amount;     uint64_t prize = 0;      print(""Result:"", result);      // BINGO 777 or 000 !!! ~ 0.02%      if(result == 777 || result < 1 ) {         prize = 100;         sendtokens(from);     }Сам смарт-контракт выложен на гитхаб, так что все желающие могут его повнимательнее рассмотреть со всех сторон и определить остальные уязвимости. О них уже написано чуть выше, так что сложностей в их поиске быть не должно.Правила участияПравила участия очень просты: необходимо было попытаться выиграть или взломать механизмы системы. При выпадении 3 матрешек – Джек-пот!!! Система начисляет 100 единиц крипто-валюты. Если участник получает джек-пот 3 раза подряд, он становится победителем и получает призы от организаторов — фирменные худи, значки, разнообразный мерч.Конечно, можно было выиграть, долго дергая рычаг и надеясь на удачу, но фортуна — штука непредсказуемая, да и процент выигрыша очень мал, так что проще было взломать.Результаты конкурсаВ итоге конкурс, на наш взгляд, прошел идеально. Были запланированы награды для 3 человек, и как раз троим удалось справиться с конкурсом до назначенной даты окончания. Конкурс проводился 2 дня, в течение которых участники должны были решить таск. Официальное награждение и вручение подарков было на закрытии конференции на главной сцене ZeroNights 2018.Основной упор делался на познавание технологии блокчейн ЕОС, и нами была оставлена пара подсказок, одну из которых так никому не удалось найти. Эту загадку мы оставим на потом…Отзывы участниковАлексей (1 место)ZeroNights одна из моих любимых конференций, начиная с самой первой, в Петербурге я не пропустил ни одну. Всегда дает заряд энтузиазма на полгода точно, а там весной PHDays :). Последние 3 года я занимаюсь блокчейн разработкой. В этом году блокчейн добрался и до ZeroNights (в прошлом правда вроде тоже, было на хаквесте, но я его пропустил). Первым делом, после регистрации на конференции я пошел посмотреть, что и как там с блокчейном. Думал будет, что-то на подобие как на PHDays, какой-нибудь кривой рандом или race condition на эфире. Но тут оказался EOS, с которым у меня было небольшое знакомство на первом хакатоне EOS, но оно было не продолжительным, и к тому же все настройки для разработки были утеряны. Боевой настрой упал, и я пошел ждать начала конференции. Но любопытство взяло верх, все-таки что же там с EOS-ом не так!Stanislav Povolotsky (2 место)Для меня это был долгий, но интересный конкурс. И он стал замечательной возможностью познакомиться поближе с архитектурой блокчейна EOS. Конкурс начался с удивления, что в сеть EOS (mainnet) просто так не попасть — только за $$$. После подсказки, что контракт развёрнут в тестовой сети, регистрации в этой сети, настройки scatter и просмотра истории транзакций для игрового контракта — стало сразу понятно, как нужно обманывать слот-машину (автор контракта при тестировании делал это несколько раз). Но уверенность в том, что так быстро и просто удастся справиться с конкурсом быстро улетучилась, как только сеть не одобрила все мои транзакции с параметрами, идентичными выигрышной транзакции.Ирина (3 место)До участия в конкурсе представляла работу смарт-контрактов только в теории, поэтому было очень интересно «встретиться с ними вживую», увидеть исходный код, опробовать инструменты (и в очередной раз убедиться, что python лучше всего)). Задание получилось действительно очень захватывающим. Спасибо!И в заключениеНе скажем, что все справились легко. Для кого-то это были сложные 2 дня, и только под конец счастливчикам удалось победить, используя недостатки любого блокчейна — если информация попала в блокчейн, то доступна каждому, и если кто-то уже что-то взломал, то и другой может посмотреть его путь.Благодарим всех участников и тех, кто помогал в организации конкурса.До встречи на ZeroNights 2019, вас будут ждать новые приключения!"
ENCRY;DPKI: Addressing the Disadvantages of Centralized PKI by Means of Blockchain;Блог компании ENCRY Децентрализованные сети Информационная безопасность *Криптография *Сетевые технологии *;"Digital certificates are one of the most commonly known auxiliary tools that help protect data across public networks. However, the key disadvantage of this technology is also commonly known: users are forced to implicitly trust certification authorities which issue digital certificates. Andrey Chmora, Technology and Innovations Director at ENCRY, suggested a new approach for building a Public Key Infrastructure (PKI) to eliminate the existing disadvantages using the distributed ledger (blockchain) technology. 
Let's begin with the basics.";/ru/company/encry/blog/461731/;Digital certificates are one of the most commonly known auxiliary tools that help protect data across public networks. However, the key disadvantage of this technology is also commonly known: users are forced to implicitly trust certification authorities which issue digital certificates. Andrey Chmora, Technology and Innovations Director at ENCRY, suggested a new approach for building a Public Key Infrastructure (PKI) to eliminate the existing disadvantages using the distributed ledger (blockchain) technology. Let's begin with the basics. If you already know the basics of the existing public key infrastructure and its key disadvantages, feel free to scroll down to the description of what we suggest to change.What are digital signatures and digital certificates?Interactions over the Internet always include data exchange. And thus we all are interested to keep data safe during such exchange. But what is safety? The most popular safety services are confidentiality, integrity, and authenticity. Today, they are based on asymmetric cryptography, which is also called public key cryptography. First of all, these methods require that the entities of interaction must have two dedicated key pairs: public and private. These key pairs provide the above mentioned safety features. But how to achieve private exchange of information? Figure 1. Encrypted data transmission using a public key cryptographyBefore sending any data, the sender encrypts (converts cryptographically) the public data using the recipient’s public key, and then the recipient decrypts the encrypted data using the private key pair.How to achieve integrity and authenticity of the information being sent? This problem can be solved using another mechanism. Figure 2. Digital signing/verifyingThough public data is not encrypted, it contains a cryptographic hash function value, i.e. encrypted «compressed» image of the input data sequence. The result of such hashing is called a «digest» and is encrypted using the private key of the sender («authenticator»). The result of digest encryption is a digital signature, which is sent to the recipient («verifier») along with the unencrypted text. The recipient decrypts the digital signature using the authenticator's public key and then compares it with cryptographic hash function value which is calculated by the verifier based on the obtained public data. If they match, then the received data is fully authentic, integral and free from any modifications that could possibly be made by attackers.Most resources which process personal data and payment information (such as banks, insurance companies, air carriers, and payment systems along with the tax service and other government portals) widely use asymmetric cryptography. How digital certificates can help here? It's quite simple. Both processes include public keys which play a very important role and thus we must always check that they belong to the sender (or to the authenticator when we need to verify a signature) or the recipient rather than to attackers. And this is where digital certificates can help ensure authenticity and integrity of the public key.Note: Authenticity and integrity of the public key is verified in exactly the same way as for public data, i.e. using the digital signature (DS).Who issues digital certificates?Digital certificates are issued and maintained by trusted Certification Authorities (CAs). The entity making the request asks a CA to issue a certificate, registers in the Registration Center (RC) and then receives their certificate in the CA. The CA guarantees that the public key from the certificate belongs to the entity for which it was issued.If you don't verify the public key authenticity, then attackers will be able to replace the transferred/stored key with their own. Once the key has been replaced, attackers will be able to decrypt everything that the sender transfers to the receiver, or even modify the public data at their discretion. Digital certificates are always used together with asymmetric cryptography. One of the most popular digital certificates are SSL certificates for secure communications via HTTPS. SSL certificates are issued by hundreds of companies across various jurisdictions. The core market share is distributed among five to ten largest trusted certification authorities: IdenTrust, Comodo, GoDaddy, GlobalSign, DigiCert, CERTUM, Actalis, Secom, and Trustwave. CAs and RCs are the PKI components which also include:Public Dictionary: A public database that provides reliable storage for digital certificatesList of Revoked Certificates: A public database that provides reliable storage for digital certificates of revoked public keys (e.g. due to compromised private keys)Infrastructure entities may access this database on their own or use the specialized Online Certification Status Protocol (OCSP) which simplifies the verification proces.Certificate Users: PKI entities that are serviced in accordance with the user agreement with the CA and verify digital signatures and/or encrypt data based on the public key from the certificateSubscribers: PKI entities that are serviced by a CA, hold the private key and paired public key from the certificate, and have concluded a subscriber agreement with the CA. A subscriber may also be a user of the certificate.Thus, trusted entities of the public key infrastructure, including CAs, RCs, and Public Dictionaries, are responsible for:Verification of the entity making the request Profiling of the public key certificate Issue of a public key certificate for an authenticated entity making the request Change of the status of a public key certificate Provision of the information about the current status of a public key certificate. What are disadvantages of PKI?The fundamental disadvantage of PKI is reliance on trusted entities. Users are forced to trust CAs and RCs blindly. However, such blind trust is dangerous.Over the past ten years, infrastructure vulnerability caused several major scandals. In 2010, the malware Stuxnet signed using stolen digital certificates from RealTek and JMicron began to spread on the Internet. In 2017, Google accused Symantec of issuing a large number of falsified certificates. At that moment, Symantec was one of the largest CAs by number of issued certificates. Since version 70 of Google Chrome, Google has ceased support for all certificates issued by this company and its affiliates GeoTrust and Thawte before December 1, 2017. These CAs were compromised and, as a result, the CAs themselves along with users and subscribers were impacted. Moreover, confidence in the infrastructure was impacted. In addition, digital certificates may be banned due to political conflicts and thus impact many resources. This why in 2016 the Russian authorities considered creation of the national certification center to issue SSL certificates for Runet websites. In the current situation, Russian governmental portals use digital certificates issued by the US companies Comodo or Thawte (Symantec's subsidiary).There is yet another problem: how to authenticate users initially? How to identify an anonymous user who has requested a digital certificate from a CA? Today, it is often made arbitrarily depending on the infrastructure capabilities. Some information is taken from public databases (e.g. about legal entities requesting certificates) or from banks and post offices where individuals can identified by their ID cards and other documents.Impersonation based on false credentials is one of the fundamental problems. And, unfortunately, no complete solution of this problem may even exist due to informational and theoretical aspects: without reliable information, it's impossible to verify authenticity of an entity. As a rule, the verification process requires a set of documents proving the identity of the entity making the request. Though there are lots of verification methods, none of them can guarantee authenticity of the documents. Thus, authenticity of the entity making the request also cannot be identified for sure.How to eliminate these disadvantages?Since current PKI problems are mainly caused by centralization, it's obvious that decentralization may help eliminate at least some of them. Decentralization doesn't rely upon any trusted entities, since creation of the Decentralized Public Key Infrastructure (DPKI) will make both CAs and RCs needless. Let's reject the digital certificate concept and instead use a distributed ledger to store information about public keys. In our case, a ledger is a linear database consisting of individual records (blocks) and connected using the blockchain technology. Let's replace the term «digital certificate» with the term «notification». This is how the receipt, verification, and revoking of notifications will look like in the proposed DPKI:Each entity making the request applies for a notification on their own by filling out a registration form, and then composes a transaction which will be stored in a specialized pool.Information about the public key along with the owner’s details and other metadata are stored in a distributed ledger rather than in a digital certificate which is issued by the CA in the centralized PKI.The entity making the request is then authenticated by the joint efforts of the DPKI user community rather than by RC.Only the owner of such notification may change the status of a public key.Everyone may access the distributed ledger and check the current status of the public key.Note: At first glance, authentication of the entity making the request may seem unreliable. However, it's important to keep in mind that nowadays all users of digital services leave an ever-growing digital footprint. The publicly available tools include digital databases of legal entities, maps, digitalized terrain images, social media, and more. They are already successfully used in investigations by journalists and law enforcement agencies. One of the typical examples include Bellingcat investigations and joint group JIT, which investigates the Malaysian Boeing plane crash.So, how will a decentralized public key infrastructure work in practice? Let's deep dive into the technology that we've patented in 2018 and consider our best know-how.Suppose there's an individual who owns a set of public keys, where each key is a sort of transaction stored in a ledger. How to verify that all these keys really belong to a given owner without a CA? To solve this task, we can create a null transaction to store the information about the owner and their e-wallet (from which a commission fee for adding a transaction to the ledger is debited). A null transaction is a sort of «anchor» for hooking up the next transactions along with the data about public keys. Each transaction of this type contains a specialized data structure which is called «notification». Notification is a structured data set of functional fields that stores information about the owner's public key and guarantees persistence of this key by adding it to one of the related records in the distributed ledger. The next obvious question is how to form a null transaction? A null transaction, just like all subsequent transactions, is an aggregation of six data fields. To form a null transaction, we use the public/private key pair for the e-wallet. This public/private key pair is created when the user creates their wallet from which the commission fee for adding a null transaction to the ledger and for subsequent operations with notifications will be debited.Figure 3. Сreating a null transactionFigure 3 shows how a digest of the e-wallet's public key is formed using the SHA256 hash function and then the RIPEMD160 hash function. Here, RIPEMD160 is responsible for representing data with the digest size up to 160 bits. It's very important, since ledgers are expensive databases. The public key itself is included in the fifth field. The first field contains data that links a given transaction to the previous one. In the null transaction, unlike all other transactions, this field is empty. The second field contains data for verification of the transaction connectivity. For the sake of brevity, we will be referring to data in the first and second fields as «bind» and «verification» respectively. Figure 4. Transactions binding and verificationData in these fields can be formed using iterative hashing as shown in the Figure 4 above for binding the second and third transactions.Data in the first five fields is authenticated with the DS generated using the e-wallet's private key. And that's all — the transaction can now be added to the pool and then, upon successful verification (as shown in Figure 5), to the ledger. Figure 5. Verification of the null transactionNow this transaction can be used for «hooking up» the next transactions. Let's take a look at Figure 6 to see how all non-null transactions are formed.Figure 6. Сreating a non-null transactionThe first thing you may notice is a multitude of public/private key pairs. In addition to the already familiar e-wallet public/private key pair, we also use ordinary and service key pairs.An ordinary public key is the most important part here. This key is used in various procedures and processes of the surrounding world (such as banking and other transactions, document flow, etc.). For example, a private key from an ordinary public/private key pair can be used for the creation of a DS for various documents, such as payment orders, while the public key can be used for the verification of the DS with subsequent execution of these orders.A service public/private key pair is issued to a registered DPKI entity. The name of this public/private key pair clearly reflects its purpose. Note that service keys are not used for generation/verification of a null transaction.Just to be clear, let's refine purposes of these keys:E-wallet keys are used for the generation and/or verification of both null and any non-null transactions. The e-wallet's private key is known only to the e-wallet's owner who also possesses the set of ordinary public keys.The purpose of an ordinary public key is the same as that of the public key for which a certificate in the centralized PKI is issued.The service public/private key pair belongs to the DPKI. A private key is issued for the registered entities and is used for creating a DS of all non-null transactions. A public key is used for the verification of a DS for transactions before adding them to the ledger.Thus, we have two group of keys. The first group includes service keys and e-wallet keys that are eligible only within the DPKI. The second group includes ordinary keys that can be used for various purposes depending on a given field of application. At the same time, the DPKI ensures integrity and authenticity of ordinary public keys.Note: The service public/private key pair may be disclosed to various DPKI entities. In certain cases, the pair may be the same for all entities. This is why forming a signature for each non-null transaction requires two private keys, one of which is the e-wallet key: this key is known only to the e-wallet's owner who also possesses the set of ordinary public keys. All these keys have certain purposes. For example, we can always prove that a given transaction was included in the ledger by a registered DPKI entity, since the signature was formed using a service private key as well. In addition, this prevents any DOS attacks and other fraudulent activities, because the owner pays for each transaction.All transactions that follow a null transaction are formed similarly: a public key (from an ordinary key pair, not the e-wallet's key as for null transactions) is processed using two hash functions: SHA256 and RIPEMD160. This is how data in the third field is formed. The fourth field contains additional information (e.g. information on the current status, validity period, time stamp, IDs of the cryptographic algorithms, etc.). The fifth field contains a public key from the service public/private key pair. This key is replicated, since it will be used for the verification of a DS. Let's prove that such approach is necessary.Each transaction is included in the pool and stored there until processed. However, keeping transactions in the pool is risky, since transaction data can be falsified. The owner authenticates transaction data using a DS. The public key for the verification of this DS is explicitly specified in one of the transaction fields and then included in the ledger. Transactions are processed in a way that possibly allows an attacker to modify the data at their own discretion, verify it with own private key and then specify the corresponding public key for the verification of DS directly in the transaction. If authenticity and integrity are ensured only using a DS, such forgery may remain unnoticed. However, extending a DS with an additional mechanism that provides both archiving and persistence of the stored information will help detect such forgery. All we need to do is to include the authentic public key of the owner in the ledger. Let's see how it works.Suppose that an attacker is trying to falsify the transaction data. In terms of the keys and DS, the following options are possible:The attacker places their own public key in the transaction while keeping the owner's DS unchanged.The attacker forms a new DS using their own private key while keeping the owner's public key unchanged.The attacker forms a new DS using their own private key and place the corresponding public key in the transaction.It's obvious that options 1 and 2 are useless, since the verification of the DS will always detect such forgery. The only option that makes sense is option 3: if the attacker creates a DS using their own private key, then they are forced to save the corresponding public key in the transaction, and this key will be different from the owner's public key. It's the only way for the attacker to enforce their falsified data.Suppose that the owner has a fixed public/private key pair. Suppose that the data is authenticated with a DS using a private key from this pair while the public key is specified in the transaction. Suppose also that this public key has been included previously in the ledger and has been fully authenticated. Then the forgery can be revealed by the fact that the public key in the transaction does not match the public key in the ledger.Let's sum it up. When processing data from the owner's very first transaction, we must authenticate the public key included in the ledger. To do this, we can read the key from the ledger and then match this key with the owner's authentic public key within the security perimeter (relatively invulnerable area). If the placed key is authenticated and fully persistent, then the key from the next transaction can also be easily authenticated by matching it with the key from the ledger. In other words, the key from the ledger is used as a reference. All other transactions of the owner will be processed similarly.Each transaction is authenticated with a DS, and here we need both private keys: the service private key and the e-wallet's private key. Based on the two private keys, we can ensure the target security level, since the service private key can be known to other users, while the e-wallet's private key is known only to the owner of the ordinary key pair. We've called such a two-key signature a «consolidated» DS.Non-null transactions are verified using the two public keys: the e-wallet's key and the service key. (Figure 7)Figure 7. Verification of a non-null transactionThe verification process consists of the two basic steps: the first step includes verification of the digest of the e-wallet's public key while the second step implements the verification of the transaction's «consolidated» DS formed using the two private keys (i.e. the e-wallet's key and the service key). When the DS is authenticated, then the corresponding transaction, upon the additional verification, is included in the ledger.However, the following question arises: how to verify whether a given transaction belongs to a particular transaction chain which begins from a null transaction? To do this, we've updated the verification process with yet another step — the connectivity verification. This step will require data from the first two fields that we haven't used up to this point.Suppose that we need to verify whether transaction #2 is really followed by transaction #3. To do this, we can use the combined hashing method for calculating the hash function values for the data in the third, fourth, and fifth fields. The we can concatenate the data from the first field of transaction #3 and the previously calculated combined hash function value for the data in the third, fourth, and fifth fields of transaction #2. All these values are then processed using the two hash functions: SHA256 and RIPEMD160. If the resulting value matches the data in the second field of transaction #2, then the verification is passed successfully and the connectivity is proved. This is shown in more detail in the figures below.Figure 8, Figure 9. Binding verification, second and third transactions exampleIn general, forming and including a notification in the ledger look like this. The workflow of forming a chain of notifications is clearly shown in the following figure:Figure 10. Transaction structure and processingIn this article, we will not dive deep into the details and get back to the discussion of the concept of the decentralized infrastructure for public keys.So, since the entity making the request sends a request for registration of notifications that are stored in the ledger rather than in a CA database, the core architectural components of the DPKI are as follows:Ledger of Valid Notifications (LVN)Ledger of Withdrawn Notifications (LWN)Ledger of Suspended Notifications (LSN).The information about public keys is stored in the LVN/LWN/LSN as hash function values. Note also that it can be either different ledgers or different chains or even a single chain as part of a single ledger, when information about the status of an ordinary public key (withdrawal, suspension, etc.) is added to the fourth field of the data structure as the corresponding code value. There are lots of options for the architectural implementation of the DPKI depending on various optimization criteria, such as costs for for long-term storing of public keys in memory, etc.Thus, the DPKI can turn to be of the same or even lower architectural complexity compared to a centralized solution. So, the main question here is which ledger is more suitable for implementing this technology?The core requirement for the ledger is to be able to form transactions of any type. The most well-known example of a real ledger is Bitcoin. However, implementing the above technology for Bitcoin may face certain difficulties: limitations of the existing scripting language, the lack of necessary mechanisms for processing arbitrary datasets and methods for generating transactions of arbitrary types, and so on.We at ENCRY tried to solve the above problems and developed a ledger, which, in our opinion, features several important advantages:Support of several types of transactions: in this ledger, you can both exchange assets (i.e. carry out financial transactions) and form transactions of an arbitrary structureDevelopers are welcome to use the proprietary programming language PrismLang which is very flexible in solving various technological problemsThe implemented mechanism for processing arbitrary datasets.Simply put, the following steps should be completed:An entity making the request registers in the DPKI and obtains an e-wallet. The e-wallet's address is a value of the hash function applied to the e-wallet's public key. The e-wallet's private key is known only to the entity making the requestUpon registration, the entity obtains access to the service private keyThe entity forms a null transaction and then authenticates its DS using the e-wallet's private keyWhen forming a non-null transaction, the entity must authenticate its DS using two private keys: the e-wallet's key and the service keyThe entity sends the transaction to the poolThe ENCRY network node reads the transaction from the pool and then verifies the transaction's DS and connectivityIf the DS is valid and the connectivity is proved, then the node will prepare the transaction for adding to the ledger.Here, the ledger serves as a distributed database that stores information about valid, withdrawn, and suspended notifications.Certainly, decentralization is not a one-size-fits-all solution. The core issue with the primary user authentication still persists: while the entity making the request is currently verified by the CA, the DPKI proposes to delegate this verification to the community members and motivate them financially. The verification technology based on public sources is commonly known. Efficiency of such verification has also been proved in practice: several high-profile investigations conducted by Bellingcat are good examples of this.But in general, we are quite sure that the DPKI is capable to eliminate many, if not all, disadvantages of a centralized PKI.Feel free to subscribe to our blog on Habr, where we are going to discuss our further researches and developments, and follow our Twitter to stay tuned for more news about ENCRY projects.
Itelma;Стартапы в области Automotive и Blockchain;Блог компании НПП ИТЭЛМА Разработка систем связи *Распределённые системы *Транспорт;"Победители первого этапа конкурса MOBI Grand Challenge применяют блокчейн к автоиндустрии и рынку транспорта новыми способами, начиная от колонн беспилотных автомобилей и заканчивая автоматизированной V2X-связью.

Блокчейн все еще имеет некоторые проблемы на своем пути, но его потенциальное влияние на автомобильную промышленность неоспоримо. Вокруг этого специфического применения блокчейна возникла целая экосистема стартапов и новых предприятий.

Mobility Open Blockchain Initiative (MOBI), некоммерческая инициатива, направленная на ускоренное внедрение стандартов, связанных с блокчейном, в автомобильной и транспортной промышленности, провела первую фазу своего проекта MOBI Grand Challenge (MGC), рассчитанного на три года и направленного на выявление инновационных способов применения блокчейна в формирующейся экосистеме подключенных к сети и автономных автомобилей. 

Согласно заявлению MOBI: «Целью MGC является создание жизнеспособной, децентрализованной, специальной сети связанных между собой автомобилей на распределенной бухгалтерии (distributed ledger technology) и инфраструктуры, которая может надежно обмениваться данными, координировать поведение и, в конечном счете, улучшать городскую мобильность».";/ru/company/itelma/blog/496588/;Победители первого этапа конкурса MOBI Grand Challenge применяют блокчейн к автоиндустрии и рынку транспорта новыми способами, начиная от колонн беспилотных автомобилей и заканчивая автоматизированной V2X-связью.Блокчейн все еще имеет некоторые проблемы на своем пути, но его потенциальное влияние на автомобильную промышленность неоспоримо. Вокруг этого специфического применения блокчейна возникла целая экосистема стартапов и новых предприятий.Mobility Open Blockchain Initiative (MOBI), некоммерческая инициатива, направленная на ускоренное внедрение стандартов, связанных с блокчейном, в автомобильной и транспортной промышленности, провела первую фазу своего проекта MOBI Grand Challenge (MGC), рассчитанного на три года и направленного на выявление инновационных способов применения блокчейна в формирующейся экосистеме подключенных к сети и автономных автомобилей. Согласно заявлению MOBI: «Целью MGC является создание жизнеспособной, децентрализованной, специальной сети связанных между собой автомобилей на распределенной бухгалтерии (distributed ledger technology) и инфраструктуры, которая может надежно обмениваться данными, координировать поведение и, в конечном счете, улучшать городскую мобильность».За четыре месяца первого этапа 23 команды, представляющие 15 стран, соревновались в создании решения, использующего технологию блокчейна или распределенной бухгалтерии для решения проблем мобильности, стоящих перед современным миром. Представленные материалы оценивались с точки зрения творческого подхода, технических достоинств, потенциального воздействия и осуществимости. В конце концов, четыре команды были отмечены самыми высокими наградами.В то время как на этом первом этапе рассматривались проблемы, связанные с мобильностью, на втором этапе конкурса будут изучаться способы, с помощью которых блокчейн «может стимулировать действия, направленные на предотвращение заторов, снижение уровня загрязнения окружающей среды и повышение уровня жизни в городах», по данным MOBI.Вот четыре победителя:3-е место (разделенное) — Fraunhofer Blockchain LabFraunhofer Blockchain Lab решает задачу конвойной езды беспилотных автомобилей, применяя блокчейн для связи между транспортными средствами (V2V) и связи между транспортными средствами и инфраструктурой (V2X). Система Fraunhofer позволяет транспортным средствам обмениваться данными с датчиками для формирования колонны, в которой переднее транспортное средство, управляемое человеком, может управлять несколькими автомобилями позади него. Все автомобили поддерживают постоянную скорость и расстояние друг от друга (считанные сантиметры). Идея заключается в создании мобильной автосферы с преимуществами беспилотной езды без полного отказа человека от управления транспортными средствами.Компания говорит, что этот метод организации конвойной езды снижает выбросы и расход топлива и может служить мостом между нашим нынешним положением дел с мобильностью и миром, в котором все автомобили автономны.3-е место (разделенное) — NuCypherNuCypher (в партнерстве с NCIS Labs) разработали систему, использующую блокчейн, который позволяет владельцам транспортных средств безопасно и надежно обмениваться с организациями данными бортовой диагностики (БДД) своих транспортных средств. Распространяя БДД по леджеру, система NuCypher поддерживает доступность и точность, которые, по словам компании, могут быть использованы как для прогнозирования технического обслуживания, так и для урегулирования страховых случаев и конфликтов, связанных с авариями.2-е место — Oaken InnovationsOaken Innovations разработала Vento, систему оплаты за проезд по платным дорогам с блокчейном, которая позволяет пассажирам (и самим транспортным средствам) оплачивать проезд по платным дорогам и другие виды использования инфраструктуры по требованию с помощью защищенной и зашифрованной системы. Там, где современные платные дороги могут идентифицировать автомобиль и впоследствии смогут собирать платежи с помощью таких технологий, как камеры и RFID, Oaken стремится использовать блокчейн, чтобы объединить все это в единый, бесшовный процесс. Согласно заявлению MOBI, это может улучшить общественный транспорт, приводя к созданию экосистемы, основанной на блокчейне в которой транспортные средства могут не только оплачивать проезд по дороге, но и получать штрафы за формирование пробок, загрязнение окружающей среды и другие действия, которые препятствуют общей мобильности на дороге.1 место — Chorus MobilityChorus Mobility (в сотрудничестве с Decentralized Technology) разработала платформу с блокчейном для связи между человеком и автомобилем, а также V2V и V2X в сетях с автономными автомобилями. Целью компании является снижение затрат на передвижение и повышение безопасности дорожного движения за счет предоставления автономным автомобилям возможности безопасного и автоматического общения с людьми, инфраструктурой и другими транспортными средствами, которые их окружают. С помощью платформы Chorus автомобили могут обмениваться информацией о маршрутах движения, получать информацию об инфраструктуре, а также распределять право проезда между собой в зависимости от спроса и доступности. Платформа позволяет транспортным средствам перемещаться, совершая операции друг с другом, по сути, благодаря друг друга за такие привилегии, как право на дорогу.О компании ИТЭЛМАМы большая компания-разработчик automotive компонентов. В компании трудится около 2500 сотрудников, в том числе 650 инженеров. Мы, пожалуй, самый сильный в России центр компетенций по разработке автомобильной электроники. Сейчас активно растем и открыли много вакансий (порядка 30, в том числе в регионах), таких как инженер-программист, инженер-конструктор, ведущий инженер-разработчик (DSP-программист) и др.У нас много интересных задач от автопроизводителей и концернов, двигающих индустрию. Если хотите расти, как специалист, и учиться у лучших, будем рады видеть вас в нашей команде. Также мы готовы делиться экспертизой, самым важным что происходит в automotive. Задавайте нам любые вопросы, ответим, пообсуждаем.Читать еще полезные статьи:[Прогноз] Транспорт будущего (краткосрочный, среднесрочный, долгосрочный горизонты)Лучшие материалы по взлому автомобилей с DEF CON 2018-2019 года[Прогноз] Motornet — сеть обмена данными для роботизированного транспортаКомпании потратили 16 миллиардов долларов на беспилотные автомобили, чтобы захватить рынок в 8 триллионовКамеры или лазерыАвтономные автомобили на open sourceMcKinsey: переосмысляем софт и архитектуру электроники в automotiveОчередная война операционок уже идет под капотом автомобилейПрограммный код в автомобилеВ современном автомобиле строк кода больше чем…
XaocCPS;Red Hat, Revolution R, Elasticsearch, MariaDB, Blockchain-as-a-service и многое другое доступно в Azure Marketplace;Блог компании Microsoft Microsoft Azure;"Не так давно мы рассказывали про возможности, которые приносит Azure Marketplace как независимым разработчикам ПО (ISV), так и рядовым программистам и ИТ-профессионалам, которые разрабатывают приложения и сервисы в облачном окружении. В других материалах мы подробно и на примерах рассказывали как некоторые ISV, например компания Jelastic, уже опубликовались в Azure Marketplace.



С тех пор в магазине Azure Marketplace произошло много интересного, о чем и пойдет речь в этой статье. Разработчики и ИТ-профессионалы получили доступ к новым решениям, таким как Red Hat, Revolution R, Elasticsearch, MariaDb, Blockchain-платформе STRATO, и многим другим решениям. Еще больше интересного ожидается вскоре, а пока давайте рассмотрим горячие новости.";/ru/company/microsoft/blog/278367/;Не так давно мы рассказывали про возможности, которые приносит Azure Marketplace как независимым разработчикам ПО (ISV), так и рядовым программистам и ИТ-профессионалам, которые разрабатывают приложения и сервисы в облачном окружении. В других материалах мы подробно и на примерах рассказывали как некоторые ISV, например компания Jelastic, уже опубликовались в Azure Marketplace.С тех пор в магазине Azure Marketplace произошло много интересного, о чем и пойдет речь в этой статье. Разработчики и ИТ-профессионалы получили доступ к новым решениям, таким как Red Hat, Revolution R, Elasticsearch, MariaDb, Blockchain-платформе STRATO, и многим другим решениям. Еще больше интересного ожидается вскоре, а пока давайте рассмотрим горячие новости.Red HatДолгожданная для многих новость – сертифицированные решения Red Hat официально поддерживаемые доступны на платформе Microsoft Azure! Подробно о возможностях можно прочитать на специальной странице.Пользователи Red Hat, благодаря преимуществам Red Hat Cloud Access могут легко перемещать свои имеющиеся лицензии в облако Azure и развертывать там виртуальные машины с продуктами компании.Azure Marketplace предлагает простой и легкий способ развертывания Red Hat Enterprise Linux 6.7 и версии 7.2 в несколько кликов. Revolution RОтличной новостью для всех ученых, аналитиков и других специалистов, которые используют в своей работе язык R и продукты Revolution стал выход официального сервера Revolution R Enterprise версии 7.4.1, доступного для быстрой установки через Azure Marketplace.Сервер доступен для установки как на базе OpenLogic CentOS Linux 6.5, так и на базе Windows Server 2012 R2.Новейшая же версия сервера уже выпущена под брендом Microsoft R Server 8.0 и тоже доступна в Azure Marketplace для установки в пары кликов. Попробуйте ее сегодня в облачном окружении доступном по запросу!ElasticsearchПлатформа Elasticsearch известна многим. Популярное решение для индексации и поиска до петабайт данных теперь официально доступно для автоматического развертывания из Azure Marketplace!Подписки от Elastic, компании-производителя Elasticsearch, предлагаются пользователям Azure с лицензией на коммерческое ПО и поддержку корпоративного уровня для стека Elastic. Попробуйте Elasticsearch and Kibana прямо сейчас из Azure Marketplace.MariaDBДругой знаменитый проект с открытым исходным кодом – база данных MariaDB – так же официально анонсировал свою поддержку Azure и теперь доступен для быстрого развертывания кластеров через Azure Marketplace.Кластер MariaDB Enterprise Cluster предлагает в Microsoft Azure развертывание 3 узлов и дополнительный узел MariaDB MaxScale, работающие на CentOS 7. MaxScale автоматизирует конфигурирование балансировки нагрузки и параметров сервисов Read/Write Split, Write Connection Router и Read Connection Router для узлов баз данных.Пользователи могут в несколько кликов поднять кластера MariaDB с помощью этого официального решения доступного в Azure Marketplace.Blockchain-платформа STRATOТехнология блокчейнов пользуется сегодня огромной популярностью и интересом самого широкого круга специалистов. Azure предлагает множество решений для поддержки технологий блокчейн, в том числе платформы Ethereum и STRATO. Подробнее вы можете узнать из этого списка анонсов.Хорошая новость состоит в том, что Azure Marketplace предлагает вам развернуть всего в несколько шагов готовое решение BlockApps STRATO!  Открытые проекты от BitnamiОгромное количество решений на базе открытого кода доступно в Azure Marketplace благодаря публикации готовых к использованию виртуальных машин от компании Bitnami! Среди них: готовые преднастроенные и сконфигурированные стеки Django, Ruby, LAMP, MEAN и другие, базы данных MongoDB, Apache Solr и другие, инструменты Memcached, Nginx, Parse Server и другие, множество CMS (Moodle, Wordpress, Drupal, Joomla) и других инструментов с исходным кодом, которые вы можете добавить в свою облачную подписку всего парой кликов.Установить любое из десятков open source решений в пару кликов из Azure Marketplace.Azure Marketplace как канал продажМы рассмотрели Azure Marketplace как мощный инструмент, облегчающий разработчикам и ИТ-специалистам развертывание решений и организацию окружений на базе разных решений в облаке Azure.С другой стороны, Azure Marketplace является мощным каналом продаж решений для независимых разработчиков программного обеспечения. Сегодня в магазин ежемесячно добавляются десятки новых решений от компаний из множества стран. Эти решения получают разнообразную маркетинговую поддержку от компании Microsoft и дополнительное продвижение на целевую аудиторию. Пример такого продвижения – канал Microsoft Partner Apps.Канал Azure Marketplace с присутствием на более чем сотни рынков по всему миру становится отличным способом для любого разработчика ПО выйти на мировую сцену и начать продавать себя в любой точке мира без лишних хлопот с юридическими и налоговыми вопросами.Полезные ссылкиВы можете узнавать последние новости о платформе Azure и в том числе о Azure Marketplace в официальном блоге http://azure.microsoft.com/blog.Подпишитесь в Твиттере на канал Microsoft Partner Apps, чтобы узнавать больше о новых решениях и технологических новинках независимых разработчиков ПО.Более 3300 разнообразных решений вы всего сможете найти на странице Azure Marketplace.
kichik;Июньская DevCon-школа: AI, BlockChain, Azure Stack и 12 мастер-классов;Блог компании Microsoft Microsoft Azure Машинное обучение *;"Всем привет!

Для тех, кому немножечко лень читать вводную часть, сразу перейду к делу:


1 июня мы проводим в Москве уже шестую DevCon-школу;
В программе три интенсива (AI, BlockChain и Azure Stack) и 12 мастер-классов;
Участие бесплатное, но надо ответить на вопросы. Места, как обычно, быстро заканчиваются.";/ru/company/microsoft/blog/329038/;"Всем привет!Для тех, кому немножечко лень читать вводную часть, сразу перейду к делу:1 июня мы проводим в Москве уже шестую DevCon-школу;В программе три интенсива (AI, BlockChain и Azure Stack) и 12 мастер-классов;Участие бесплатное, но надо ответить на вопросы. Места, как обычно, быстро заканчиваются.КонтекстПару недель назад завершилась наша большая технологическая конференция Build 2017 (см. также анонсы 1 дня и 2 дня). Одна из ключевых тем — это постепенная эволюция мира «Cloud First Mobile First» в сторону «Intelligent Cloud Intelligent Edge». Казалось бы, простая игра слов, но в реальности это изменение носит фундаментальный характер. Во-первых, становится понятным, что интеллектуальные решения (то есть ИИ) будут проникать на конечные устройства или системы, будь то смартфон, автономная машина, круизный лайнер или система управления металлопрокатным оборудованием. Причем не просто проникать, будучи доступными из облака, но и исполняться непосредственно там, где генерируются данные. Тут огромный спектр технологических вопросов и в зависимости от масштаба, решением может быть чипсет, спроектированный под задачи работы с нейронными сетями, или, скажем Azure IoT Edge, позволяющий перенести часть умной облачной логики на локальные сервера.Во-вторых, благодаря многочисленным усилиям индустрии, направленным на переносимость кода (прежде всего, речь идет про решения с открытым кодом), последовательно стираются технические границы между публичными и приватными облаками. Здесь снова широкий набор технологий — от последовательного расширения поддержки в облаке популярных решений (например, PostgreSQL и MySQL) и контейниризации до таких инфраструктурных решений, как Azure Stack. Где-то в светлом будущем границы будут определяться конфигурациями контуров безопасности, размещения данных и вычислительных мощностей.И, в-третьих, то, что интеллектуальная начинка будет везде, в том числе на клиенте, прослеживается из трендов развития пользовательского опыта. Тут и единый граф данных (в нашем случае, Microsoft Graph + Project Rome), связывающий в единую сеть различные конечные устройства, и адаптивные карточки, подстраивающиеся под разные контексты, будь то бот, мобильное приложение, уведомление или поисковая система. И конечно, смешанная реальность, для которой взамодействие с трехмерным окружением пронизано ИИ-прослойкой — от голосового управления до анализа изображения при наложении трехмерных объектов и эффектов.Вот примерно в таком контексте мы и решили проводить нашу шестую DevCon-школу. Учитывая формат школы, мы постарались сосредоточиться на том, что можно попробовать уже сейчас или, по-крайней мере, первых практических шагах в больших и долгоиграющих историях.Июньская DevCon-школаВ июне мы повторяем формат широкой школы с выделенными интенсивами и мастер-классами по аналогии с тем, что мы делали в ноябре прошлого года.Мероприятие пройдет 1 июня, в Москве (Digital October). Мы готовим для вас:1 ключевой доклад (он же открытие)3 интенсива:Практическое введение в нейронные сети и глубокое обучениеГибридные приложения и практики DevOps на базе Azure StackBlockchain: от первого «умного контракта» до ICO12 практических мастер-классов: Azure Service Fabric — платформа для распределенных проектов на практикеВозможности Microsoft Visual Studio Team Services и Azure для Java-разработчиковКонтейнеризация и DevOps приложений на примере Docker и Visual Studio Team ServicesPostgres в облаке AzureКонтейнеры на практикеСбор системной телеметрии в реальном времениРефакторинг унаследованного кода: как разорвать зависимости?Построение процесса безопасной разработки Программируем в мире Minecraft с фреймворком Malmo от MS ResearchМашинное обучение в облаке Microsoft AzureВизуализация данных с помощью Power BIИ еще один мастер-классДля справки: интенсив — это активность на 6 часов с теорией и практикой, мастер-класс — это 2 часа теории и практики. Соответственно, регистрируясь на мероприятие, вы выбираете либо один интенсив (из числа доступных на момент регистрации), либо посещение мастер-классов.Как попасть в школу1. Мы проводим школу бесплатно для участников.2. Необходимо подать заявку на участие, ответив на несколько вопросов.3. Если вы получили подтверждение, следуйте дальнейшим инструкциям, включая установку необходимого ПО на ваш ноутбук в зависимости от выбранных интенсивов или мастер-классов.До встречи 1 июня!"
therealal;Blockchain глазами разработчика;Блог компании MixBytes Криптография *Open source *Программирование *Алгоритмы *;Зачем этот рассказ? Когда я изучал blockchain по открытым источникам, например по Википедии, информация казалась отрывочной и бессвязной. Прошло время, прежде чем она сложилась в целостную картину. Кажется, я знаю, в каком порядке и какими словами описать введение в blockchain, чтобы любой профессиональный разработчик смог понять общую картину за 1—1,5 часа. В тексте будут некоторые упрощения. Понятно, что в любой теме есть много деталей, куда можно при желании погрузиться.;/ru/company/mixbytes/blog/340916/;"Зачем этот рассказ? Когда я изучал blockchain по открытым источникам, например по Википедии, информация казалась отрывочной и бессвязной. Прошло время, прежде чем она сложилась в целостную картину. Кажется, я знаю, в каком порядке и какими словами описать введение в blockchain, чтобы любой профессиональный разработчик смог понять общую картину за 1—1,5 часа. В тексте будут некоторые упрощения. Понятно, что в любой теме есть много деталей, куда можно при желании погрузиться.Начнем. Уже давно существует ассиметричная криптография. Напомню, есть открытый и закрытый ключи. Шифруем открытым, расшифровываем закрытым. Или наоборот. Один из другого получить невозможно. Таким образом, уже пользуясь только ассиметричной криптографией, я могу послать кому-то сообщение, например: «Я перевел 100 рублей», при этом все будут знать, что его послал именно я и что оно доставлено без изменений.Пусть десять человек договорились, что у каждого из них по миллиону новой валюты. Каждый из них может удостовериться (и все могут удостовериться), что именно он послал 300 тысяч этой валюты другому. При этом неизвестно, были ли у него в распоряжении эти 300 тысяч или нет. Чтобы получить это знание, можно узнать балансы каждого. Для этого надо просто математически сложить все приходы денег и вычесть все расходы человека. Таким образом, требуются все операции прихода и расхода. Отсюда возникает public ledger, публичная бухгалтерская книга. Она позволит сказать, может ли человек послать 300 тысяч.Bitcoin: началоОстается одна проблема: что, если я посылаю все свои деньги одновременно двоим? Это двойное расходование, или double-spending. Конечно, эти двое не должны одновременно получить на счета сумму, равную моему балансу до операции. И выяснять между собой, кому все-таки пришел платеж, им тоже неудобно. Ориентироваться на отметки времени (смотреть, кому я послал деньги раньше) ненадежно. Есть решение: упорядочить транзакции. Тогда точно будет понятно, что первый платеж ушел Васе, а второго я просто не могу сделать: нет денег. Но теперь непонятно, кто будет говорить, в каком порядке идут транзакции. В банках и прочих централизованных системах есть доверенное лицо — сам банк, единая точка отказа и точка доверия. Банк говорит, кому ушли мои деньги. В блокчейне единого доверенного лица нет. Это может быть бо?льшая часть сети (понятно, что абсолютно всей сети, ведь каждому участнику доверять нельзя: среди них наверняка есть мошенники). Предполагается, что она не управляется одним лицом и что большинство участников действуют сугубо в своих финансовых интересах.Но проблема упорядочивания транзакций всё еще не решена: нужен так называемый консенсус среди участников сети. Решением этой проблемы занимается один из ключевых алгоритмов каждого конкретного блокчейна — алгоритм консенсуса.Прежде чем мы поговорим о конкретном алгоритме консенсуса, скажу пару слов о пресловутых блоках блокчейна. Блоки — техническая мера, пакетная обработка (batching), чтобы считать консенсус «пачкой» и «размазывать» прочие накладные расходы работы сети по нескольким транзакциям. Порядок транзакций внутри блока определяет один участник сети — тот, кто формирует блок (майнер). А вот порядок блоков определяется уже алгоритмом консенсуса. Алгоритмы консенсуса существуют довольно давно. Например, алгоритмы Paxos и Raft в мультимастер-NoSQL-системах. Но для сети с миллионом равноправных участников они вряд ли подойдут.В Bitcoin был предложен революционный по тем временам алгоритм — консенсус через доказательство работой (proof of work, PoW). Новые блоки формируются одновременно многими участниками сети — майнерами. Нужно решить, чей блок брать в качестве следующего. Чтобы блок стал следующим блоком цепи, майнер должен произвести специально подобранное очень трудоемкое хеширование. Блок (вместе с инкрементируемым числом, nonce) хешируется до тех пор, пока хеш, будучи рассмотренным как большое число, не удовлетворит определенным условиям, например пока не будет содержать 10 нулей в начале. Это потребует миллиардов хеширований — именно той работы, которой майнер «доказывает» свой блок. А проверить правильность работы очень легко: нужно всего одно хеширование. Важно понимать, что работа подбирается так, чтобы во всей сети (т. е. среди тысяч майнеров!) появлялся в среднем всего один блок за десять минут (средний интервал возникновения блоков в Bitcoin). При таких условиях вероятность коллизий, т. е. одновременного представления двух и более блоков в качестве следующего, крайне снижается.Однако вероятность коллизий всё еще остается. На этот случай есть следующее правило: участники сети принимают тот блок, что образует наиболее длинную цепь (одна из альтернатив станет длиннее, когда появится еще один блок).На самом деле есть не цепь, а направленный граф без циклов (DAG) со множеством ответвлений и цепей, а цепью обычно называют «общепринятую историю» — цепь с наибольшей длиной. Поскольку консенсус может быть достигнут не сразу, а за несколько блоков, следует подождать. Для уверенности, что тебе не сделают double-spending, обычно ждут шесть блоков (в Биткойне — час, в Эфириуме — несколько минут).В блоке, кроме транзакций, присутствует хеш предыдущего блока. Таким образом, невозможно что-то исправить в прошлом: неправильными окажутся все последующие хеши. Заодно вместе с блоком выдается награда за майнинг — отсюда и новые деньги! Иначе было бы непонятно, как в принципе ввести деньги в систему: нужно кому-то их выдать, что делает этого кого-то особенным и противоречит идее децентрализации. Выдача денег за майнинг кажется логичным и приемлемым решением.Кстати о майнинге. Нужно понимать, что основная работа майнера — это лютое хеширование нового блока, ассиметричной криптографии там нет, она нужна только для проверки транзакций перед добавлением в блок. В Bitcoin используется хеш SHA-256, в Ethereum — Keccak-256. Если майнить одному — придется в среднем очень долго жить на рисе и воде, прежде чем получишь блок (блок — раз в десять минут, конкурентов — сотни тысяч!). Поэтому майнеры объединяются в пулы. В пуле награда как-то (есть разные подходы) распределяется между участниками, т. е. ты чаще получаешь деньги (конечно, меньшие, чем награда за блок). То есть и риск, и выгода «размазываются». При стремлении времени к бесконечности мат. ожидание прибыли от майнинга в пуле (если пренебречь комиссией пула) равно мат. ожиданию прибыли от одиночного майнинга.До сих пор мы много говорили об обмене данными между участниками сети, но не касались деталей. И не коснемся. Важно помнить, что обмен данными происходит через некий сетевой пиринг, что наша транзакция через него достигнет майнеров.Итак, мы получили технологию блокчейна биткойна.Смарт-контракты и ICOИдем дальше. В Биткойне над каждым аккаунтом выполняются две операции: сложение и вычитание, и они проверяются всеми желающими, прежде всего майнерами. Но что, если добавить внутренние переменные к аккаунту (storage), а к операциям добавить, например, сравнения. Предположим, я хочу перестать принимать деньги на свой аккаунт, когда наберу на нем 10М — т. е. получается уже не просто добавление денег к балансу аккаунта, а добавление при условии. Развивая идею, получаем машину Тьюринга, причем детерминированную — т. е. всё так же все могут проверить состояние аккаунта, — и получаем смарт-контракт. Далее под смарт-контрактами будем понимать смарт-контракты сети Эфириум (Ethereum) как самые популярные на момент написания статьи.Детерминированность означает, что для одних и тех же аргументов транзакции и одного и того же исходного состояния storage на выходе получаем одинаковый результат и одинаковые изменения, произведенные в storage. Только при таких условиях сеть сможет прийти к консенсусу по каждой транзакции. Нужно понимать, что смарт-контракт довольно изолирован от внешнего мира в силу требования детерминированности, проверяемости и децентрализованности. Например, он не может дернуть Web API в децентрализованном стиле (есть варианты решения, так называемые оракулы, но там всё непросто, и это отдельная тема). Кроме того, контроль контракта над внешним миром также крайне ограничен, например трудно снять квартиру через смарт-контракт, обменяв криптовалюту на электронный ключ (вопреки восторженным проспектам, встречающимся в Сети): я все равно должен доверять арендодателю, чтобы знать, что, когда я подойду к двери, поверх электронного замка не будет висеть большой амбарный.Чтобы получить результаты работы контракта (новый баланс или изменения storage), ноды сети вынуждены выполнить операции, в нем прописанные. Вычисление на множестве нод не может быть бесплатным, поэтому в Эфириуме введено понятие газ (gas) — чтобы не хардкодить комиссии за вычисления в криптовалюте, а позволить пользователю посчитать объем вычислений и установить их цену. Эта конструкция — дополнительный уровень косвенности, он дает пользователю выбрать между дешевой транзакцией и быстрой транзакцией.Когда деньги посылаются в контракт как в аккаунт (т. е. просто по адресу) — срабатывает точка входа по умолчанию: fallback function. В отличие от аккаунта, у контракта более одной точки входа — это методы, которые могут принимать параметры. Чтобы изменить контракт (неважно, через какую точку входа), придется посылать транзакцию в сеть: она должна зафиксировать изменения. А просто что-то глянуть в режиме read only можно и локально, имея актуальный блокчейн. Также, в отличие от аккаунтов, у контрактов нет закрытого ключа. Напрямую с их баланса не снять средства — это делают с помощью явно прописанных методов, на которые, конечно, нужно накладывать ограничения безопасности, например проверять адрес того, кто их вызывает.Итого поверх блокчейна в стиле биткойна мы получили технологию смарт-контрактов.На смарт-контрактах Эфириума основано много криптовалют, или так называемых токенов. Да, обычно такая криптовалюта — это просто эфириум-контракт (один!). Балансы — это записи в storage контракта в виде map, а передача валюты от одного к другому — это:map[Alice] –= payment;map[Bob] += payment;Для них не нужно своего майнинга и своей сети: они пользуются инфраструктурой Эфириума. ICO/ITO на Эфириуме — это обмен эфира (криптовалюты сети Эфириум) на криптовалюту (токены). Стандарт ERC20 говорит, какие методы должны быть определены у контракта криптовалюты, за счет чего многие криптовалюты могут быть поддержаны биржами и сразу поддерживаются электронными кошельками, работающими с Эфириумом.Дальнейшее развитиеПоверх базовой идеи блокчейна помимо смарт-контрактов есть много других идей, например так называемое нулевое разглашение или саморегулирование сети.Нулевое разглашение базируется на одноименном семействе криптографических протоколов, суть которых в том, чтобы доказать владение объектом, не показывая его полностью. Например, я могу доказать, что владею конкретным файлом объемом 1 Гб, если смогу ответить на десять вопросов о байтах в разных случайных позициях этого файла. При этом, очевидно, я передам всего 10 байтов из 1 Гб, которые проверяющая сторона и так, вероятно, знает. Поскольку в ходе RSA-шифрования выполняется возведение в степень, ато получается, чтоТаким образом, например, кто угодно может проверить, что баланс моего аккаунта был корректно умножен, причем нет необходимости разглашать, сколько денег у меня было в аккаунте! Продолжая эту идею, можно создать криптовалюту с закрытой информацией о балансах и платежах (и она уже есть — Zcash) и вообще скрыть аргументы вычислений в смарт-контракте.У блокчейнов есть общие для сети параметры, записанные в программном коде самих клиентов сети, например сколько транзакций включать в блок. Обычно их изменение требует принятия сообществом участников сети этих правок (которое выражается в обновлении кода) и грозит форками сети (когда часть участников решают не принимать правку, они просто продолжают работать на «старом» коде). Эти проблемы пытается решить саморегулирование, например блокчейн Tezos. Суть в том, что за каждую правку можно будет проголосовать своими средствами (без их потери, конечно).ЗаключениеИтого технологии прошли следующий путь:подпись транзакций (ассиметричная криптография) + открытость транзакций + упорядочивание транзакций + расширение операций до машины Тьюринга + (нулевое разглашение | саморегулирование | ...)Пара слов о ландшафте блокчейнов. Уже говорилось, что есть много криптовалют, представляющих из себя эфириум-контракты, т. е. использующих блокчейн Эфириума. Но есть проекты помимо Биткойна и Эфириума — они могут отличаться как в деталях (например, форки), так и довольно сильно, пытаясь создать принципиально новые блокчейны, например EOS.БонусОб изучении смарт-контрактов Эфириума. Инфраструктура местами сырая (ее не очень удобно использовать), но достаточно надежная. Вот набор ссылок, по которым изучал написание и безопасность смарт-контрактов я (Не забываем про безопасность! На кону деньги!). Рекомендую читать в такой последовательности:Bitcoin: A Peer-to-Peer Electronic Cash System — секции 1—8Just Enough Bitcoin for EthereumEthereum White PaperЕсли сразу хочется немного практики: The Hitchhiker’s Guide to Smart Contracts in EthereumSolidity DocumentationEthereum Natural Specification Formatcontracts/ в Zeppelin SolidityOnward with Ethereum Smart Contract SecurityEthereum Contract Security Techniques and TipsТолько релевантное из Hacking, Distributed"
Paley;Один+Один — благотворительный маркетплейс на Blockchain;Блог компании Один+Один Разработка под e-commerce *;"Всем привет! Я Михаил Палей, основатель торговой благотворительной площадки «Один+Один». Мы запустились совсем недавно, 15 августа 2017 года, и решили завести блог на Хабре, чтобы знакомить ИТ-сообщество с нашим проектом, а также со сферой благотворительности, в которой он работает. Надеемся получать обратную связь от разработчиков, предпринимателей, и вдохновить других на создание своих собственных ИТ-проектов в благотворительной или социальной сфере.

«Один+Один» — это интернет-платформа, объединяющая благотворительные магазины, социально-ответственный ритейл, благотворительные фонды, а также всех тех, кто хочет делать добрые дела, покупая и продавая вещи. Здесь любой пользователь может выставить свои вещи на продажу или купить вещи других людей или магазинов. Деньги от покупки пойдут в один из благотворительных фондов, подключенных к нам. В какой именно фонд пойдут деньги, решает тот, кто вещь выставляет. Если он этого не делает, то покупатель решает это в момент покупки.";/ru/company/1p1/blog/344676/;Всем привет! Я Михаил Палей, основатель торговой благотворительной площадки «Один+Один». Мы запустились совсем недавно, 15 августа 2017 года, и решили завести блог на Хабре, чтобы знакомить ИТ-сообщество с нашим проектом, а также со сферой благотворительности, в которой он работает. Надеемся получать обратную связь от разработчиков, предпринимателей, и вдохновить других на создание своих собственных ИТ-проектов в благотворительной или социальной сфере.«Один+Один» — это интернет-платформа, объединяющая благотворительные магазины, социально-ответственный ритейл, благотворительные фонды, а также всех тех, кто хочет делать добрые дела, покупая и продавая вещи. Здесь любой пользователь может выставить свои вещи на продажу или купить вещи других людей или магазинов. Деньги от покупки пойдут в один из благотворительных фондов, подключенных к нам. В какой именно фонд пойдут деньги, решает тот, кто вещь выставляет. Если он этого не делает, то покупатель решает это в момент покупки. Благотворительные аукционы известны с незапамятных времен. До недавнего времени это было делом богатых людей. Но в начале 20 века появляются первые благотворительные магазины, в которых начинают участвовать люди самых разных слоёв.Наиболее известный пример — организация Goodwill, состоящая из тысяч благотворительных магазинов, расположенных в США и еще десятке других стран, с ежегодным оборотом в несколько миллиардов долларов. А в Европе уже долгое время существуют онлайн-агрегаторы благотворительных магазинов.За последние 10 лет в России тоже появились подобные проекты. Одним из первых в 2010 году запустился магазин «Спасибо!» в Санкт-Петербурге, сейчас это уже мини-сеть из четырех магазинов. Чуть позже, в 2014 году, появился Charity Shop в Москве, также представляющий собой небольшую сеть.Есть в России и первые благотворительные онлайн-магазины, к примеру, замечательная организация «Легко-Легко». Но даже они работают только с одним конкретным фондом и не дают возможности людям и обычным магазинам самостоятельно выставлять вещи на своей платформе, участвуя в благотворительной деятельности. Мы же решили предоставить людям и бизнесу такую возможность, применив современные технологии.Как мы пришли к идее благотворительной онлайн-площадки Проект «Один+Один» появился у меня в замыслах еще во время работы в банковской сфере. Именно там я впервые столкнуться с блокчейном, а параллельно меня попросили помочь с благотворительным проектом для детских домов. Так, мне, ранее избегавшему «близкого» контакта с благотворительностью (ведь я не до конца понимал механизмы работы благотворительных фондов), но регулярно жертвовавшему деньги, пришла идея объединить современные технологии и благотворительность. Только было неясно, где именно они лучше всего пересекаются и могут дать наибольший эффект.Почему мы выбрали сферу благотворительности? В первую очередь, потому что это та часть жизни, которая нужна и понятна каждому. Если в других социальных направлениях, которыми приходилось заниматься раньше (культура, история, искусство и улучшение качества жизни жителей страны),  проекты могут быть направлены только на определенные группы людей, то благотворительность – понятие всеобъемлющее, находящее отклик в каждом сердце.Мы стали думать, где в этой сфере лучше всего применить современные технологии, чтобы вывести её на принципиально новый качественный уровень. Мы изучили рынок и увидели, что есть благотворительные магазины, уже доказавшие свою рентабельность, но почему-то до сих пор они ограничиваются узконаправленной деятельностью в пользу конкретного благотворительного фонда. А почему бы не работать со всеми существующими фондами? Кроме того, все благотворительные магазины работают преимущественно с физическими лицами, дарящими свои вещи магазину, чтобы тот их продал, но ведь еще есть множество обычных магазинов, которые тоже могли бы часть средств, полученных от продажи своих вещей, отдавать на благотворительные цели.Так в марте 2017 года мы пришли к идее торговой благотворительной площадки, построенной на блокчейне и объединяющей самые разные благотворительные фонды, социально ориентированные коммерческие магазины и людей, которым интересна идея «лёгкой» благотворительности, когда достаточно просто купить понравившуюся вещь, чтобы уже помочь кому-то.Мы провели опрос среди потенциальной аудитории и выяснили, что 67% пользователей готовы отдавать вещи на благотворительность и покупать их с помощью нашего онлайн-сервиса.Команда и запуск проектаНад детальной проработкой идеи работали 5 человек, которые и стали основателями проекта. Нас давно объединяли различные совместные проекты. Например, до «Один+Один» мы запускали приложение «Вместе», решающее те же проблемы, что и «Добродел». Ещё раньше мы помогали проекту «Бессмертный полк». Роли в новом проекте между нами распределились следующим образом: руководитель проекта, технический директор, директор по маркетингу, руководитель по работе с платёжными системами, руководитель по операционной работе.Прототип проекта мы создали в течение первого месяца, и благодаря этой версии смогли привлечь дружеские инвестиции. В течение трёх месяцев мы начали подключать благотворительные фонды и в августе запустили официальную версию «Один+Один». В конце сентября мы привлекли новые инвестиции, к октябрю подключили ритейл, а к ноябрю запустили механизм аукционов.Сейчас над проектом работает порядка 25 человек. Помимо основателей, это прежде всего 10 разработчиков, разбитых на 2 группы: первая занимается маркетплейсом, а вторая – блокчейном. Ещё это тестировщики, системный администратор, аналитик и дизайнер, клиентский и операционный менеджеры, менеджер по коммуникациям, СММ-менеджер, юрист, бухгалтер и другие.Технологический стекПлатформа «Один+Один» развернута на базе LAMP стека, на фреймворке Symfony, в качестве фронт-контроллера используется Nginx.Пользователи взаимодействуют с помощью безопасной сделки. Схему безопасной сделки в пользу третьего лица (благотворительного фонда в нашем случае) специально разработали для «Один+Один» в Yandex.Money. Мы очень им благодарны за сотрудничество и предоставленный нам API.Все транзакции, проведенные через площадку, записываются в Blockchain. В качестве блокчейн-платформы используется Emercoin. Мы выбрали эту технологию, потому что видим одной из своих задач – сделать отчетность благотворительных фондов полностью прозрачной. Кроме того, мы уже приступили к созданию Ассоциации благотворительных фондов на блокчейн. На наш взгляд, такое решение позволит, как минимум:убрать из благотворительности нечистоплотные фонды и «фонды-однодневки»,привлечь в благотворительную сферу тех людей, которые не жертвовали по причине недоверия к благотворительным фондам,перераспределить рынок пожертвований в пользу компаний, готовых быть прозрачными для жертвователей.Мы посвятим отдельный материал вопросу блокчейна в благотворительности, это очень большая и интересная тема.Клиенты, пользователи, партнёрыОсновные клиенты, которым наш сервис призван помогать собирать деньги на благие дела — благотворительные фонды. С нами уже работают более 20 фондов, но будет больше (желающих очень много). При этом особое внимание мы уделяем прозрачности и честности фонда, в связи с чем заключили соглашение с Российским представительством United Way, которое помогает с проверкой организаций, желающих подключиться к площадке.У нас уже есть первые успехи. Например, детский хоспис «Дом с маяком» с помощью нашего сервиса смог собрать более 300 тыс. руб.Основные пользователи «Один+Один» делятся на две группы: первая группа — люди, которые выставляют свои вещи для благотворительной продажи, а вторая — те, кто покупают эти вещи для себя. Тот, кто выставляет вещь, сам назначает ей цену, а также указывает тот фонд, в пользу которого пойдут деньги от продажи. Но фонд можно и не указывать, тогда это сделает покупатель. Взаимодействие происходит на нашем маркетплейсе.Ещё мы работаем с магазинами, которые выставляют у нас свои товары, а часть выручки переводят на благотворительные нужды подключённых к нам фондов. Магазин сам выставляет процент от продаж, который будет направлен на благотворительность, обычно это 5, 10, 15, 20 или 25%. Магазин может выбрать благополучателя (в случае, если у руководства компании есть конкретные предпочтения по направлению благотворительной деятельности или фонду) или оставить выбор за покупателем.Многие сомневались в том, что бизнесу вообще может быть интересно участие в подобном проекте. Но только за первый месяц, без дополнительной клиентской работы, 6 магазинов подключились к нам и уже продают свою продукцию. Желающих подключиться много, ведь плюсы очевидны. Во-первых, конечно, возможность дополнительно заработать, используя «Один+Один» как агентскую площадку для продаж. И это хорошо. Во-вторых, репутация. Чем амбициознее компания, тем больше внимания она уделяет социальной ответственности, а имидж в этой области необходимо выстраивать на реальных кейсах с реальными партнерами, и наша площадка полезный для этого инструмент.Отдельно мы работаем с известными людьми, которые дарят свои вещи для продажи с помощью благотворительного аукциона. Во многом благодаря нашему партнеру Делись добром среди звезд, разместивших свои вещи на площадке, такие люди как Полина Гагарина, Чулпан Хаматова, Мария Шарапова, Андрей Кириленко,  Максим Поташев, Андрей Макаревич, и многие другие.Мы не берем денег с благотворительных фондов за подключение к Blockchain. Наш единственный канал монетизации – комиссия с продаж через интернет-площадку, которая составляет 7%. Мы не стали делать высокую комиссию по этическим соображениям, по этим же причинам не ставим себе высоких зарплат и не раскидываемся рекламными бюджетами. При этом, надеемся, что со временем сможем значительно снизить или даже совсем отказаться от этой комиссии.Делать добрые дела легко – вот что мы хотим показать. А еще важно уйти от благотворительности «давящей на жалость», манипулирующей эмоциями людей, и показать, что помогать может каждый из нас. «Один+Один» позволяет менять мир и помогать без ущерба для себя.
Artod;Переписываем приложение под Blockchain;Децентрализованные сети Open source *Программирование *Solidity *;"Отмечу сразу, что данная статья не о том как писать код на Solidity, а как существующую классическую архитектуру вашего приложения можно перевести на рельсы blockchain и думать в ключе децентрализации.
Пару лет назад я работал над одним интересным веб приложением сервиса p2p доставки посылок. По определенным причинам разработку пришлось заморозить на этапе прототипа, так что я просто выложил исходный код на GitHub и забыл про него.
В последнее время по роду деятельности мне довелось поработать с несколькими проектами связанными с криптовалютой и blockchain-технологиями. Познакомившись ближе с Ethereum и его идеологией децентрализованных приложений (?App) я просто заболел этой идеей: никакой цензуры, никто не может прикрыть ваш бизнес, никто не может конфисковать ваши средства, невозможно просто взять и выключить сервер на котором работает ваше приложение. В определенный момент я пришёл к выводу, что именно в такой среде мой проект может иметь шансы на жизнь.
Итак, взглянем на фронт работ.";/ru/post/351398/;"Отмечу сразу, что данная статья не о том как писать код на Solidity, а как существующую классическую архитектуру вашего приложения можно перевести на рельсы blockchain и думать в ключе децентрализации.Пару лет назад я работал над одним интересным веб приложением сервиса p2p доставки посылок. По определенным причинам разработку пришлось заморозить на этапе прототипа, так что я просто выложил исходный код на GitHub и забыл про него.В последнее время по роду деятельности мне довелось поработать с несколькими проектами связанными с криптовалютой и blockchain-технологиями. Познакомившись ближе с Ethereum и его идеологией децентрализованных приложений (?App) я просто заболел этой идеей: никакой цензуры, никто не может прикрыть ваш бизнес, никто не может конфисковать ваши средства, невозможно просто взять и выключить сервер на котором работает ваше приложение. В определенный момент я пришёл к выводу, что именно в такой среде мой проект может иметь шансы на жизнь.Итак, взглянем на фронт работ. Фронт работИзначальная идея проекта была в том, что люди которые часто путешествуют, могли бы перевозить что-нибудь в своих чемоданах или автомобилях. Этакий Uber для доставки. Пользователи делились на путешественников (осликов) и клиентов. Если вы собираетесь ехать, допустим, из Москвы в Минск на эти выходные, вы можете добавить в сервисе новую поездку (трип) с описанием того, что вы можете перевезти и когда. Клиенты, подписанные на данное направление, получали уведомление о новом трипе и могли добавлять запросы на доставку, например лекарства какие-нибудь или iPad для мамы. Стороны договаривались об оплате (самописный escrow на PayPal) и условиях доставки. После исполнения заказа стороны могли оставлять рейтинги и комментарии друг о друге. В профиле каждого пользователя имелась небольшая статистика.Со временем произошло переосмысление некоторых пунктов в алгоритме работы сервиса. Стало ясно, что будет правильно если бы сначало клиенты добавляли свои заказы на перевозку, а ослики уже выбирали бы кому оказывать услугу. Далее вы увидите, как такая концепция обеспечивает гибкость и масштабируемость.По сути нам надо переписать весь back-end на смарт контракты и задеплоиться на блокчейне. Приложение будет абсолютно открытым, неизменяемым (immutable), децентрализованным и, следовательно, свободным от регуляции даже самим разработчиком. Таким образом, мы получим децентрализованную платформу на базе которой любой человек сможет реализовать своё front-end, мобильное или серверное приложение.Протокол работы подобного сервиса в краткой форме будет выглядеть следующим образом:Клиент добавляет Заказ на перевозку из точки A в точку БОслик может добавить Предложение на оказание услугиКлиент может добавить Ответ на ПредложениеОслик выставляет Счёт на оплату Заказа с указанием суммы Предоплаты и ДепозитаКлиент оплачивает Счёт и может установить Ключ на снятие ДепозитаОслик выполняет заказ и получает Ключ на снятие Депозита (QR-код например)Ослик в любой момент может возместить средства КлиентуОслик и Клиент обмениваются рейтингамиПриступимДанный протокол будет реализован смарт контрактом на Solidity, который назовём Osliki. Для начала заведём переменные для хранения заказов, предложений, счетов и статистики:Order[] public orders; // заказыOffer[] public offers; // предложения (тут же будут храниться и ответы от клиентов)Invoice[] public invoices; // счетаmapping (address => Stat) internal stats; // маппинг адреса пользователя к его статистикеОписание всех структур:struct Order {    address customer; // ethereum-адрес клиента    string from; // гео координаты в формате ""lat,lon"" или ethereum-адрес ""0x..."" (например адрес принадлежащий магазину, ресторану, ферме или частному лицу) или просто пустое значение (например если важно что привезут, а не откуда)    string to; // тоже самое что и предыдущее    string params; // параметры посылки в формате ""вес(кг),длина(м),ширина(м),высота(м)""    uint expires; // дата истечения срока действия, Unix-время в секундах    string message; // просто текст в свободной форме    uint[] offerIds; // массив id предложений    address carrier; // ethereum-адрес выбранного ослика для исполнения заказа    uint invoiceId; // прикрепленный оплаченный счёт    EnumOrderStatus status; // статус заказа    uint createdAt; // дата создания    uint updatedAt; // дата изменения}struct Offer {    address carrier; // ethereum-адрес ослика    uint orderId; // id заказа    string message; // текст предложения в свободной форме    string respond; // текст ответа от клиента в свободной форме.    uint createdAt;    uint updatedAt;}struct Invoice {    address sender; // ethereum-адрес ослика    uint orderId; // id заказа    uint prepayment; // сумма для предоплаты (может быть 0)    uint deposit; // сумма для депозита (может быть 0)    uint expires; // срок годности инвойса     EnumCurrency currency; // валюта в которой выставлен счёт    bytes32 depositHash; // хеш Ethereum-SHA-3 (Keccak-256) депозитного ключа (устанавливается клиентом в момент оплаты счета)    EnumInvoiceStatus status; // статус счёта    uint createdAt;    uint updatedAt;}struct Stat {    uint[] orders; // массив id заказов в которых участвовал юзер в качестве клиента или ослика    uint rateSum; // сумма оценок    uint rateCount; // количество оценок, средняя оценка averageRate = rateSum / rateCount    mapping (uint => Review) reviews; // маппинг id заказа к отзыву и оценке этого заказа}struct Review {    uint8 rate; // оценка между 1 и 5    string text; // текст отзыва    uint createdAt;}Статусы:enum EnumOrderStatus { New, Process, Fulfilled }enum EnumInvoiceStatus { New, Settled, Closed, Refund }enum EnumCurrency { ETH, OSLIK } // оплата счетов в эфире (комиссия 1%) или в своих внутренних токенах OSLIK (без комиссии)Далее не буду приводить тела функций, иначе займет слишком много места. Ниже будет ссылка на исходный код на GitHub.Клиент добавляет Заказ:function addOrder(    string from, //  """" || ""lat,lon"" || ethereum-адрес ""0x...""    string to,     //  """" || ""lat,lon"" || ethereum-адрес ""0x...""    string params, // ""weight(kg),length(m),width(m),height(m)""    uint expires,    string message) public;Ослик добавляет Предложение:function addOffer(    uint orderId,    string message) public;Клиент отправляет Ответ:function respond(    uint offerId,    string message) public; // только один ответ на предложениеОслик отправляет Счёт:function addInvoice(    uint orderId,    uint prepayment,    uint deposit,    EnumCurrency currency, // ETH || OSLIKI    uint expires) public;Клиент оплачивает Счёт:function pay(    uint invoiceId,    bytes32 depositHash // клиент отправляет хеш keccak256 ключа для доступа к депозиту, может быть пустым если нет депозита и все средства оплачены вперед) public payable; // после оплаты, счёт прикрепляется к заказу и отправитель счёта считается выбранным в качестве исполнителя заказаОслик выполняет Заказ. К примеру при доставке Ослик сканирует QR-код у Клиента, в котором вшит Ключ от Депозита:function fulfill(    uint orderId,    string depositKey // ключ который хешируется и сравнивается с depositHash, может быть пустым если депозита не было, в этом случае просто поменяется статус заказа на ‘Выполнен’) public;Ослик возвращает средства Клиенту если тот не доволен или что-то пошло не так в процессе:function refund(    uint invoiceId) public payable;Стороны могут добавлять отзывы друг о друге с оценкой впечатления от Заказа:function addReview(    uint orderId,    uint8 rate,    string text) public; // тут же обновляем статистикуПлюс еще пачка функций для доступа к данным. В итоге у нас вышло 2 контракта: Контракт Osliki, который реализует наш протокол и является ядром платформы для построения любого бизнеса связанного или зависимого от доставки.Токен внутренней валюты OSLIK, который может использоваться для оплаты без комиссии. Токены можно распродать в рамках crowdfunding-а и привлечь средства на развитие и продвижение платформы и сервисов построенных на этой платформе.ПримерыПо сути, контракт Osliki является открытой базой данных заказов на доставку, которую может использовать любое частное лицо, организация или какой-нибудь дрон по типу Amazon Prime Air.Представьте себе предпринимателя с парком грузовых дронов, базирующихся на крыше какого-нибудь здания в вашем городе. Дроны мониторят базу данных в блокчейне и если заказ соответствует каким-то определенным параметрам (например приемлемый радиус действия и габариты груза), автоматически отправляют предложения и счета, а потом летят исполнять заказы.Представьте себе Мистера X с Крэйглиста, который выращивает у себя на даче особо душистый сорт канабиса (конечно же в странах где это легально). Он кидает вам ссылку, по которой вы можете добавить заказ в Osliki с указанием ethereum-адреса Мистера X напрямую, чтобы другие ослики не спамили предложениями. Далее счёт, оплата и вот посылка у вас уже на руках. И даже в случае блокировки аккаунта Мистера X на Крэйглисте, поклонники его садоводческого таланта будут всегда помнить куда слать заказы.Можно представить себе маркетплейс, где фермеры продают свои биологические овощи без ГМО “только что с грядки”, свежее молоко и мясо. Доставка может осуществляться, например, водителями, курсирующими из пригорода в город. Фермеры таким образом получат неограниченный доступ к розничным клиентам в обход супермаркетов.Ну и изначальная идея с путешественниками, перевозящими посылки между городами и странами, также остается актуальной.ПланыКак часть платформы, сюда хорошо вписался бы такой же децентрализованный маркетплейс (Osliki Marketplace) или доска объявлений (Osliki Classifieds). Или, возможно, использовать уже готовые решения.С использованием методов BigData и AI можно более глубоко анализировать поведение и статистику каждого пользователя и выдавать результаты о его благонадежности. Например можно выявлять пользователей, которые накрутили себе рейтинг.На данный момент пока стоит задача реализовать front-end приложение osliki-js (как один из вариантов реализации) на каком-нибудь GitHub Pages, чтобы можно было привычным способом в браузере работать с контрактами. Плюс набор виджетов для встраивания на сайты.Если тема вам показалась интересной, присоединяйтесь к разработке.СсылкиСсылки на исходные коды на GitHub:До После Контракты на данный момент задеплоины в тестовой сети Ethereum Ropsten. Тестовый эфир, чтобы поиграться, можно получить тут.Адреса контрактов: Osliki 0xa5AF61cE7deEb042e7Ad6A2118b183D3733E1D99 ERC20-совместимый токен OSLIK 0x7ee36e1ddac343649edaa622f9bb067ed74545b2"
DataArt;Блокчейн-благотворительность — DataArt победил на хакатоне Malta Blockchain Summit;Блог компании DataArt Хакатоны;"Команда DataArt победила на крупнейшем блокчейн-хакатоне, недавно прошедшем на Мальте. За двое суток коллеги разработали платформу для проведения благотворительных онлайн-лотерей и завоевали приз в 25 тысяч долларов. 

Рассказы победителей и ссылки на проект под катом.";/ru/company/dataart/blog/430514/;Команда DataArt победила на крупнейшем блокчейн-хакатоне, недавно прошедшем на Мальте. За двое суток коллеги разработали платформу для проведения благотворительных онлайн-лотерей и завоевали приз в 25 тысяч долларов. Рассказы победителей и ссылки на проект под катом.Malta Blockchain Summit прошел в мальтийском городе Сент-Джулианс в начале ноябре и собрал около 8,5 тысяч человек, хотя организаторы ожидали примерно вдвое меньше участников. Вот что об MBS пишет Forbes.Команда DataArt на вручении главного приза хакатона. Фото: MBSБлокчейн-хакатон фактически предварял конференцию, которая открылась объявлением победителей. Лучшей стала команда DataArt, представившая платформу для проведения благотворительных лотерей. ПриложениеС платформой Blockchain Charity Lottery могут интегрироваться благотворительные организации, а сама лотерея, благодаря использованию блокчейна, оказывается абсолютно открытой и прозрачной. Все платежи производятся в криптовалюте (команда DataArt использовала Ethereum), но потенциально проект можно интегрировать с биржей.Анатолий Рубцов, Product Design Consultancy DataArt, Санкт-Петербург: «Очень большая проблема благотворительности, по мнению многих, — отсутствие достаточного уровня доверия. Есть опасения, что пожертвованные деньги не дойдут до людей, которые в них действительно нуждаются. Блокчейн решает эту проблему. Можно посмотреть, с каких кошельков шли транзакции, кто победил, на кошелек какой благотворительной организации ушла сумма. Т. е основная фича нашей лотереи — полная открытость и прозрачность. Плюс это гейминг, который в последнее время очень тесно связан с блокчейном».Владислав Дмитриев, Team Lead / Senior Java Developer DataArt, Киев:«Платформа позволяет благотворителям создавать собственные лотереи. В простейшем варианте, реализованном нами за два дня, некий фонд должен обратиться к администратору на нашей стороне, передать данные: описание, цену билета, срок и т. д. При дальнейшем развитии можно сделать регистрацию, передав функции администратору на стороне самого фонда».КомандаСоревновались команды из пяти человек. Правила предполагали тимлида, архитектора, двух бэкенд и одного фронтенд-разработчика. Игорь Кожуренко, лидер iGaming-практики DataArt, тимлид команды, Санкт-Петербург: «Можно сказать, что на хакатоне мы оказались случайно. Но как говорил один из героев мультфильма про Кунг-фу Панду: „Случайности не случайны“. Все началось с того, что CEO MLS прислал мне приглашение получить бесплатный VIP-билет. Событие планировалось крутое (получилось еще круче, чем предполагалось), и когда увидел, что на Мальте пройдет еще и хакатон, сразу подумал, что мы можем собрать команду. Все-таки, мы действительно занимаемся блокчейном уже давно и серьезно». Вместе с Игорем в команду вошли Влад Дмитриев, выступивший в роли архитектора и помогавший с бэкендом, Максим Черников, занимавшийся непосредственно смарт-контрактом, его интеграцией с Java и DevOps, Александр Кузьменко, взявший на себя всю остальную структуру приложения, включая фронтенд, и Анатолий Рубцов, на котором были продуктовая составляющая и дизайн.Владислав Дмитриев, Team Lead / Senior Java Developer: «С Сашей и Максом мы работаем уже достаточно давно, в последнем проекте, где я был тимлидом, работали уже все вместе. Поэтому когда Игорь (с ним мы тоже сделали уже несколько проектов) предложил собрать команду, я сразу решил позвать именно их — это одни из самых крутых разработчиков, которых я знаю».Анатолий Рубцов, Product Design Consultancy: «Все мы в разное время засветились в проектах нашей iGaming-практики, поэтому Игорь с Владом нас и позвали. Лично не все были знакомы между собой, но нам это удалось быстро перейти из состояния рабочей группы в состояние команды, благо опыт у всех достаточно большой. Мы разграничили зоны ответственности и занялись делом. Думаю, если бы пришлось повторить в том же составе, сейчас мы бы управились за сутки».ПодготовкаС самого начала было известно, что в хакатоне будут участвовать проекты, основанные на блокчейне и связанные с геймингом (на Мальте разрешены, в том числе, и азартные игры). Команды заполняли заявки, формулируя общую идею своего приложения, но окончательный список ограничений организаторы обещали озвучить накануне старта. Поэтому тратить время на глубокий анализ и тем более домашние заготовки команда DataArt не стала.Максим Черников, Senior Java Developer, Одесса: «Мы ехали посмотреть на саммит и саму Мальту, завести новые знакомства, в том числе, и с потенциальными клиентами, посмотреть, как работают другие. Участие в хакатоне было следующим пунктом программы, хотя мы хотели показать себя, сделать что-то красивое и классное. Но мы ждали, что соревноваться с нами будут люди, которые делают какие-то совершенно феноменальные вещи. Поэтому на результат мы изначально смотрели спокойно».Александр Кузьменко, Senior Java Developer, Одесса: «Утром первого дня хакатона нам сказали, что мы можем делать то, что заявили в форме регистрации. Дополнительных вводных не появилось, но мы в любом случае ничего заранее не готовили».ХакатонНа разработку проекта было дано два дня. Все команды работали в одном помещении, в процессе за ними могли наблюдать менторы и некоторые участники конференции. Коммиты делались точечно, код отправлялся в специальное окружение и был доступен на GitHub (сейчас код также можно посмотреть — здесь).Игорь Кожуренко, Александр Кузьменко, Владислав Дмитриев, Максим Черников, Анатолий Рубцов. Intercontinental Hotel, Сент-Джулианс, Мальта. Фото: Facebook Владислава ДмитриеваАлександр Кузьменко, Senior Java Developer: «В первый день мы писали код часов пять на хакатоне — нам там разрешали оставаться до одиннадцати. Ну и немного поработали ночью. Второй день писали целиком с восьми утра до одиннадцати вечера, на третий в полдень был код-фриз, и мы как раз до 12 заканчивали фиксить баги и выкатывать мелкие дополнения к функционалу».Владислав Дмитриев, Team Lead / Senior Java Developer: «Когда ты занят кодом, тебе сложно отвлечься на общение с менторами, которых на хакатоне много. У нас все разговоры брали на себя Игорь и Толя, они показывали наши наработки тем, кто подходил с вопросами, беседовали с ними, анализировали какие-то рекомендации». Игорь Кожуренко, лидер iGaming-практики: «Хакатон — это очень интересно, но там, конечно, не до веселья — ты просто не поднимаешь головы. Я старался следить, чтобы мы все время от времени выходили подышать, и конечно, были перерывы на завтрак, обед и ужин. Спали часов по шесть–семь, чтобы не вырубаться днем. Я держался до последнего дня, но перед презентацией все-таки начал пить Red Bull».СложностиБольшинство решений в команде принимали коллегиально, сферы ответственности каждого участника пересекались, а с учетом сжатых сроков обсуждать свои действия приходилось постоянно. Оставаться сосредоточенными двое суток было нелегко, не обошлось и без технических проблем. Владислав Дмитриев, Team Lead / Senior Java Developer: «В команде я формально числился архитектором, но весь бэкенд мы делали втроем. Мы очень много программировали непосредственно вместе с Максом, иногда разделяя задачи. Много проблем возникало с базовыми вещами: Ethereum, Geth, web3j, Solidity. Нам пришлось подбирать версии, которые будут корректно работать друг с другом». Александр Кузьменко, Senior Java Developer: «В принципе, перед мной стояли вполне понятные технические задачи. Самым сложным было делать все быстро и сохранять концентрацию, несмотря на шум вокруг. За тканевой перегородкой вообще находился ресторан, где звенели вилки и что-то постоянно падало».Максим Черников, Senior Java Developer: «Второй день оказался тяжелым: появились проблемы и со смарт-контрактом, и с тестовой сетью, которую долго настраивали. К тому же, мы поменяли подход к решению проблемы рандомайзера. Вначале мы хотели использовать Oraclize в связке с Random.org и доверять генерацию случайных чисел стороннему API, но остановились на алгоритме Provably fair. Кстати, решение этой серьезной проблемы Игорь предложил за обедом».Игорь Кожуренко, лидер iGaming-практики: «Самым сложным было принимать правильные для проекта решения, которые при этом не удлиняли бы процесс. Технически самой сложной областью оказался рандомайзер на блокчейне — проблема, с которой, кроме меня, никто в команде дела раньше не имел. Мы решили не интегрироваться со стороннему системами, опасаясь не только багов, но и вообще специфики работы кода. А решение взять рандомайз-протокол сэкономило нам кучу времени. Мы могли застрять на этом этапе и вообще провалить всю идею, но сообразили, что делать, вовремя. А Макс — молодец — быстро разобрался, как выбранный протокол прикрутить, и вопрос решили с ходу!»ПрезентацияОтдельным и очень важным этапом хакатона была презентация проектов. В команде DataArt эту часть взяли на себя Игорь Кожуренко и Анатолий Рубцов, опытные эксперты с богатым опытом публичных выступлений. Все выступление нужно было уложить в 5 минут, не считая одной–двух минут на вопросы, и удалось это далеко не всем. Многие команды, попытавшись рассказать как можно больше. Не успели полностью представить свои проекты. Игорь Кожуренко, лидер iGaming-практики: «Последний коммит мы сделали в 12 часов, когда был объявлен код-фриз, и к счастью, все у нас действительно заработало. Сразу после этого мы пошли тренировать презентацию. Все разделили на части, посидели два часа с секундомером и были готовы выступать». Максим Черников, Senior Java Developer: «Перед самой презентацией у меня вновь появились сомнения в победе, когда я увидел, насколько серьезно выглядят проекты конкурентов. Но в итоге оказалось, что это в основном презентации, мокапы и видео. Мы же предлагали продукт, который можно было проверить в тестовой сети. К тому же, у нас все было проработано и с технической, и с визуальной точки зрения. Как только началась презентация, стало понятно, насколько сильным получился наш проект». ПобедаС самого начала о победе и призе в команде старались не думать. Но по общему признанию, проект лотереи получился таким, что не победить или хотя бы не войти в тройку призеров было бы обидно. Главным секретом успеха оказалась задача, достаточно сложная технически, чтобы быть интересной и произвести впечатление, однако сложная ровно настолько, чтобы ее можно было убедительно решить за отведенное время.Анатолий Рубцов, Product Design Consultancy: «Были моменты, когда мы сильно волновались. Нам даже казалось, что другие команды подглядывают через плечо и копируют нас. Но в итоге они даже не вошли в тройку. Под конец мы уже расслабились и решили — будь что будет. Когда объявляли победителей, даже не сразу сообразили, что это мы».Александр Кузьменко, Senior Java Developer: «У нас оказался самый завершенный проект. У других команд были интересные задумки, кто-то уже прикручивал к своему проекту устройства с голосовым управлением и т. д. Труда они вложили много, но на самом деле не успели закончить, что собирались, за 48 часов». На экскурсии по Мальте после хакатона. Фото: Facebook Владислава ДмитриеваИгорь Кожуренко, лидер iGaming-практики: «Нам удалось соединить объединить продуманное техническое решение, бизнес-идею и благотворительность. Показать, что с помощью игры можно напрямую делать добро людям, а блокчейн позволяет устранить сомнения в честности того, кто эту игру проводит».ПризОкончательное решение о призе организаторы приняли в последний момент. Вначале фигурировали 50 тысяч евро в криптовалюте для единственной команды, но в итоге остановились на 50 тысячах долларов обычным банковским переводом, которые поделят три команды. Команда DataArt как победитель получит половину (вторая и третья команды получат 15 и 10 тысяч долларов, соответственно). Призовой фонд организаторы решили разделить между тремя командами-призерами. Фото: Facebook Анатолия РубцоваМаксим Черников, Senior Java Developer: «Мы с девушкой давно запланировали поездку в Германию и даже деньги на нее успели отложить, но приз позволит комфортнее себя чувствовать после возвращения. Дошираком питаться не придется!»Александр Кузьменко, Senior Java Developer: «Тратить призовые деньги я точно не собираюсь. Планирую их отложить и прибавить к тем, которые откладываю на автомобиль». Анатолий Рубцов, Product Design Consultancy: «Призовые деньги вполне физические, но их сначала получить надо. Я вот хочу коробку передач поменять».Владислав Дмитриев, Team Lead / Senior Java Developer: «Свою часть выигрыша пока думаю просто положить в банковскую ячейку».
olegchir;Cradle: Rave. Два хакатона + конференция, с упором на Big Data & ML, Blockchain, Quantum Computing, DevOps и Mobile;Блог компании JUG Ru Group Java *Разработка мобильных приложений *Big Data *DevOps *;"На прошлой неделе друзья позвали отдохнуть на неком Cradle:Rave. Судя по названию, это могло быть всё что угодно, включая кислотную вечеринку, поэтому я решил провести некие исследования в интернетах.
На Хабре быстро отыскалась статья в блоге Сбертеха с анонсом мероприятия. Мне этого оказалось недостаточно, поэтому я связался с организаторами напрямую и попросил своими словами объяснить, что это такое. Предоставленная информация была даже шире, чем сейчас опубликовано на сайте, и сейчас я поделюсь с вами данными секретами полишинеля.
Оказалось, всё довольно круто. Это гибридное развлечение, совмещающее хакатон и конференцию. Взяли два основных способа культурного времяпровождения, упаковали в три дня, побеспокоились о помещении и ништяках. Круто. Будет на этой неделе, 16.02-18.02. 
Бесплатно, иначе говоря — на халяву, на шару, совершенно свободно. Но нужно успеть зарегистрироваться до 15-ого числа на сайте, регистрация обязательна.";/ru/company/jugru/blog/348896/;"На прошлой неделе друзья позвали отдохнуть на неком Cradle:Rave. Судя по названию, это могло быть всё что угодно, включая кислотную вечеринку, поэтому я решил провести некие исследования в интернетах.На Хабре быстро отыскалась статья в блоге Сбертеха с анонсом мероприятия. Мне этого оказалось недостаточно, поэтому я связался с организаторами напрямую и попросил своими словами объяснить, что это такое. Предоставленная информация была даже шире, чем сейчас опубликовано на сайте, и сейчас я поделюсь с вами данными секретами полишинеля.Оказалось, всё довольно круто. Это гибридное развлечение, совмещающее хакатон и конференцию. Взяли два основных способа культурного времяпровождения, упаковали в три дня, побеспокоились о помещении и ништяках. Круто. Будет на этой неделе, 16.02-18.02. Бесплатно, иначе говоря — на халяву, на шару, совершенно свободно. Но нужно успеть зарегистрироваться до 15-ого числа на сайте, регистрация обязательна.ХакатоныОни тематические: big data/machine learning и мобильная разработка. Мобильная разработка не простая: очень желательно использовать VR, ML, AR, Blockchain, биометрию. Например, я ни в чём из этого не разбираюсь от слова совсем, поэтому собираюсь погуглить Tensorflow, и как его можно запускать из Java. Сбертех обещает привести своих менторов по всем означенным технологиям, т.е. для меня это возможность не просто погуглить, а ещё и проверить полученные знания с реальными специалистами.Учитывая что бигдата — это, скорей всего, Hadoop/Spark, а мобилки — это Android, — ожидаю, что всё это будет выглядеть как некий особый джава-хакатон. Хотя нигде в описаниях я не видел ограничений на используемые технологии. Можно и Python. Разве что они хотят, чтобы используемые алгоритмы были формально описаны на блоксхемах (даёт дополнительные баллы) — это странно, но… ок, пусть будет.Программа и тайминг хакатонов стандартные: в пятницу надо отметиться что ты есть, в воскресенье — сдать проект. И забрать деньги, если ты что-то заработал. Но есть кое-что интересное! Сколково по ночам не работает, поэтому организаторы пошли на беспрецедентный шаг: находиться на площадке вообще не обязательно. Как долго я ждал, пока до этого кто-то догадается! Интроверту (типа меня) нужно иногда отключаться от общения с людьми. Имхо, в этом и есть определение интроверта — человек, который не может полностью отдохнуть, общаясь с людьми. Причём, я на три дня прилечу на самолёте и заночую у друзей, а у кого-то рядом есть уютный тёплый офис со своей атмосферой, и торчать всё время в Сколково — не рационально. Вся эта необходимость круглосуточно сидеть на площадке люто напрягала меня на других аналогичных мероприятиях — а здесь, слава хаосу и анархии, такого не будет.Отдельно я получил от департамента корпоративных коммуникаций неформальное заверение, что все права на разработанный софт останутся за разработчиками. Это хорошо и честно. (Сейчас могие организаторы хакатонов (не будем тыкать пальцами) приобрели отвратительную привычку заставлять заполнять пачку бумаг, по которым ты обязан передать им не только исходники, но ещё и душу. Нужно бороться с этим и всячески давать понять, что мы в таком участвовать не собираемся.) То есть, грубо говоря, можно делать не рандомную фигню, а реальный сайд-проект, или даже решать рабочие вопросы.Отдельный вопрос — как найти себе команду. Если ты, читатель, такой же хиккан и как и я, это нетривиально. Как вы вообще это представляете: подойти к случайному человеку на улице, и предложить: ""девушка, давайте похакатонимся""? Можно попробовать использовать для этого комментарии Хабра: нужно прямо сейчас написать в комметариях, что ты хочешь участвовать. Прямо сейчас — потому, что потом забудешь.КонференцияОбщая канва конференции следующая: блокчейн, квантовые вычисления, искусственный интеллект, интернет вещей, распределённые хранилища, девопс.У неё есть программа, и она прямо сейчас живо формируется. Поэтому на веб-страничке с программой до сих пор есть пробелы.Очевидно, Сбертех приведёт туда много своих экспертов. Про DevOps будет рассказывать начальник тестировщиков, про кванты — руководитель соответствующего направления, про IoT — директор центра развития биллинговых систем. У меня на всех этих людей один конкретный план — поймать их в кулуарах и задать ряд животрепещущих вопросов.Но кроме этого будут ещё и внешние специалисты. Точно будут товарищи из IBM, которые расскажут про QISKit, Watson и IoT.Возможно, даже я сам смогу втиснуться с докладом о настоящем и будущем Java. Мотивация простая: половина софта, о котором идёт речь на конференции, работает на JVM. Времени на подготовку оказалось очень мало и рассказывать я смогу только то, что знаю ""без подготовки"". Например, о произошедшем в Java 9, плане выпуска релизов, и составе JEPов для Java 10 и 11. Но всё это пока вилами по воде писано.Гвоздь программы — это «печа-куча» по блокчейну. Звучит это слово несколько дико, поэтому пришлось расчехлить википедию:Методология представления кратких докладов, специально ограниченных по форме и продолжительности, на неформальных конференциях PechaKucha Nights. Выступающий представляет доклад-презентацию из 20 слайдов, каждый слайд демонстрируется 20 секунд, после чего автоматически сменяется на следующий. Таким образом продолжительность доклада ограничена 6 минутами 40 секундами или 6 минутами. Доклады следуют один за другим. Количество докладов обычно варьируется от 8 до 12. После каждой презентации делается перерыв на drink & talk для обмена идеями.Понятия не имею, смогут ли выдержать такой жёсткий формат на Cradle:Rave, но если получится — будет круто. В реальности, судя по программе, это некий единый блок докладов по блокчейну, занимающий два стандартных таймслота. План всё тот же самый — по одному выловить всех этих людей и задать вопросы. Сейчас вокруг блокчейна огромный хайп, но вот людей, которые могут осмысленно объяснить как его использовать и получить с этого профит — совсем немного.Выводы16.02-18.02 будет интересный гибридный ивент (хакатоны+конференция), посвященный блокчейну, бигдате, квантам, и дргуим свежим вещам. Всё это не особо пиарилось в Сети, но похоже, вполне может выйти хорошо и интересно. Рекомендую зайти и взглянуть одним глазком, а для настоящим джедаям — записаться на хакатон."
wirex;Исследование рынка Blockchain от PwC: потенциал применения и основные тенденции;Блог компании Wirex Финансы в IT Криптовалюты;"«Ключевая идея, которую мы хотим выразить, состоит в том, что блокчейн — это эволюционный скачок в развитии технологий оптимизации бизнес-процессов. Децентрализованные распределенные базы данных предоставляют участникам рынка такие возможности изменения облика финансового сектора, которые, как правило, появляются лишь раз в поколение».

Такой вывод относительно блокчейн и связанных с ним технологий делает авторитетная международная компания PriceWaterhouseCoopers в своем масштабном исследовании финтех-рынка, проведенном в этом году. Мы в Wirex, как поставщик финансовых услуг с использованием blockchain и без банковского посредничества, придерживаемся такой же точки зрения. В ходе исследования компания PwC провела крупный опрос, участниками которого стали 544 руководителя крупных финансовых учреждений и их подразделений из 46 стран мира. Опрос показал, что 56% респондентов осознают важность технологии блокчейн, однако 57% участников признали, что в данный момент не имеют четкого представления, о том, как их компаниям следует реагировать на те возможности, которые она предоставляет.";/ru/company/wirex/blog/371957/;"«Ключевая идея, которую мы хотим выразить, состоит в том, что блокчейн — это эволюционный скачок в развитии технологий оптимизации бизнес-процессов. Децентрализованные распределенные базы данных предоставляют участникам рынка такие возможности изменения облика финансового сектора, которые, как правило, появляются лишь раз в поколение».Такой вывод относительно блокчейн и связанных с ним технологий делает авторитетная международная компания PriceWaterhouseCoopers в своем масштабном исследовании финтех-рынка, проведенном в этом году. Мы в Wirex, как поставщик финансовых услуг с использованием blockchain и без банковского посредничества, придерживаемся такой же точки зрения. В ходе исследования компания PwC провела крупный опрос, участниками которого стали 544 руководителя крупных финансовых учреждений и их подразделений из 46 стран мира. Опрос показал, что 56% респондентов осознают важность технологии блокчейн, однако 57% участников признали, что в данный момент не имеют четкого представления, о том, как их компаниям следует реагировать на те возможности, которые она предоставляет.Эксперты PwC считают, что несмотря на свою перспективность, блокчейн все еще встречает на своем пути немало преград и вызовов. Во многом это можно объяснить недостаточным пониманием технологии со стороны игроков финансового сектора. Восемьдесят три процента респондентов ответили, что знакомы с ней в общих чертах и лишь 17% руководителей ответили, что знакомы с ней очень хорошо (15%) или назвали себя экспертами в области (2%).В то же время, как отмечают авторы исследования, «понимание блокчейн и его коммерческих возможностей требует четкого представления о том, как можно связать воедино самые разные, зачастую никак не пересекающиеся друг с другом области знаний». А недостаток такого понимания, по их мнению, приводит к тому, «что участники рынка рискуют недооценить потенциальное влияние новой технологии на свою основную деятельность».Наиболее высокий уровень осведомленности отмечается среди платежных компаний, и других учреждений, занятых переводами средств. Тридцать процентов участников опроса, работающих в этой области, ответили, что очень хорошо знакомы с предметом.Как и многие другие эксперты, специалисты PwC также отметили скорость, с которой эта сфера деятельности подвергается изменениям: «Блокчейн развивается и распространяется с беспрецедентной скоростью. Чтобы превратиться из стартапной идеи в зрелую технологию, ему потребовалась лишь малая часть того времени, которое понадобилось интернету или персональным компьютерам, чтобы стать привычными для всех атрибутами повседневной жизни».Потенциал применения технологииАвторы исследования считают, что распространение блокчейн может привести к радикальному изменению конкурентного ландшафта в финансовом секторе. Текущие фонды прибыли будут перераспределены в пользу владельцев новых эффективных блокчейн платформ.Специалисты PwC выделяют следующие положительные возможности, связанные с практическим применением блокчейн:1. Упрощение доступа к финансовым услугам для жителей развивающихся странМиллиарды людей по всему миру лишены доступа к банковским услугам и обмену валюты. Мы уже писали в нашем блоге о примерах того, как новые финансовые технологии могут полностью разрешить эту проблему.2. Появление новых стартапов и компанииБлокчейн-стартапы появляются с невиданной доселе скоростью. Количество идей велико, а сами они разнообразны. По данным PwC, рынок насчитывает более тысячи игроков, как новых, так и уже обосновавшихся, и цифра эта только растет.В качестве примеров других интересных стартапов PwC приводит криптовалютную биржу Coinbase, которая помогают своим клиентам продавать и покупать криптовалюту, хранить цифровые активы и защищать их от кражи. Libra помогает корпорациям вести учет и проводить анализ и аудит операций с цифровыми активами, независимо от того, какую блокчейн-базу они используют. Такие компании, как Blockstream, Digital Asset Holdings и itBit упрощают работу с цифровыми активами для финансовых учреждений, а опыт Eris Industries, поставщика решений в области так называемых умных контрактов, используется самой PwC в рамках интеграции в существующий бизнес клиента.3. Усовершенствование методов ведения бухгалтерииБлокчейн предлагает возможность создания распределенной, прозрачной, работающей практически в реальном времени бухгалтерской книги, пользоваться которой можно в том числе для анализа данных и подтверждения их подлинности. Применение блокчейн в таком ключе снижает время и усилия, затрачиваемые на синхронизацию (сверку) данных между разными компьютерными системами, и открывает возможность интегрировать бухгалтерию компании с множеством внешних источников информации.4. Более гибкое управление денежными резервамиУвеличение скорости и возможность мгновенного оповещения снизит количество денег и других залоговых активов, которые банку необходимо удерживать, чтобы снизить риски взаиморасчета с другими банками и финансовыми учреждениями. Прозрачность технологии также способствует этому, поскольку повышает уровень доверия партнеров к подобным системам.5. Улучшение взаимодействия с финансовыми регуляторамиНаличие центральной, неизменяемой и прозрачной базы операций позволит аудиторам и регуляторам быстро и в реальном времени отслеживать поток финансовых данных, устраняя какую-либо потребность в перепроверке данных постфактум.6. Улучшение качества повседневных финансовых операцийНовые виды брокерских счетов на основе умных контрактов могут исключить посредничество и предоставить возможность участникам фондовых, валютных и других рынков работать напрямую друг с другом. Вполне возможно, что некоторые функции, такие как обмен сообщениями, клиринг и взаиморасчет, выполняемые SWIFT, центральными банками и платежными сетями, будут осуществляться напрямую автоматизированными биржами. Даже выпуск новых активов может осуществляться на базе блокчейн.7. Умные контрактыPwC называет их одним из наиболее актуальных способов применения новой технологии. Умные контракты представляют собой написанные c помощью программного кода наборы правил, работающие на основе базы данных блокчейн. Считается, что сфера их применения очень широка: от простой организации голосования во время обсуждения до более серьезных задач, таких как залогообразование, создание фьючерсных контрактов и даже приоритизации выплат по структурированным финансовым продуктам.Основные тенденции рынка блокчейн в 2016 годуПомимо опроса, PwC также внимательно следит за развитием событий на рынке и анализирует деятельность отдельных компаний. В общей сложности, по утверждению компании, ее специалисты исследовали более 1 тыс. связанных с блокчейн стартапов, а также провели финансовую и техническую экспертизу группы подобных компаний, посвятив этой деятельности суммарно более 10 тыс. часов.С целью предоставить игрокам финансового сектора и другим его участника полноценную картину того, как сейчас выглядит рынок финансовых технологий, PwC запустила отдельную аналитическую платформу под названием DeNovo, посвященную исследованию влияния технологий на финансовый сектор.В области блокчейн-технологий эксперты компании насчитали более 700 новых участников рынка, 150 из которых заслуживают пристального внимания, а 25 из них имеют потенциал стать лидерами рынка. На основе имеющихся данных компания определила три основных тенденции развития блокчейн сегмента, которые, по ее мнению, будут четко прослеживаться в 2016 году.Тенденция №1. Зарекомендовавшие себя участники рынка сосредоточатся на защите интеллектуальной собственности.Компании, деятельность которых так или иначе связана с финтех-рынком, вероятно, уже сейчас рассматривают варианты интеграции блокчейн в свой бизнес. Авторитетные игроки вроде банков или бирж ищут способы улучшения качества всех предоставляемых ими услуг и продуктов. В то же время стартапы и поставщики услуг, понимающие блокчейн-технологию, ищут лучшие способы дополнить подобные бизнес-процессы. В 2016 году PwC рекомендуют традиционным финансовым учреждениям вступать в подобный диалог с целью получить лучшее понимание того, какую интеллектуальную собственность им придется делить с другими игроками.С технической точки зрения многие участники рынка уже работают сообща над внедрением тех или иных разработок. Тем не менее стратегические и бизнес-партнерства однозначно не вписываются в такую открытую модель взаимодействия. Исходя из этого, традиционным финансовым учреждениям следует сформировать фундаментальное техническое понимание вопроса, поскольку оно позволит лучше определить, какой информацией следует делиться на открытых форумах, а какую оставить конфиденциальной.Тенденция №2. Принятие сопряженных с риском технических решений должно основываться на стратегических планах компании.В 2016 году все больше новых игроков будут приходить на рынок и вступать в конкуренцию с уже обосновавшимися там участниками. В результате этого финансовые учреждения столкнутся с огромным выбором вариантов сотрудничества. В 2015 году многие участники начали открыто говорить о своих инновационных идеях, связанных с блокчейн. Тем не менее другие компании, не делавшие подобных заявлений, все это время также работали над созданием собственных технических решений. Это позволяет с уверенностью утверждать, что уже в этом году рынок пожнет плоды этих инвестиций. Рассматривая доступные варианты, финансовые учреждения столкнутся с новой задачей, требующей решения: оценка перспективности сотрудничества с теми или иными финтех-партнерами.Компании, желающие разработать проекты проверки концепции, пилотные проекты или даже сделать прямые инвестиции, должны понимать, какую финансовую позицию занимают их потенциальные партнеры и каковы их стратегические цели. В текущей ситуации определить, кто переживет следующий раунд финансирования невозможно, однако PwC указывает на то, что разница между успешными стартапами и теми из них, кто практически исчерпал финансирование или будет вскоре приобретен, существует, и компании, желающие преуспеть, должны уметь ее увидеть.В конечном счете, PwC рекомендует компаниям заняться разработкой стратегических планов, которые помогут задать конкретные параметры и критерии отбора проектов и партнеров, а также определиться с общим направлением инвестирования.Тенденция №3. Акцент разработки и тестирования блокчейн-проектов сместится с операционной деятельности но проработку связанных с ней процедур.В 2015 году львиную долю своего внимания рынок уделял решениям, направленным на проверку концепции на уровне проведения операций. В этом году мы увидим, как акцент постепенно сместиться к поддержке нового уровня систем и процессов, которые будут базироваться на проверенных ранее и успешных операционных решениях.Это значит, что если раньше основным вопросом, которым задавались финансовые институты, был: «Как мы можем использовать блокчейн в своих целях?», то теперь актуальность получит новый вопрос: «Как построить другие связанные с блокчейн процессы так, чтобы получить от его использования максимальную выгоду?»; или другой, еще более важный: «Какое влияние эти новые процессы окажут на наш профиль рисков?»В этом смысле компания рекомендует участникам рынка уделить особое внимание таким областям деятельности, как организация управления, аудит и информационная безопасность.Основные закономерности, на которые следует ориентироваться в 2016 году и в будущемПреимущества новых технологий редко распределяются поровну между участниками рынка. Другими словами, победители и проигравшие есть всегда. Таким образом, уже сейчас можно сказать, что многие игроки не получат той бизнес-выгоды, которую они ожидают увидеть от появления новых технологий.Эксперты PwC считают возможным следующий вариант развития событий: технически подкованные участники рынка наладят стратегические партнерства с небольшими группами других продвинутых игроков (микроконсорциумами). Это позволит им сосредоточиться на трансформации дорогих внутренних процессов и предложить результаты этой работы в рамках эффективных платформ общего пользования. Такие платформы впоследствии могут продаваться в качестве услуг более малым конкурентам.Способность строить сотрудничество с небольшой группой ключевых партнеров на уровне стратегии и бизнеса, по мнению PwC, может стать ключом к получению конкурентного преимущества в течение следующих нескольких лет. В целом все участники финансового сектора должны занять активную позицию с точки зрения реакции на возникающие угрозы и новые возможности, которые возникнут вместе с распространением технологий.Подготовлено по материалам PwC. Присоединяйтесь к нам, заказывайте двухвалютную карту Wirex MasterCard. Напоминаем, что виртуальная карта выдается бесплатно сразу после установки приложения на Android или iOS устройство. До встречи в блоге Wirex."
Menaskop;Bitcoin & Blockchain в Иркутске: как здесь оказался CEO Chronobank и другие ответы на вопросы;Я пиарюсь;"Так уж случилось, что на Хабр пишу часто, а сюда — нет. Но сегодня, а точнее — ещё 20 апреля года нынешнего, появился отличный инфоповод закрыть этот пробел. 

В Иркутск приехал известный в блокчейн-сообществе эксперт, энтузиаст и глава Хронобанка — Сергей Сергиенко (отвечу сразу, здесь он был по сугубо личным делам, т.к. родители супруги живут в Шелехове, но это не помешало ему поучаствовать в митапе).

Меньше чем за неделю сообщество B&B в Иркутске открылось мне с новых, совершенно неожиданных, ракурсов. О сим и хочу рассказать людям из Хабра и Гигтаймс.";/ru/post/373399/;"Так уж случилось, что на Хабр пишу часто, а сюда — нет. Но сегодня, а точнее — ещё 20 апреля года нынешнего, появился отличный инфоповод закрыть этот пробел. В Иркутск приехал известный в блокчейн-сообществе эксперт, энтузиаст и глава Хронобанка — Сергей Сергиенко (отвечу сразу, здесь он был по сугубо личным делам, т.к. родители супруги живут в Шелехове, но это не помешало ему поучаствовать в митапе).Меньше чем за неделю сообщество B&B в Иркутске открылось мне с новых, совершенно неожиданных, ракурсов. О сим и хочу рассказать людям из Хабра и Гигтаймс.Meetup, или что нужно сделатьВо-первых, уникальность события в том, что организовать его смогли за каких-то 1.5 дня (начиная от идеи, лендинга и заканчивая продажей билетов, которая, к слову, прошла неплохо, через pokupo и собственно — встречей), то есть интерес к блокчейн-технологиям, как у нас говорят, «в народе есть». Во-вторых, Сергей Сергиенко — не каждый день бывает в Сибири, поэтому новость на местном «MCM-радио» быстро разошлась полезным слухом по городу. И всё же по опросам публики на входе — большинство ни Сергеем, ни с блокчейн-именами знакомо не было вообще, то есть интерес есть, но пока это только интерес и превратить его во что-то продуктивное — дело не одного дня, и, скорее всего, даже не одного года.В-третьих, само событие показало, что вопросов сейчас много и далеко не все они технические. Например:Чем же так полезен блокчей?Где именно и как хранить средства в крипто-?На сколько всё это безопасно?Какие криптовалюты существуют?Что на блокчейне сделано, кроме собственно криптовалют?Какие направления можно считать перспективными?И ещё с десятка два вопросов в этом же русле.Майнинг, трейдинг, crypto-commerce, или что уже сделаноВторая часть пришедших представляла ту часть, что называют майнерами. Поясню, чтобы сразу же снять лишние вопросы: стоимость электричества в Иркутске — крайне мала. Были даже времена, когда наш регион был первым в мире по этому показателю (то есть тарифы были самыми низкими). Именно поэтому даже среди «официальных» (читай — тех, что святят IP) нод Bitcoin есть и из нашего региона. Правда, как я понял, не все майнеры любят подобный «шум» ака собрания под любым соусом и названием: причины довольно банальны — желание делать всё «по-тихому» и «без лишнего внимания». Правда, как это вяжется с открытой идеологией блокчейна — мне не ясно. Впрочем, всякий имеет право на личное мнение. Идём дальше.Одной из ключевых фигур майнинга в области является Юрий Дромашко, который сам себя в шутку называет «официальным представителем Сатоши Накамото по Сибирскому федеральному округу». После семинара был у него в гостях и удивился, насколько разные люди покупают сейчас асики: особенно меня поразила мама двух детей, которая приобрела у Юрия уже второй аппарат и более четырёх месяцев посвятила майнингу. Кроме неё были и разного рода бизнесмены, причины «войти в майнеры» у каждого из них своя: у кого-то основной бизнес начал чахнуть из-за излишнего давления сверху, кто-то захотел «попробовать силы в чём-то новом», а кому-то это просто интересно и в этом видят «ещё одну возможность получить доход». Кстати, сам Юрий ввёл в оборот интересный маркетинговый инструмент под названием «Эквивалент», который принимает уже ряд заведений г. Иркутска: то есть частные «деньги» у нас живы не только online, но и offline. Кстати, в моих разъездах после митапа (а всего их было 18) узнал, что «Bitcoin accepted here» — стала относительно популярна в городе. Цвет — не только классический оранжевый, но и синий (эти наклейки, как выяснил, распространяет как раз Юрий).Следующей большой группой, которую стоит назвать, являются, конечно же, трейдеры. С ними у меня завязалась жаркая дискуссия, т.к. на мой взгляд спекуляции — пережиток прошлых систем, который даёт возможность централизовать любую p2p-структуру. И всё же мы едины в том, что Bitcoin & Со-братья — это не просто «валюты», а деньги будущего. Правда, в это предстоит ещё вложить не мало труда. Так, например, на следующий день после встречи блокчейн-сообщества, 21.04.17, я был в IT-секциии Библионочи — ежегодного события, собирающего под одной крышей свыше 3000 человек (в основном — студенты и дети, но есть и категории многим старше). И там натолкнулся на непонимание того, что есть блокчейн и кому он нужен. Если говорить совсем точно и правдиво, то это было даже не непонимание, а прямое не желание «считаться с этой технологией».И именно там, в жаркой полемике с ярыми противниками blockchain, пришёл к выводам, которые уже не раз посещали меня (да и не только меня):Блокчейн — это технология, но не только. И в первую очередь это идеология, новая и не популярная, но очень привлекательная. Во-вторых, это сообщество: молодое и разное, но в нём уже сформировались свои принципы. Например, С. Сергиенко прямо сказал, что «скамы мы (т.е. сообщество) не приемлем и стараемся с ними бороться». Почему? Потому что фейк-системы не выгодны никому: ни инвесторам, ни разработчикам, ни трейдерам, ни другим участникам в принципе.Технари, во многих случаях разобравшись лишь с верхушкой айсберга блокчейн, очень снисходительно относятся к тем, кто этого не сделал. И это — сильнейший тормоз на пути понимания первого аспекта (идеологического) и развития второго (сообщества). И на встрече, и особенно на Библионочи, это было видно чересчур хорошо. При этом собственно блокчейн-разработчиков не так много (но они есть), а пригласить их на какую-то встречу — это вообще титанический труд, который ещё предстоит.При этом представители крупных объединений блокчейна (будь то Бутерин или Сергиенко) как раз наоборот стараются донести как можно до самой широкой публики, что есть данная технология и кому, зачем и почему она может понадобиться. Это своего рода диалектика, но пока она мала похожа на то, что называют модным словом «синергия».И выводы выше — универсальные. Не только про Иркутск: был в этом году в разных городах России (от нашего и до Питера, через Казань и т.д.). Самое интересное, что энтузиазм пока очень быстро угасает, даже у самых ярких представителей. Но с другой стороны — это закономерность любого развития. Выводы же по Иркутску следующие:Сообщество начало формироваться и грани его вполне ощутимы;Уже есть своя мини-экономика (майнеры, трейдеры, обменники и даже продавцы и покупатели) на основе p2p;Самое главное — популяризация привлекает даже тех людей, которые и слыхом не слыхивали о блокчейне и криптовалютах: безусловно, не все из них после уходят с головой в изучение и главное — практику реализации, но даже по митапу судя — это больше, чем 10%;Есть огромный пласт людей, которым нужно объяснить многое: от самого простого и до тонкостей протоколов, например. И для этого нужно формировать уже сообщество экспертов, чем сейчас и заняты.Наконец, именно общие встречи рождают правильные вопросы и новые идеи (сейчас знаю обсуждаются два совместных проекта — посмотрим, что из этого получится). И даже неконструктивная критика приводит к положительным результатам.Благодарю за прочтение. Вопросы и пожелания приветствуются."
SLY_G;VISA планирует развивать blockchain-платежи;Финансы в IT Криптовалюты Будущее здесь;"В конце февраля на сайте вакансий компании VISA появилось объявление  о поиске ведущего программиста в новое подразделение компании Visa Research. Одним из направлений его деятельности, судя по тексту вакансии, является разработка новых методов платежей – в частности, платежей на основе цепочки блоков.

Blockchain, или цепочка блоков – технология, придуманная для использования в криптовалютах типа биткоин. Отличительными особенностями технологии являются открытость и распределённый доступ к информации, в том числе — ко всем проведённым операциям.

Также в вакансии  упомянуты возможность работы с виртуальными валютами. Кроме систем платежей будущего, задачами Visa Research названы аналитика данных и безопасность.

Среди должностных обязанностей упомянуты дизайн и разработка безопасной и масштабируемой сети цепочки блоков (с непосредственным участием в разработке, тестировании и создании документации). Предполагается, что программист будет работать по методике Agile и должен уметь быстро переключаться между задачами.";/ru/post/391321/;В конце февраля на сайте вакансий компании VISA появилось объявление  о поиске ведущего программиста в новое подразделение компании Visa Research. Одним из направлений его деятельности, судя по тексту вакансии, является разработка новых методов платежей – в частности, платежей на основе цепочки блоков.Blockchain, или цепочка блоков – технология, придуманная для использования в криптовалютах типа биткоин. Отличительными особенностями технологии являются открытость и распределённый доступ к информации, в том числе — ко всем проведённым операциям.Также в вакансии  упомянуты возможность работы с виртуальными валютами. Кроме систем платежей будущего, задачами Visa Research названы аналитика данных и безопасность.Среди должностных обязанностей упомянуты дизайн и разработка безопасной и масштабируемой сети цепочки блоков (с непосредственным участием в разработке, тестировании и создании документации). Предполагается, что программист будет работать по методике Agile и должен уметь быстро переключаться между задачами.Среди требований – высшее образование в этой сфере, опыт работы более 5 лет с Java, Scala, JavaScript, опыт работы с криптографией, системами контроля версий, и прочие навыки. Предполагаемый уровень заработной платы не указан.Прошлой осенью компания VISA вложилась в стартап Chain, собравший инвестиций на $30 миллионов на развитие технологии цепочки блоков.Технологией давно интересуются и крупнейшие банки – в январе консорциум R3CEV, состоящий из 42 банков, провёл первые успешные испытания технологии в применении к традиционным финансовым операциям. В тесте участвовало одиннадцать членов консорциума. Консорциум R3CEV был основан в 2014 году, и с тех пор к нему присоединилось уже более 40 банков, в частности Barclays, Credit Suisse, Goldman Sachs, J.P. Morgan, Royal Bank of Scotland, Bank of America, Commerzbank, Deutsche Bank, Morgan Stanley, National Australia Bank, Royal Bank of Canada, UniCredit, Wells Fargo и другие.
mrKron;В чем сила IoT, брат? В Blockchain;Блог компании Unet Интернет вещей;Активное внедрение Интернета вещей (IoT) в повседневную жизнь наталкивается на ряд проблем, от успешного решения которых будет зависеть массовость и доступность этой перспективной концепции. Прежде всего, это обеспечение глобального и безопасного масштабирования IoT-системы и быстроты взаимодействия входящих в нее устройств. Решить их способна не менее прорывная технология — Blockchain.;/ru/company/unet/blog/409385/;Активное внедрение Интернета вещей (IoT) в повседневную жизнь наталкивается на ряд проблем, от успешного решения которых будет зависеть массовость и доступность этой перспективной концепции. Прежде всего, это обеспечение глобального и безопасного масштабирования IoT-системы и быстроты взаимодействия входящих в нее устройств. Решить их способна не менее прорывная технология — Blockchain.Децентрализация + блокчейн = довериеРеализация широких возможностей Интернета вещей при помощи централизованных сетей показала трудоемкость и плохую масштабированность этого процесса. При этом вопросы безопасности в отдельных системах становятся важнее быстродействия и отклика «умного» устройства. С появлением блокчейн-технологии появилась возможность решить ряд «узких» мест, препятствующих воплощению IoT.Не вдаваясь в технические подробности, напомним, что блокчейн-технология — это DLT-технология, посредством которой пользователи получают возможность создания, записи и считывания любого типа информации без риска ее снятия и редактирования третьими лицами. Блокчейн («цепочка блоков») — журнал с фактами, который реплицируется на несколько устройств, объединенных в одноранговую сеть (P2P), при этом фактами могут быть любые виды данных. Такие данные, хранящиеся в блокчейне, верифицируются специальными программами — майнерами.Сегодня цифровой мир начинает постепенно уходить от модели взаимодействия с центром в облаке к децентрализованной, где все — пользователи, «умные» устройства, роботы, бизнес, государство и т.д. будут связаны межу собой.И главным для них будет вопрос доверия, обеспечить которое сможет блокчейн. В блокчейне отсутствует централизованный элемент управления или какой-либо иной способ вмешательства в его работу. В отличие от типичной базы данных, размещенной на централизованном сервере, являющимся собственностью какого-либо лица (компании или конкретного человека), блокчейн рассредоточен среди большого числа пользователей сети. И главное здесь то, что никто из них по отдельности не может его контролировать.Хотя в децентрализации сети с равноправными устройствами нет ничего нового, блокчейн интересен тем, что способен решать проблемы согласования путем алгоритма доказательства выполненной работы (proof-of-work), использующий блоки. В техническом плане блокчейн опирается на «три кита»: распределительные P2P-сети, асимметричную криптографию и распределенный консенсус.Использование блокчейн-технологии дает возможность быстрого и безопасного сохранения протоколов обмена и результатов совместной работы различных устройств в децентрализованной системе. Распределенная архитектура блокчейна гарантирует достаточно высокую безопасность. Если часть из устройств сети будет подвержена взлому, это не скажется на работе всей системы.Отдельные эксперты считают, что применение блокчейн-технологии сотворит в IT революцию, подобную изобретению Интернета, а вместе с IoT они станут главными движителями развития большинства отраслей глобальной экономики. Сегодня в разработки на основе блокчейна инвестируются серьезные деньги, поскольку есть экономический стимул — блокчейн дает возможность отказаться от централизованных посредников, которые обеспечивают доверие между участниками системы, а это очень существенная экономия. Доверие же к блокчейну базируется на том, что он фиксирует последовательность операций по времени и защищает их от манипуляций.«Блокчейная» безопасностьЧтобы концепция IoT стала массовой, ей нужны защищенные Р2Р-сети, способные надежно передавать сведения между всеми устройствами и участниками. И чем больше их будет, тем более значимым будет запротоколированный результат их взаимодействия, к примеру, точная идентификация объектов экосистемы, трекинг их истории в сети и т. д. То есть, любые данные о коммуникации каждого устройства с другими объектами будут занесены в его индивидуальный блокчейн.С ростом числа сетевых устройств серверы, через которые они обмениваются данными, становятся «слабым звеном» как в плане продуктивности, так и надежности. Сегодня пока только блокчейн-технология по своим возможностям может гарантировать стабильную работоспособность всей постоянно масштабируемой IoT-системы, обеспечивая при этом безопасность и аутентичность информации. Поэтому неудивительно, что первой сферой применения блокчейна в Интернете вещей стала безопасность данных.Участившиеся во всем мире взломы баз данных и DNS-атаки, приводившие к временному отсутствию Интернета, использование «умных» устройств в качестве ботов в DDoS-атаках стали толчком к переосмыслению безопасной работы IoT-систем и блокчейн сыграл здесь не последнюю роль.Благодаря технологии распределенного реестра появилась возможность создать наивысший на сегодня уровень безопасности в сети, и покончить с имеющимися ограничениями, связанными с централизацией, а по сути — с рисками, которые она несет для IoT.Упомянутое использование ботнетами «умных» устройств, работающих в IoT-системах, стало возможным вследствие их слабой защищенности. Распределенный тип доверительных отношений позволяет избавиться от «сломанного» устройства без ущерба для всей модели взаимодействия между «здоровыми» объектами.Также, если IoT-сеть достаточно обширна и разбросана, нередко возникают перебои со связью с главным сервером. Децентрализация сети и блокчейн дают возможность наладить обратную связь с ним через другое устройство. Таким образом, децентрализованная архитектура поможет нивелировать критические ситуации, одновременно обеспечив стандартные протоколы устройств по распознаванию и связи между ними.И это только начало...Если говорить о практической реализации связки блокчейн-технологии и IoT, то в последние два-три года наблюдается стойкий интерес к решениям, использующим распределительный реестр. Лидером здесь можно назвать банковско-финансовую сферу, которая начинает вкладывать инвестиции в P2PE, чтобы защитить целостность платежей и данных банковских карт. Несколько ведущих мировых банков даже создали консорциум «R3» для разработки решений для банковской сферы на основе блокчейн-технологии, и в прошлом году им уже был представлен проект для финансовых сервисов «Corda».Помимо финансовой, есть еще немало сфер, где применение блокчейн-технологии будет способствовать активному внедрению Интернета вещей. Это, в частности, борьба с кибермошенничеством, управление аутентификацией, верификация работоспособности различных сервисов, логистика, обеспечение сохранности данных и другое. Сегодня многие компании уже представили несколько решений по совершенствованию IoT-систем с применением блокчейна. Так, «монстр» Интернет-торговли Alibaba в сотрудничестве с несколькими компаниями разрабатывает решения для противодействия подделкам продуктов. Компания Bosch для предотвращения мошенничества в автостраховании внедрила решение, осуществляющее верификацию километража спидометра автомобиля. А IBM совместно с крупнейшим морским перевозчиком Maersk запустили пилотный проект по применению блокчейн-технологии в трансграничной цепи глобальных морских поставок.При этом и сам IoT вносит свою лепту в реализацию блокчейна, например, в сфере регистрации права собственности или заключения контрактов. Стоит отметить, что отдельные страны готовы работать над внедрением в качестве эксперимента новой системы голосования на выборах на основе блокчейна. Считается, что это увеличить степень их прозрачности и сделает невозможными любые манипуляции.Можно привести еще много примеров, но на самом деле возможности применения технологии распределенного реестра в Интернете вещей очень обширны и с каждым днем появляются, и будут появляться новые решения в самых неожиданных сферах. И, безусловно, блокчейн-технология еще далека от своего пика развития, а в сфере IoT она и вовсе находится на начальном этапе. Тем не менее, соединение этих технологий, по мере их практической реализации, уже в скором времени кардинально изменит архитектуру большинства действующих сегодня IT-экосистем. Все идет к тому, что их развитие все больше будет связывать различные сферы жизнедеятельности человека с «умными» устройствами. Поэтому, очень важно, чтобы эта связь была надежной, безопасной и реально полезной для пользователей.
snvakula;Равертывание Emercoin blockchain с веб-кошельком на RedHat/CentOS 7 и Ubuntu 16.04;Криптография *Открытые данные *Разработка под Linux *;Одним из современных технических мейнстримов является блокчейн. В этой статье я расскажу как можно быстро развернуть Emercoin блокчейн на RedHat/CentOS 7 и Ubuntu 16.04 LTS.;/ru/post/304100/;"Одним из современных технических мейнстримов является блокчейн. В этой статье я расскажу как можно быстро развернуть Emercoin блокчейн на RedHat/CentOS 7 и Ubuntu 16.04 LTS.1. ВведениеВ этом материале мы будем исходить из следующего:У вас уже есть чистая предустановленная RHEL/CentOS 7 или Ubuntu 16.04 LTS, со стандартным набором пакетов, без специфических настроекРассматриваемые версии ПО: emercoin(0.3.7), emcssh(0.0.3), emcweb(1.0)В качестве веб-сервера будет использоваться ApacheВсе команды, приведенные ниже, должны исполняться либо пользователем root, либо через sudoРабота с SElinux в режиме Enforcing не гарантируется2. Установка пакетов EmercoinДля начала, мы должны подключить официальный репозиторий Emercoin для использования вашим сервером, скачать и установить требуемые пакеты, запустить клиент блокчейна и пометить его для исполнения во время загрузки ОС. Для этого, нужно выполнить:В RHEL/CentOS:rpm -ivh http://download.emercoin.com/rhel/el7/RPMS/emercoin-release-1.0-1.el7.centos.noarch.rpmyum -y install emercoin emcssh emcwebsystemctl restart emercoind httpdsystemctl enable emercoind httpdВ Ubuntu:apt-key adv --keyserver keyserver.ubuntu.com --recv B58C58F4add-apt-repository 'deb [arch=amd64] http://download.emercoin.com/ubuntu xenial emercoin'apt update && apt install emercoin emcssh emcweb3. Скачивание и управление блокчейномСразу после первого запуска emercoind, начнется скачивание блокчейна. На это может потребоваться какое-то время.Чтобы посмотреть текущее состояние блокчейна, нужно выполнить команду:emc getinfoОбращаю ваше внимание на то, что команду emc может исполнять любой пользователь системы, у которого есть права на исполнение команд через sudo. Также, хочу заметить то, что на старт службы emercoind может потребоваться до 30 секунд. Соответственно, если вы поспешите выполнить команду emc до полного старта emercoind, то у вас может возникнуть ошибка подключения к сервису.Результатом исполнения emc getinfo будет вывод нечто подобного:{    ""version"" : ""v0.3.7.0-unk-beta"",    ""protocolversion"" : 60005,    ""walletversion"" : 60000,    ""balance"" : 0.00000000,    ""newmint"" : 0.00000000,    ""stake"" : 0.00000000,    ""blocks"" : 6532,    ""moneysupply"" : 26500634.19000000,    ""connections"" : 7,    ""proxy"" : """",    ""ip"" : ""162.243.248.174"",    ""difficulty"" : 66.44524799,    ""testnet"" : false,    ""keypoololdest"" : 1466865671,    ""keypoolsize"" : 101,    ""paytxfee"" : 0.01000000,    ""errors"" : ""WARNING: Checkpoint is too old. Wait for block chain to download, or notify developers of the issue.""}Здесь нужно смотреть на строку «errors», которая может указывать на то, что, в данный момент, блокчейн слишком старый (то есть, не полностью скачанный), а, также, на строку «blocks», где указано сколько блоков уже скачано в вашем блокчейне. На момент написания этой статьи, в блокчейне Emercoin насчитывалось 173444 блока.Чтобы управлять блокчейном и вашим кошельком через консоль, можно воспользоваться помощью по опциям команды emc:emc help4. Веб-кошелекДля того, чтобы использовать веб-кошелек, у вас должен быть либо созданная учетная запись для него (логин+пароль), либо персональній SSL сертификат. Как использовать персональный SSL сертификат я расскажу в другой раз. Сейчас же, мы можем создать пользователя веб-кошелька командой:emcweb-user ""UserName"" ""UserPassword""где, UserName и UserPassword — конечно же, придуманные вами логин и пароль.У веб-кошелька может быть только одна учетная запись. Поэтому, если вы выполните команду emcweb-user повторно, то вы замените предыдущего пользователя новым.Следующим шагом мы можем в браузере перейти на IP-адрес вашего сервера.Браузер вас предупредит, что сайт небезопасен. Это нормально и совершенно безопасно, ведь, сертификат веб-сервера был автоматически сгенерирован на вашем сервере в момент устаноавки пакета emcweb. Поэтому, такое предупреждение браузера нужно проигнорировать и продолжить посещение этого ресурса (возможно, добавив этот сайт в исключения, как того требует Firefox, к примеру).Выбираем «Login via Login/Password» и вводим лоин с паролем, указанные вами при выполнении команды emcweb-user:Попадаем в веб-кошелек:Интерфейс веб-кошелька довольно простой и интуитивно понятный. К примеру, раздел с информацией, где можно увидеть похожие данные, получаемые исполнением команды emc getinfo:Известная ошибка: если блокчейн еще не полностью скачан и вы попытаетесь войти в раздел «Manage Names», то будет ошибка.Удачного пользования!"
user16;Декомпозиция blockchain;Информационная безопасность *Анализ и проектирование систем *Алгоритмы *;В данной статье будет рассмотрена максимально простая модель, описывающая сущность блокчейна. Специфика хранимой в блоках информации не рассматривается, будь то транзакции, умные контракты или что-то еще. То есть блоки просто хранят записи, значения которых зависят от конкретного применения. Такой подход позволит понять принцип работы блокчейна в целом, не затрагивая деталей конкретной реализации.;/ru/post/312654/;В данной статье будет рассмотрена максимально простая модель, описывающая сущность блокчейна. Специфика хранимой в блоках информации не рассматривается, будь то транзакции, умные контракты или что-то еще. То есть блоки просто хранят записи, значения которых зависят от конкретного применения. Такой подход позволит понять принцип работы блокчейна в целом, не затрагивая деталей конкретной реализации.Мы начнем от самой простой тривиальной модели и будем дополнять ее возможности, пока не получим полноценную модель.Определим цель использования блокчейна:Есть несколько участников, которые заинтересованы поддерживать целостность общего массива данных и дополнять его. Базовая модельДанные представлены последовательностью записей, которую можно дополнять. Записи вместе с вспомогательной информацией хранятся в блоках. Блоки хранятся в виде односвязного списка. Каждый участник представлен узлом(node), который хранит весь актуальный массив данных и контактирует с другими узлами. Узлы могут добавлять новые записи в конец списка, а также сообщают друг другу об изменениях списка.Последовательное расширение функционалаПриоритет более длинному спискуВыбирая между несколькими версиями списка записей, узлы сохраняют у себя более длинный. Таким образом, добавленная в одном узле новая запись распространяется на все остальные узлы. Хеш предыдущей записиВ блоке хранится хеш-код предыдущей записи. Такой хеш-код однозначно идентифицирует все предыдущие блоки и их взаимное расположение. Следовательно, блок внутри списка не может быть изменен без изменения последующих блоков.Вычислительная сложность создания блокаВ блоке добавляется новое поле — counter — произвольное число. Нужно подобрать такое значение counter'а, чтобы хеш-код блока заканчивался на определенное число нулей. Пул необработанных записейНовые записи попадают в пул. Узлы достают записи из пула, формируют блок, и после добавления блока в список удаляют запись из пула. Поручение майнинга третьим лицамЗаписи из пула выбирают майнеры, формируют блок и передают готовый блок узлу. На майнеров перекладывается основная вычислительная нагрузка.Узел проверяет блок и добавляет в список.Несколько записей в блокеВ блоке может быть несколько записей. Майнеры выбирают любые записи для формирования блока. Блок ограничен максимальной длинной. Ну вот и всё — концептуальная модель готова, спасибо за внимание.
Pavlov_dog;Malware + Blockchain = ??;Информационная безопасность *;"Эта статья является продолжением цикла о написании умных контрактов на платформе Ethereum. В первой части я пообещал показать, как создать новую криптовалюту на Solidity (в мире блокчейна это является чем-то вроде аналога ""Hello, world!""). Но на самом деле в этом нет смысла, так как об этом уже написано несколько хороших статей (пример из доков Solidity, пример с главной страницы Ethereum).
Так что я немного подумал и нашел еще один use case для умных контрактов. В данной статье я покажу, как теоретически автор трояна-шифровальщика может монетизировать свое детище, продавая ключи для расшифровки с помощью умных контрактов.
BTW все написанное ниже имеет чисто образовательный характер.";/ru/post/313710/;"Эта статья является продолжением цикла о написании умных контрактов на платформе Ethereum. В первой части я пообещал показать, как создать новую криптовалюту на Solidity (в мире блокчейна это является чем-то вроде аналога ""Hello, world!""). Но на самом деле в этом нет смысла, так как об этом уже написано несколько хороших статей (пример из доков Solidity, пример с главной страницы Ethereum).Так что я немного подумал и нашел еще один use case для умных контрактов. В данной статье я покажу, как теоретически автор трояна-шифровальщика может монетизировать свое детище, продавая ключи для расшифровки с помощью умных контрактов.BTW все написанное ниже имеет чисто образовательный характер.Общая идеяШифровальщики появились не вчера и имеют более-менее схожую схему работы. И как правило в этой схеме присутствуют шаги видаОплата выкупа через *coinОтправка некоторого ID зараженного ПК + ID транзакции преступникам Получение ключа для расшифровки файловВот эти три фрагмента системы мы и попытаемся перенести в блокчейн.Общая структура проектаНаш проект будет состоять из двух частей — модуль администрирования и модуль ""магазина"". Админку мы сделаем в виде отдельного контракта, а контракт магазина просто от него унаследуем. Вообще говоря, в Ethereum можно взаимодействовать между двумя различными контрактами в блокчейне, достаточно лишь знать их адреса и названия интересующих нас функций, но это я продемонстрирую как-нибудь в следующий раз.Tool boxПисать будем на Solidity версии 0.4.2 (текущая версия на 26 октября 2016). В качестве среды разработки можно использовать онлайн компилятор или только что вышедшую онлайн платформу Ethereum studio. Последняя сделана на базе c9.io, но с фичами для разработки под Ethereum. Сам не пользовался, так как вышла только-только, но выглядит симпатично, хотя документацию ее создатели прячут, наверное, специально.В качестве клиента-кошелька возьмем Mist, а так как мы делаем просто PoC, то и запускать все контракты будем на своем private блокчейне (как это сделать я рассказывал здесь). Так будет проще, дешевле (в смысле бесплатно) и быстрее.Пишем кодДля начала создадим модуль администрирования. В него мы добавим функционал для добавления и удаления администраторов, вывода денег и ""убийства контракта"". Первым делом определим все необходимые переменные и функцию-конструктор. Она должна называться так же как и сам контракт и вызывается лишь однажды (автоматически) — при загрузке контракта в блокчейн.pragma solidity ^0.4.2; // Указываем версию языка - любая, начиная с 0.4.2 до 0.5 не включительноcontract admin {     // VARIABLES     struct user {          address addr;          string name;  // '$uPeR_p0wner_1999'          string desc;  // 'CEO & CTO'     }     user owner;     mapping (address => user) adminInfo;     mapping (address => bool) isAdmin;     function admin (string _name, string _desc) {          owner = user({               addr : msg.sender, // msg - дефолтная переменная с информацией о пользователе               name : _name,      // вызвавшем контракт. msg.sender - его адрес               desc : _desc       // msg.value - сумма в wei, переданная контракту и т.д.          });          isAdmin[msg.sender] = true;          adminInfo[msg.sender] = owner;     }}Сам по себе код прост и понятен, благо синтаксис напоминает C++, JS, C, etc. На всякий случай напомню, что оператор struct позволяет создавать кастомные типы данных из уже имеющихся . Mapping, как можно догадаться реализует ассоциативный массив (dict в Python, map в C++).Здесь мы создали переменную owner, в которой с помощью struct храним адрес, имя и какой-нибудь description для создателя контракта. Контракты в Ethereum имеют так называемый state, то есть в дальнейшем, когда кто-то вызовет контракт, мы сможем воспользоваться этой переменной.Далее добавим функции, отвечающие за добавление / удаление администратора, вывод денег и уничтожение контракта. Здесь все вообще тривиально, кроме одной штуки — оператора event. Это очень симпатичный, с точки зрения UI и юзабилити вообще, оператор, который позволяет реализовать что-то вроде push уведомлений внутри контракта. Чуть нижу будет скриншот, из которого понятно, как это выглядит на практике.         // EVENTS     event adminAdded(address _address, string _name, string _desc);     event adminRemoved(address _address, string _name, string _desc);     event moneySend(address _address, uint _amount);     // FUNCTIONS     function addAdmin (address _address, string _name, string _desc) {          if (owner.addr != msg.sender || isAdmin[_address]) throw;    // Только владелец может добавлять / удалять админов          isAdmin[_address] = true;          adminInfo[_address] = user({addr : _address, name : _name, desc : _desc});          adminAdded(              _address,              _name,              _desc          ); // Call event     }     function removeAdmin (address _address) {          if (owner.addr != msg.sender || !isAdmin[_address]) throw;          isAdmin[_address] = false;          adminRemoved(              _address,              adminInfo[_address].name,              adminInfo[_address].desc          ); // Call event          delete adminInfo[_address];     }     function getMoneyOut(address _receiver, uint _amount) {          if (owner.addr != msg.sender || _amount  string) keys; // Пары ID - ключ    // EVENTS    event keyAdded(uint _ID, string _name, string _desc);    event keyBought(address _address, uint _ID);    // FUNCTIONS    function buyKey(uint _ID) payable { // Без модификатора payable на функцию нельзя отправлять эфир        if (msg.value < 15000000000000000000) throw; // Проверяем, что пользователь отправил нам минимум 15 этеров        orders.push(_ID); // Добавляем его в массив оплаченных заказов        keyBought(            msg.sender,            _ID        );    }    function getKeyByID(uint _ID) returns (string) { // Таким специфическим образом указывается, что вернет функция        return keys[_ID]; // Если ключ для этого ID еще не добавлен, то вернется пустая строка    }    function getLastOrder() returns (uint) {        if (!isAdmin[msg.sender]) throw;        return orders[currentOrder]; // Возвращаем первый ID        currentOrder += 1;    }    function addKey(uint _ID, string _key) {        if (!isAdmin[msg.sender]) throw; // Только администратор может добавить ключ для какого-то ID        keys[_ID] = _key;        keyAdded(            _ID,            adminInfo[msg.sender].name,            adminInfo[msg.sender].desc        );    }}ИтогЕще раз подчеркну, что написанное здесь — это прототип с кучей погрешностей и недоделок. Простой пример — в нашем случае массив заявок никак не чистится и только набирает в размере. Из-за этого, когда-нибудь стоимость вызова функции buyKey вырастет до стоимости самого ключа, что как-то неправильно.Другой, более сложный момент — для того, чтобы хранить порядковый номер последнего обработанного заказа, мы используем переменную currentOrder. А теперь представим ситуацию — есть два админа: Вася в Пекине и Петя в Нью-Йорке. В один момент времени они обратились к функции getLastOrder и оба получили какой-то номер — пусть 23412. Далее каждый из них вызвал функцию addKey и добавил в ""базу"" ключ для этого заказа, а вместе с ним сохранился его name и desc. В результате, когда майнеры начинают выполнять эти действия, те что поближе к Пекину, быстрее выполнят Васин запрос и state будет иметь один вид, а те что поближе к Нью-Йорку — Петин и state получится другой. В результате какой-то merge conflict.В любом случае, я надеюсь что мне удалось продемонстрировать, какие фантастические возможности предлагает нам технология блокчейна. Даже этот простой контракт предоставит хакерам возможность монетизировать зловред на порядок проще и безопаснее, по сравнению с привычными схемами. В следующей статье скорее всего напишу, как прикручивать к контрактам интерфейсы отличные от Mist (например взаимодействие через обычный сайт) ну или как работать с Ethereum в связке с каким-нибудь языком программирования, например Python. Но если есть какие-то предложения — обязательно пишите в комментарии."
Menaskop;Blockchain: будущее, которое стоит знать it-специалистам;Исследования и прогнозы в IT Учебный процесс в IT Финансы в IT;"Я знаю, что многие устали от хайпа вокруг Bitcoin, ETH и ICO. Но давайте же на it-ресурсе вернёмся к истокам: к технологии.

В этом, не очень большом, но содержательном, исследовании мне хотелось бы рассказать про несколько тонких мест в децентрализованных технологиях (блокчейн — конечно же, одна из них, основная, но не единственная), устранив которые каждый сможет создать прибыльный, интересный и полезный сервис.";/ru/post/336284/;"Я знаю, что многие устали от хайпа вокруг Bitcoin, ETH и ICO. Но давайте же на it-ресурсе вернёмся к истокам: к технологии.В этом, не очень большом, но содержательном, исследовании мне хотелось бы рассказать про несколько тонких мест в децентрализованных технологиях (блокчейн — конечно же, одна из них, основная, но не единственная), устранив которые каждый сможет создать прибыльный, интересный и полезный сервис.Централизованные сервисы опасныЗа последний год мне несколько раз крупно повезло: SEC & MAS выступили с заявлениями по ICO; btc-e накрыли и плотной крышкой, надо отметить; количество скам-проектов возросло просто в геометрической прогрессии; а главное — люди стали понимать, что бесконечный рост активов — вещь интересная, но плохо интегрируемая в реальность.Повезло, конечно, как специалисту в первую очередь. Как p2p-энтузиасту — тоже, но это метод от обратно: в социальной среде он действует болезнено.Главное, что бросается в глаза:Централизованные биржи — от «Полыни» до Кракена и обратно — являются одним из самых уязвимых мест в потоке «крипто-фиат». Пример btc-e — как раз про это. Впрочем, можно вспомнить и MtGox. Но, если смотреть в глубь, пусть не веков, но лет, то стоит найти и пример LibertyReserve, в год закрытия которой Bitcoin не даром показал свой первый значимый рост, измеряемый уже сотнями долларов за единицу.Не так давно Прокуратура (и опять у Северной Столицы Родины) заблокировала сразу 40 обменных пунктов, включая и агрегаторов обменников. И это при том, что Центробанк хочет «возглавить блокчейн революции», Минфин — отказался от репрессионного закона об уголовной ответственности за распространение информации о цифровых деньгах и их оборот, а Президент встречался ни с кем-нибудь, а В. Бутериным для обсуждения будущего и перспектив. Поэтому p2p-интернет: i2p, TOR-сеть или любой другой, даже ещё более глубинный — то, что найдёт свою нишу. И не только для Тёмной стороны.Сатоши Фонд также некоторое время назад написал буквально следующее: «ущественная часть пользователей не осознает рисков, связанных с вложением средств в блокчейн-активы, и возросшие риски по выпуску токенов — мы приняли для себя решение отказаться от хранения под своим контролем пользовательских блокчейн-активов и перепрофилироваться из кастодиана в производителя программного обеспечения. В связи с чем, взвесив все за и против, мы решили ликвидировать Satoshi Pie». Главная же мысль состоит в том, что инвестиции в формате p2p — это будущее. И это — именно так. Поэтому сервисы аналитики, оценки репутации, в том числе, основанные на каких-то смарт-стандартах — то, что сделает рынок более конструктивным, понятным и технологичным одновременно.В целом, централизация пока прослеживается всюду:В устаревших методах финансирования: «чистых» p2p-ICO не так и много, поскольку огромная часть — это приход тех или иных крипто-фондов, относительно (самого крипто-рынка) игроков, но не принцип «с миру по нитке»;В обсуждении перспективности идеи DPoS или PoS — хотя всё это человечество уже проходило и не раз: централизация через деньги или через коррупцию. Но, безусловно, это интересно тем, кто делает хайп-проекты, скажем, такие как EOS или Filecoin;В первую очередь (извините за непоследовательность) в том, что крипто-социум создаёт некую технологическую инфраструктуру, основанную на p2p-принципах, но при этом экономику и сами общественные процессы оставляет на откуп старым законам: так появляется оцифрованных банк Полибиус, который в общем-то противоречит самой природе виртуальных валют; или те же обменники с комиссиями в 10-20% и более процентов; переведённые на блокчейн форекс-проекты, казино и т.п. Всё это — атавизмы. Но пока понять это суждено немногим;Кроме того, лишь немногие проекты (о них я ещё отдельно расскажу) развивают такие понятия как: «распределённые юридические лица», «автоматизация бизнес процессов на основе смарт-контрактов» и т.д. Большинство же даже для ICO стараются сделать юридическое лицо в какой-нибудь «шоколадной» юрисдикции: Швейцарии или, скажем, тех же Штатах;Наконец, среди миллионов лишь малая горсть тех, кто в принципе хочет развивать p2p:большинство идёт за популярностью, лёгкими деньгами и безнаказанностью.Да, переходные формы всегда неизбежны после революции (которая, конечно же, случилась). Но будущее, на мой взгляд за принципиально иными подходами. Перечислю лишь наиболее очевидные:Смарт-контракты — хорошо и по-своему правильно, но, во-первых, это устарело ещё до того, как появилось, потому как основа будущего — это ещё большая абстракция (чтобы понять о чём веду речь, стоит посмотреть на эволюцию языков программирования: там явно прослеживается всё больший уход от детального к общему), например, моделирование или проектирование, которые предполагают описание бизнес- и иных процессов. А как же кодинг?Думаю, что он достанется роботам и ИИ, если эти понятия, конечно, мы сможем отделить. Чтобы жители Хабра понимали, что это не холивара ради сказано, сделаю зарисовку о том, что в Новосибирске и Иркутске работают две группы под единым управлением, которые занимаются как раз этим: и если я подошёл к процессу с точки зрения обобщения, то они — с сугубо утилитарной и одновременно — научной позиции. Надеюсь, как-нибудь расскажу об этом интереснейшем проекте. Во-вторых, появление смарт-стандартов: сегодня сообщество только-только подходит к этому. Но без стандартизации больших кусков разных алгоритмов построить по-настоящему цельные, защищённые и одновременно гибкие системе не получится.Децентрализованные биржи — будущее: сейчас, например, можно изучать nvo.io, kyber.network, а также любые dex-подобные. Кроме того, есть, в случае модернизации, будущее и у сервисов формата localbitcoins. Скажем, RuDex —  мала, но приемлема уже сегодня.Репутационные сервисы разных уровней — то, чего не хватает p2p-системам и то, что станет их будущим в ближайшие годы. В этом аспекте самое интересное, что глобальные системы репутации не просто не исключают, а, напротив, детерминируют появление локальных, поскольку репутация как некий набор количественных показателей — всё же, довольно ограниченный феномен, тогда как совокупность субъективных оценок, объективные критерии (в виде баллов и т.п.) вкупе с унифицированным алгоритмом оценки и рейтингов — это то, что даст толчок настоящим p2p-системам. Но для этого нужно, чтобы люди поняли, что репутация — единственно важные деньги в любой социальной среде.Системы, связывающие бизнес-сектор с разными блокчейнами — концептуально отличаются от нынешних систем, привязанных к одному из блокчейнов, т.к. риски харфорков и возможного отмирания систем (потому как бесконечное деление приведёт неизбежно к инфляции в активах, которые якобы ей не подвержены), возможного «волевого» решения изменения алгоритмов майнинга, как в случае с Эфириумом, морального устаревания и т.д., неизбежны при долгосрочном планировании. Кроме того, уже сегодня мы видим подобные анклавы, но пока лишь в сфере приёма средств, скажем, в тех же ICO.Из узконаправленных ниш мне больше всего импонирует создание систем с квантовым шифрованием, т.к. не оглядываясь на существование проблемы с 1980х годов, но учитывая экспоциональный рост в технологиях (хороший пример — сотовые телефоны), можно сказать, что в ближайшие 10-15 лет эта проблема может стать очень актуальной: кроме того, стоит учесть и само развитие и набор популярности систем блокчейн.Конечно, мне хотелось бы ещё рассмотреть связку «блокчейн + большие данные + ИИ», но пока оставим это на следующий этап.Для тех, кому мои рассуждения покажутся чересчур абстрактными, сообщаю, что выведены они на основе анализа более 200 Белых книг и концептов разных проектов из данной сферы, а также в результате изучения ряда действующих проектов, как то: биржи, обменники, замкнутые системы сервисов на блокчейн (типа kickico или COSS), медиаплатформ (Golos, Decent и т.д.) и других проектов, построенных благодаря этой же технологии. Безусловно, выделить все тенденции трудно, но обозначенные, на мой взгляд, имеют все шансы на то, чтобы стать приоритетными и породить тем самым целые сферы, которые на сегодня даже не существуют, как, скажем моделирование как новый этап развития кодинга, смарт-стандартизация как эволюционная стадия развития умных контрактов. Пока всё. Вопросы приветствуются. Дополнения — ещё больше. P.S. Опыт пока систематизируется в книгу. Хабру — эксклюзив. При выходе — выпуск с дополнениями."
olegbunin;Разработка на Blockchain — что изменится для разработчиков?;Блог компании Конференции Олега Бунина (Онтико);"Эта статья является переводом поста Винсента Чена (Vincent Chen) и Рамона Рекуэро (Ramon Recuero), цели которого очень схожи с теми, что преследуем и мы, и написанного для таких разработчиков, которых мы хотели бы видеть на своих мероприятиях.

Введение
Если вы читаете этот текст, то можно смело предположить, что вы — разработчик, который интересуется блокчейном. Вы уверены в том, что вы понимаете, как работает блокчейн, и вам не терпится узнать, какую пользу блокчейн может принести вам и вашим навыкам разработчика.

Целью нашего поста является:


Объяснить, как разработка под блокчейн отличается от других существующих парадигм разработки; 
Предоставить некоторый контекст для возможностей и вызовов, которые существую в этой сфере; 
Познакомить вас с полезными (зарубежными) ресурсами, которые помогут вам заняться разработкой в этой новой парадигме.";/ru/company/oleg-bunin/blog/349086/;"Эта статья является переводом поста Винсента Чена (Vincent Chen) и Рамона Рекуэро (Ramon Recuero), цели которого очень схожи с теми, что преследуем и мы, и написанного для таких разработчиков, которых мы хотели бы видеть на своих мероприятиях.ВведениеЕсли вы читаете этот текст, то можно смело предположить, что вы — разработчик, который интересуется блокчейном. Вы уверены в том, что вы понимаете, как работает блокчейн, и вам не терпится узнать, какую пользу блокчейн может принести вам и вашим навыкам разработчика.Целью нашего поста является:Объяснить, как разработка под блокчейн отличается от других существующих парадигм разработки; Предоставить некоторый контекст для возможностей и вызовов, которые существую в этой сфере; Познакомить вас с полезными (зарубежными) ресурсами, которые помогут вам заняться разработкой в этой новой парадигме. Если же вы только начинаете разбираться в этой теме, мы рекомендуем вам начать с чтения bitcoin white paper и white paper для Ethereum.Сдвиг парадигмы для разработчиковВеб-приложения выгодно использование сетевого эффекта благодаря тому, что они придерживаются централизованного хранения информации. Построенные на общих открытых протоколах (например, TCP/IP и HTTP), компании Yelp, Facebook и Amazon выигрывают от того, что всех их пользователи и, в результате, их данные находятся в одном месте. Таким образом, они не просто получают преимущество над конкурентами, у которых имеется меньше данных, но и держат полный контроль над тем, как монетизировать эти данные. Цитируя криптоинвестора Джоэла Монегро:«Нынешняя парадигма интернета извлекает максимум полезности из толстого слоя приложений, в то время как тонкий слой коммуникационных протоколов под ним имеет минимальную ценность».В качестве альтернативы, распределение ценности в парадигме блокчейна может быть выражено как толстые протоколы и тонкий слой приложений. Подобный сдвиг парадигмы возможен за счет нововведения — криптографических токенов, которые хорошо описал Альберт Венгер из венчурной компании Union Square Ventures:«Исторически сложилось, что единственным способом заработать на протоколе было создание программного обеспечения, которое его реализует, с последующей попыткой продавать данное ПО (а в последние годы — хостить его). Однако с помощью криптографических токенов создатели протокола могут «монетизировать» его напрямую и фактически получают еще больше выгоды по мере того, как другие создают бизнесы на основе их протокола».В прошлом, создатели открытых коммуникационных протоколов для Интернета — по большей части это были исследователи DARPA и контрибьюторы-добровольцы — не имели финансовых стимулов к разработке протоколов. Для сравнения, сегодня создатели протоколов могут выпускать токены, подобные Bitcoin или Ethereum, что отражает ценность этих децентрализованных протоколов.Монегро считает, что из-за этого сдвига парадигмы разработчики должны иначе относится к своим приложениям:«Комбинация общих открытых данных с системой мотивации, которая предотвращает рыночную ситуацию «победитель забирает себе все», меняет подход к слою приложений и создает совершенно новую категорию компаний с фундаментально иными бизнес-моделями для уровня протокола».EthereumМы пришли к пониманию того, что в парадигме блокчейна разработчики могут «захватывать» ценность при помощи создании инновационных протоколов. В продолжение нашего обсуждения, мы рассмотрим, каким образом технологии блокчейна эволюционировали до того уровня, когда ими заинтересовались разработчики.Восемь лет назад Bitcoin воспринимался как виртуальная валюта, которая устраняет необходимость существования централизованных финансовых систем. Первоначально разработчики действительно пытались строить приложения поверх блокчейна Bitcoin с сохранением данных в самом блокчейне, однако достаточно быстро выяснилось, что это весьма неэффективный подход (об этом тоже есть старый пост Джоэла). Один из таких разработчиков, Виталик Бутерин, был разочарован «малоподвижностью» Bitcoin и его принципом избегания риска в части новых, дружественных разработчикам функций. Поэтому он создал свою собственную платформу, Ethereum.В то время как Bitcoin изначально задумывался как новое средство для финансового хранения стоимости, Ethereum был изобретен для того, чтобы служить Тьюринг-полным окружением разработки. В Ethereum, разработчики пишут смарт-контракты на Solidity, и эти умные контракты выполняются на виртуальной машине Ethereum. В нем для разработчиков есть возможность сделать свой форк и реализовать собственные блокчейны для разных целей. Однако, чтобы достичь этого результата, требуется снова возродить масштабный интерес среди разработчиков, который удавалось достичь прошлым итерациям блокчейн-технологий. Сегодня создание приложений поверх существующих сетей вроде Ethereum позволяет разработчикам быть заинтересованными не только в их собственных приложениях, но и в используемых протоколах.Dapps, токены и смарт-контрактыНынешние блокчейн-разработчики обычно создают распределенные приложения (dapps, сокращение от distributed apps) поверх существующих протоколов для того, чтобы решить конкретные бизнес-задачи и удовлетворять конечных пользователей. Таким образом, разработчики могут выпускать токены, или койны (app coins), которые используются для выполнения конкретных «функций» распределенных приложений, в отличии от «универсальных» токенов, которые используются как монетки для игровых автоматов. Эти функции и есть смарт-контракты, которые предоставляют сервисы распределенного приложения в обмен на цифровой актив, тем самым убирая необходимость в посреднике для проверки транзакций. Другими словами, смарт-контракты обещают, что за один токен вы получите одну партию за игровым автоматом.По мере того, как функциональность распределенный приложений становится все более востребованной, стоимость фиксированного количества койнов приложений растет как функция спроса и предложения. Другими словами, если ваш игровой автомат оказывается по-настоящему запоминающимся и начинает пользоваться спросом, то ограниченное количество токенов начинает расти в цене. Это принцип, лежащий в основе ICO (initial coin offereing), в рамках которых разработчики занимаются сбором инвестиций предлагая койны в обмен на капитал для финансирования их проектов.Но постойте, здесь вы можете спросить: «Почему бы не использовать существующий токен вместо того, чтобы выпускать свой, специфический для приложения?». Дело в том, что специфические токены конкретных распределенных приложений позволяют создавать мелкие экономики, которые способствуют осуществлению основного замысла приложения. Эти токены выступают в роли ограниченных ресурсов, которые можно регулировать согласно функциональности приложения. Здесь и приходит на помощь Ethereum: при помощи Ethereum разработчики могут с легкостью выпускать свои собственные токены.Возможности на ранних этапахТеперь, когда у вас есть понимание механизма, лежащего в основе dapps, важно тщательно продумать, какую пользу децентрализация принесет вашим пользователям. Вместо того, чтобы бросаться к своим проектам и переделывать их с реляционных баз данных на блокчейн-альтернативу, мы призываем вас подумать о преимуществах децентрализации. К примеру, Augur создает рынок предсказаний, вовлекая децентрализованных участников для того, чтобы используя общий финансовый стимул повысить точность предсказаний.На мета-уровне также существуют возможности для инноваций в стеке разработки. Многие блокчейн-разработчики сравнивают современное состояние инструментов и фреймворков с тем, что происходило в вебе в годы становления Интернета. Когда мы разговаривали об этом с Беном Ю из Stream, он описал это как новую возможность для разработчиков:«Сейчас есть очевидная задача сделать блокчейн более доступным для широких масс, блокчейн нужно провести из 1994 года в 2018-ый, а для этого потребуется построить много технической инфраструктуры».Технологические инновации блокчейна многих натолкнули на идею построения нового, децентрализованного веб-стека, который будет независим от централизованных правительств и корпораций. Традиционный стек в вебе состоит из кирпичиков вроде TCP/IP, DNS, баз данных, веб-серверов, систем аутентификации и CDN, и мы в процессе воспроизведения этих компонентов при помощи базовых платформ вроде Ethereum.Проблемы неизменяемостиК сожалению, технология похожая на ранние итерации JavaScript, почти всегда содержит в себе проблемы, самые частые из которых связаны с устойчивостью протоколов к фальсфикации. Разработчики не могут изменить лежащий в основе блокчейн или высокоуровневые смарт-контракты. Отсутствует простой способ версионирования библиотеки или контрактов. Недавний баг в Parity, который заблокировал средства объемом в 150 000 000 $, наряду с другими подобными инцидентами, лишний раз напоминает нам о необходимости построения надежных архитектур.Брэндон Милман, разработчик в 0x, следующим образом описывает влияние неизменяемости блокчейна на безопасность:«Когда вы занимаетесь этим, то вы должны быть гораздо осторожнее, чем обычно, поскольку речь идет о средствах других людей. Преимуществом парадигмы блокчейна является то, что, если вы надежно храните свой приватный ключ, другим людям крайне тяжело забрать ваши деньги; однако, многие мошенники постараются вынудить вас отправить деньги не туда для того, чтобы украсть их из вашего кошелька».Разработчики — особенно те, кто привык к бешеному темпу мира стартапов — вынуждены задумываться о компромиссах между скоростью и защищенностью. Бен Ю по этому поводу сказал:«Вы должны двигаться вперед максимально быстро, поскольку сфера растет невероятными темпами. Но вы не можете быстро что-то делать ломая уже готовое, несмотря на то, что такова на сегодня общепринятая философия среди разработчиков. Если вы случайно сломаете что-нибудь, то вы потеряете миллионы долларов»Разработка приложений на основе блокчейна требует совсем другого уровня планирования. Разработчики не смогут выкатывать хотфиксы или патчи по ночам, потому что у них не будет централизованного контроля надо всей системой. Вместо этого, внесение изменений системы зачастую будет вовлекать хард форки протоколов целиком — или, в некоторых случаях, включение других источников для параметров протокола, которые не так сильно завязаны на блокчейн.Ограничения EthereumПомимо основных сложностей, связанных с неизменяемостью, Ethereum содержит в себе несколько ограничений, с которыми могут столкнуться блокчейн-разработчики. Одно из них состоит в том, что Ethereum не может получать доступ к данным в реальном времени за пределами блокчейна.Разработчики должны полагаться на сторонних провайдеров данных, называемых оракулами, для предачи информации из внешнего мира в умные контракты — например, погоды, случайных чисел или курсов валют.Более того, спецификация Ethereum препятствует вычислениям в реальном времени. Обработка блока транзакций занимает до 15 секунд (что прямо-таки молниеносно в сравнении с 10 минутами, которые требуются биткоину). В результате, разработчики вынуждены писать асинхронный код, взаимодействующий с фронтенд-фреймворками, которые умеют работать с такой моделью обновления состояний (например React).В случае с Ethereum, вы также связаны обязательством платить за свои транзакции, выполняя операции с «газом», который превращается в эфиры Ethereum. По этой причине при использовании текущей версии Solidity вы быстро упираетесь в лимит транзакций, если вычисления, которые вы пытаетесь выполнить, будут слишком дорогими (как, например, проверка на мат для игры в шахматы). В результате вычисления на блокчейне становятся весьма дорогостоящими в плане денег и нагрузки на сеть. Существуют интересные альтернативы (например, Truebit), позволяющие выполнять интенсивные вычисления вне сети.Начало работыПоначалу работа с блокчейном может показаться ошеломляющей. Это сфера, распространяющаяся сразу на несколько областей: экономику, теорию игр, computer science, финансы, математику, криптографию и другие. Такая ширина охвата является признаком того, что в данной сфере есть много различных возможностей внести в нее свой вклад.Брэндон Милман рекомендует начинать с того, что вам интересно или в чем у вас уже есть некоторый опыт: «Если до этого вы занимались разработкой на JavaScript, то существует большое количество JS-библиотек, развитию которых вы можете помочь. Конечно, рано или поздно вы должны будете разобраться с тем, как все это работает в целом, но вам не нужно пытаться понять все и сразу».Конечно же, когда речь идет о децентрализации, большая часть проектов по теме блокчейна доступна в виде открытого исходного кода. Если вам не терпится начать свое знакомство с блокчейном, вам помогут следующие ресурсы:Официальная документация Solidity — отличное место для старта;Truffle Framework — один из лучших фреймворков для Solidity;Посмотреть на разработку токенов и их продажу можно в репозитори zeppelinOS;Ресурс Blockgeeks предлагает подробное руководство по токенам Ethereum с примерами кода;Учиться можно даже у Crypto Kitties — создайте свою собственную цифровую игру на блокчейне.Нельзя не упомянуть и сообщества для разработчиков:/r/ethereum/r/ethdevhttps://blockgeeks.com/Если вы предпочитаете учиться на практике, вот вам несколько идей для проектов:Создайте свой собственный кошелек. Это может быть веб, мобильное или десктоп-приложение.Создайте свой собственный ERC-20 токен и разверните его в тестовой сети.Замените криптокотиков на криптособачек, крпитотанки или криптозомби и разверните в тестовой сети.Вперед в будущееВ своем нынешнем состоянии разработка под блокчейн достаточно беспорядочна. Здесь нет понятных фреймворков и инструментов, аналогичным тем, что применяются в современной веб-разработке. Но почему бы не отнестись к этому как к возможности повлиять на парадигму, которая становится вехой в развитии технологий?В случае с блокчейном вам не придется разворачивать централизованные сервера, что означает отсутствие единой точки отказа. Если весь ваш стек децентрализован, то нет никакого постороннего влияния — ваша система становится устойчивой к цензуре, а ваша база данных поддается публичной проверке. Поскольку новая парадигма дает возможность публично обмениваться данными, мы понимаем высшее преимущество децентрализованных баз данных. Вот будущее, к которому мы стремимся построить на блокчейне, в нем информация и власть распространяются систематически и без посредника.От себя хотим обратить внимание и на русскоязычное сообщество блокчейн-разработчиков:на Facebookt.me/eth_rukt.me/distributedНу и конечно, пригласить на нашу специализированную конференцию DeCenter TokenConf про блокчейн-технологию. Это единственная конференция в России, целиком и полностью рассчитанная на аудиторию разработчиков блокчейна. За рамки программы принципиально вынесены все вопросы, касающиеся ICO, майнинга, криптовалют и спекуляций. Только чистая технология."
dzakhour;Приглашаем на Waves Blockchain Hackathon;Блог компании Binary District Децентрализованные сети Python *Scala *Хакатоны;Waves Platform — одна из крупнейших в мире блокчейн-платформ, она входит в первую двадцатку блокчейн-компаний мира. В декабре Waves проводит хакатон для разработчиков: приглашаем познакомиться с экосистемой продуктов, командой проекта и присоединиться к блокчейн-сообществу.;/ru/company/binarydistrict/blog/432050/;"Waves Platform — одна из крупнейших в мире блокчейн-платформ, она входит в первую двадцатку блокчейн-компаний мира. В декабре Waves проводит хакатон для разработчиков: приглашаем познакомиться с экосистемой продуктов, командой проекта и присоединиться к блокчейн-сообществу.Три дня с 14 по 16 декабря на площадке Digital October в Москве будет проходить хакатон по блокчейну. Участники смогут:решать задачи и предлагать свои блокчейн-решения,посетить воркшопы и поработать со смарт-контрактами Waves и Waves DEX,познакомиться с командой Waves, пообщаться с жюри и модераторами хакатона,получить призы и расслабиться на финальной вечеринке. В хакатоне можно принять участие как с командой, так и индивидуально. Для участия необходимо знание Scala (желательно знание Akka, Netty, MVStore, Cats, Monix), JS (React, Angular) или Python и пройти вступительное задание. Победители каждого из четырех треков хакатона получат призы. Во время хакатона пройдет несколько воркшопов от Waves:основы блокчейн;смарт-технологии: контракты, аккаунты, активы; Gaming Workshop. Разработка видеоигр с применением смарт-контрактов.Жюри хакатонаОснователь и генеральный директор Waves Platform и проекта Vostok Александр Иванов.Developer Advocate Waves Инал Карданов.Руководитель отдела по разработке смарт-контрактов Waves Илья Смагин.Блокчейн-инженер, руководитель направления Gaming Waves Юрий Найденов.Как проходил хакатон Binary District: ? Регистрация на Waves Hackathon доступна по ссылке"
OpenGIft;Совместный онлайн-хакатон от OpenGift и Credits Blockchain Platform;Я пиарюсь;До 8-го декабря открыта регистрация на первый онлайн-хакатон от Credits и OpenGift. Целью хакатона является создание решений и приложений на базе экосистемы блокчейн-платформы Credits. Призовой фонд хакатона — $10 000.;/ru/post/432094/;До 8-го декабря открыта регистрация на первый онлайн-хакатон от Credits и OpenGift. Целью хакатона является создание решений и приложений на базе экосистемы блокчейн-платформы Credits. Призовой фонд хакатона — $10 000. Расписание хакатонаПервый этап продлится до 9-го декабря и у вас ещё есть время зарегистрироваться на хакатон и принять в нем участие. В рамках данного этапа необходимо прислать описание будущего решения. Все участники, чей концепт будет одобрен пройдут в следующий этап — разработку MVP. Дедлайн второго этапа — 00:00 UTC, 30-го декабря. Участникам необходимо опубликовать исходный код решения и прислать ссылку на него, а также ссылку на веб-сайт или приложение. В рамках данного этапа будет отобрано 10 финалистов, которые и пройдут в следующий этап.Дедлайн заключительного этапа — 00:00 UTC, 6-го января, 2019. В рамках данного необходимо прислать 5-минутную презентацию решения на английском языке. Распредление призового фонда1 место — $50002 место — $30003 место — $2000Наличие опыта разработки на Java — является обязательным условием для участников (если вы участвуете командой, то желательно, что он был хотя бы у одного из участников), т.к. смарт-контракты для платформы пишутся на данном языке. Решения или приложения для работы с экосистемой могут быть написаны с использованием любых популярных языков (ActionScript, C, C++, C#, Cappuccino, Cocoa, Delphi, Erlang, Go, Haskell, Java, Node.js, Objective-C, OCaml, Perl, PHP, Python, Ruby). Credits.com также провели серию вебинаров для участников, с ними можно ознакомиться на их youtube-канале.Более подробно с деталями хакатона можно ознакомиться на его странице.Спасибо за внимание и ждем вас.
MaxRokatansky;Разбираемся в основах Blockchain: Задача Византийских Генералов. Часть 1;Блог компании OTUS Алгоритмы *Криптовалюты;"Перевод статьи подготовлен специально для студентов курса «Архитектор высоких нагрузок», который стартует уже в этом месяце.



Блокчейн – это децентрализованная система, состоящая из различных субъектов, которые действуют в зависимости от своих стимулов и имеющейся у них информации.

Всякий раз, когда новая транзакция транслируется по сети, узлы могут включить эту транзакцию в копию своего леджера или проигнорировать ее. Когда большинство участников сети принимают решение о принятии определенного состояния, достигается консенсус.";/ru/company/otus/blog/467053/;"Перевод статьи подготовлен специально для студентов курса «Архитектор высоких нагрузок», который стартует уже в этом месяце.Блокчейн – это децентрализованная система, состоящая из различных субъектов, которые действуют в зависимости от своих стимулов и имеющейся у них информации.Всякий раз, когда новая транзакция транслируется по сети, узлы могут включить эту транзакцию в копию своего леджера или проигнорировать ее. Когда большинство участников сети принимают решение о принятии определенного состояния, достигается консенсус.Фундаментальной проблемой в распределенных вычислениях и многоагентных системах является достижение общей надежности системы при наличии ряда нерабочих процессов. Зачастую для этого требуется, чтобы процессы согласовали между собой некоторое значение, которое понадобится во время вычисления.Эти процессы описываются как консенсус.Что происходит, когда участник решает не следовать правилам и вмешаться в состояние своего леджера?Что происходит, когда таких участников в сети достаточно много, но не большинство?Чтобы консенсусный протокол был безопасным, он должен быть отказоустойчивым. Для начала мы кратко поговорим о неразрешимой задаче двух генералов. Затем рассмотрим Задачу Византийских Генералов и обсудим Византийскую отказоустойчивость в распределенных и децентрализованных системах. А в самом конце поговорим о том, как это все относится к технологии блокчейн.Задача двух генераловЭта задача, впервые опубликованная в 1975 году и получившая свое название в 1978 году, описывает сценарий, когда два генерала атакуют общего врага. Первый генерал считается лидером, а второй – последователем. Армии каждого генерала по отдельности недостаточно, чтобы победить вражескую армию, поэтому им нужно сотрудничать и атаковать одновременно. Этот сценарий выглядит просто, но есть один нюанс:Для того, чтобы они могли общаться и договариваться о времени, первый генерал должен отправить гонца через лагерь противника, он должен доставить послание с временем начала атаки второму генералу. Однако существует вероятность того, что гонец будет захвачен противниками, а послание – не доставлено. Это приведет к тому, что армия первого генерала пойдет в атаку, а второго останется стоять на месте.Даже если первое послание будет доставлено, второй генерал должен подтвердить (ACK (acknowledge), обратите внимание на сходство с трехсторонним рукопожатием в TCP), что он получил сообщение, поэтому он отправляет гонца обратно, тем самым воспроизводя предыдущий сценарий, где посланник может быть захвачен. Это перетекает в бесконечные ACK, и из-за этого генералы не могут достичь согласия. Нет никакого способа гарантировать второе условие, то есть чтобы каждый генерал был в полной уверенности, что другой согласился с планом нападения. Оба генерала всегда будут в неведении, дошел ли гонец до его товарища.Было доказано, что задача двух генералов неразрешима. Задача Византийских ГенераловОписанная в 1982 году Лэмпортом, Шостаком и Пизом, версия этой задачи оказалось с изюминкой. Она описывает тот же сценарий, где вместо двух генералов о времени атаки должны договориться большее количество генералов. Дополнительная сложность заключается в том, что один или несколько генералов могут быть предателями, то есть они могут солгать о своих намерениях (например, генерал говорит, что он согласен атаковать в 09:00, но не сделает этого).Парадигма лидера-последователя, описанная в задаче двух генералов, трансформируется в установку командир-подчиненный. Для достижения консенсуса здесь командир и каждый подчиненный должны договориться об одном и том же решении (об атаке или отступлении).Перевод картинки:Задача Византийских Генералов. Командующий генерал должен отправить приказ своим n-1 подчиненным, такой что:Все верноподданные подчиненные генералы подчиняются одному приказу.Если командующий генерал верноподданный, тогда все верные ему подчиненные подчиняются его приказам. В добавок ко второму пункту нужно указать на интересный факт: если командир – предатель, то консенсус все равно должен быть достигнут. В результате все лейтенанты имеют большинство голосов. Алгоритм достижения консенсуса в этом случае основан на значении большинства решений, которые видят подчиненные.Теорема: Для любого m, алгоритм OM(m) достигает консенсуса при более чем 3m генералов и максимум m предателях.Это означает, что алгоритм может достичь консенсуса пока 2/3 участников честны. Если предателей больше 1/3, консенсус не достигается, армии не могут скоординировать свои атаки, и враг побеждает. Алгоритм ОМ(0)Командир отправляет свое значение каждому из подчиненных. Каждый подчиненный использует значение, которое он получает от командира, или использует значение ОТСТУПИТЬ, если не получает никакого значения.Алгоритм ОМ(m), m>0Командир отправляет с свое значение каждому из подчиненных.Для каждого i, пусть vi будет значением, которое i-й подчиненный получает от командира, либо же будет использовано значение ОТСТУПИТЬ, если подчиненный не получает никакого значения. i-й подчиненный выступает в качестве командира в Алгоритме ОМ(m-1) и отправляет значение каждому из n-2 оставшихся подчиненных.Для каждого i, при условии, что j?i, пусть vj будет значением, которое i-й подчиненный получил от j-ого подчиненного на шаге (2) (используя Алгоритм ОМ(m-1)), или использует значение ОТСТУПИТЬ, если не получает никакого значения. i-й подчиненный использует значение большинства (v1, …, vn-1).При m=0 предателей нет, каждый подчиненный следует приказу. При m>0 каждый итоговый выбор подчиненного исходит из преобладающей части выборов всех подчиненных. Будет понятнее, если вы посмотрите на ситуацию с точки зрения второго подчиненного – пускай С – Командир, а L{i} – это i-й подчиненный.OM(1): Подчиненный 3 – предатель. Ситуация с точки зрения второго подчиненного.Шаги: Командир отправляет v всем подчиненным. L1 посылает L2 значение v или L3 отправляет L2 значение x.L2 ? большинство(v,v,x) == vОкончательное решение принимается из большинства голосов от L1, L2 и L3 и в результате достигается консенсус.Важно помнить, что цель состоит в том, чтобы большинство подчиненных выбрало одно и то же решение, а не какое-то конкретное.Давайте посмотрим на случай, когда командир – предатель.OM(1): Командир – предатель.Шаги: Командир посылает L1, L2, L3 значения x, y, z соответственно;L1 посылает значение x подчиненным L2, L3 | L2 посылает L1, L3 значение y | L3 посылает L1, L2 значение z;L1 ? большинство(x, y, z) | L2 ? большинство(x, y, z) | L3 ? большинство(x, y, z)Они все имеют одинаковую ценность, таким образом достигается консенсус. Обратите внимание, что даже если значения x, y, z – все разные, значение большинство(x, y, z) одинаково для всех трех подчиненных. В случае, если x, y, z – совершенно разные приказы, мы можем предположить, что они будут действовать по дефолтному плану – ОТСТУПИТЬ.Чтобы посмотреть на практический подход к более сложному примеру с 7 генералами и 3 предателями я предлагаю вам прочитать эту статью.Византийская отказоустойчивость Византийская отказоустойчивость является характеристикой, которая определяет систему, которая допускает класс отказов, который принадлежит Задаче Византийских Генералов. Византийский отказ – самый сложный класс видов отказов. Он не подразумевает никаких ограничений и не делает предположений о том, какое поведение может иметь узел (например, узел может генерировать любые произвольные данные, выдавая себя за честного участника). Византийские ошибки устранять сложнее всего. Византийская отказоустойчивость была необходима в системах двигателей самолетов, на атомных электростанциях и практически в любой системе, действия которой зависят от результатов работы большого количества датчиков. Даже SpaceX рассматривает ее как потенциальное требование к своим системам.Алгоритм, упомянутый в предыдущем разделе, отвечает византийской отказоустойчивости до тех пор, пока число предателей не превысит одной трети всех генералов. Существуют и другие варианты, облегчающие решение этой задачи, включая использование цифровых подписей или введения ограничений на связь между одноранговыми узлами.Как это все относится к блокчейну?Блокчейн – это децентрализованные леджеры, которые по определению не контролируются центральным органом. Из-за значений, хранящихся в них, злоумышленники имеют хороший экономический стимул, чтобы попытаться инициировать ошибку. Тем не менее, Византийская отказоустойчивость и, следовательно, решение проблемы византийских генералов для блокчейна просто необходимы. В отсутствие Византийской Отказоустойчивости одноранговый узел может передавать и публиковать ложные транзакции, полностью сводя на нет надежность блокчейна. Что еще хуже, нет никакого центрального органа, который может взять на себя ответственность и исправить ущерб.Когда был изобретен биткоин, большим прорывом стало использование доказательства работы вероятностного решения задачи Византийских Генералов. Оно было подробно описано Сатоши Накамото в этом электронном письме.Заключение В этой статье мы рассмотрели некоторые основные понятия консенсуса в распределенных системах."
JagaJaga;Превращая FunC в FunCtional с помощью Haskell: как Serokell победили в Telegram Blockchain Competition;Программирование *Алгоритмы *Haskell *Функциональное программирование *Распределённые системы *;"Вы наверняка слышали о том, что Telegram собирается запустить блокчейн-платформу Ton. Но вы могли пропустить новость, что не так давно Telegram объявил конкурс на реализацию одного или нескольких смарт-контрактов для этой платформы. 
Команда Serokell с богатым опытом разработки крупных блокчейн проектов не могла остаться в стороне. Мы делегировали на конкурс пятерых сотрудников, а уже через две недели они заняли в нем первое место под (не)скромным рандомным ником Sexy Chameleon. В этой статье я расскажу о том, как им это удалось. Надеемся, за ближайшие десять минут вы как минимум прочитаете интересную историю, а как максимум найдете в ней что-то полезное, что сможете применить в своей работе. 
Но давайте начнем с небольшого погружения в контекст.";/ru/post/476756/;"Вы наверняка слышали о том, что Telegram собирается запустить блокчейн-платформу Ton. Но вы могли пропустить новость, что не так давно Telegram объявил конкурс на реализацию одного или нескольких смарт-контрактов для этой платформы. Команда Serokell с богатым опытом разработки крупных блокчейн проектов не могла остаться в стороне. Мы делегировали на конкурс пятерых сотрудников, а уже через две недели они заняли в нем первое место под (не)скромным рандомным ником Sexy Chameleon. В этой статье я расскажу о том, как им это удалось. Надеемся, за ближайшие десять минут вы как минимум прочитаете интересную историю, а как максимум найдете в ней что-то полезное, что сможете применить в своей работе. Но давайте начнем с небольшого погружения в контекст.Конкурс и его условияИтак, основными задачами участников стали реализация одного или более из предложенных смарт-контрактов, а также внесение предложений по улучшению экосистемы TON. Конкурс проходил с 24 сентября по 15 октября, а результаты объявили лишь 15 ноября. Довольно долго, учитывая, что за это время Telegram успел провести и огласить результаты контестов по дизайну и по разработке приложений на C++ для тестирования и оценки качества VoIP-звонков в Telegram.Мы выбрали из списка, предложенного организаторами, два смарт-контракта. Для одного из них мы использовали инструменты, распространяющиеся вместе с TON, а второй реализовали на новом языке, разработанном нашими инженерами специально для TON и встроенном в Haskell. Выбор функционального языка программирования не случаен. В нашем корпоративном блоге  мы часто рассказываем, почему считаем сложность функциональных языков большим преувеличением и почему мы в целом предпочитаем их объектно-ориентированным. Кстати, в нем есть и оригинал этой статьи.Почему мы вообще решили участвоватьЕсли вкратце, потому что наша специализация — это нестандартные и сложные проекты, требующие особых навыков и зачастую представляющие научную ценность для IT-сообщества. Мы горячо поддерживаем open-source разработку и занимаемся ее популяризацией, а также сотрудничаем с ведущими университетами России в области компьютерных наук и математики. Интересные задачи конкурса и причастность к горячо любимому нами проекту Телеграм сами по себе были отличной мотивацией, ну а призовой фонд стал дополнительным стимулом. :)Исследование блокчейна TONМы пристально следим за новыми разработками в блокчейне, искусственном интеллекте и машинном обучении и стараемся не пропускать ни одного значительного релиза в каждой из сфер, в которых работаем. Поэтому к моменту старта конкурса наша команда уже была знакома с идеями из TON white paper. Однако до начала работы с TON мы не анализировали техническую документацию и фактический исходный код платформы, поэтому первый шаг был достаточно очевиден — тщательное исследование официальной документации на сайте и в репозитории проекта.К началу конкурса код уже был опубликован, поэтому, чтобы сэкономить время, мы решили поискать руководство или выжимку, написанную пользователями. К сожалению, результата это не дало — кроме инструкции по сборке платформы на Ubuntu, других материалов мы не нашли. Сама документация оказалась тщательно проработанной, но читать ее в некоторых моментах было сложно. Довольно часто нам приходилось возвращаться к тем или иным пунктам и переключаться с высокоуровневых описаний абстрактных идей на низкоуровневые детали реализации.Было бы проще, если бы в спецификации вообще не было подробного описания реализации. Информация о том, как виртуальная машина представляет свой стек, скорее отвлекает разработчиков, создающих смарт-контракты для платформы TON, чем помогает им.Nix: собираем проектВ Serokell мы большие поклонники Nix. Мы собираем им наши проекты и разворачиваем их с помощью NixOps, а на всех наших серверах установлена NixOS. Благодаря этому все наши билды воспроизводимы и работают под любой операционной системой, на которую можно установить Nix. Поэтому мы начали с создания Nix overlay с выражением для сборки TON. С его помощью скомпилировать TON максимально просто:$ cd ~/.config/nixpkgs/overlays && git clone https://github.com/serokell/ton.nix$ cd /path/to/ton/repo && nix-shell[nix-shell]$ cmakeConfigurePhase && makeЗаметьте, вам не нужно устанавливать никакие зависимости. Nix магическим образом сделает все за вас вне зависимости от того, пользуетесь ли вы NixOS, Ubuntu или macOS.Программирование для TONКод смарт-контрактов в TON Network выполняется на TON Virtual Machine (TVM). TVM сложнее, чем большинство других виртуальных машин, и обладает весьма интересным функционалом, например она умеет работать с продолжениями (continuations) и ссылками на данные.Более того, ребята из TON создали целых три новых языка программирования:Fift — универсальный стековый язык программирования, напоминающий Forth. Его супер-способность — возможность взаимодействовать с TVM.FunC — язык программирования смарт контрактов, который похож на C и компилируется в еще один язык — Fift Assembler.Fift Assembler — библиотека Fift для генерации двоичного исполняемого кода для TVM. У Fift Assembler отсутствует компилятор. Это встраиваемый предметно-ориентированный язык (eDSL).Наши конкурсные работыНаконец, пришло время посмотреть на результаты наших усилий.Асинхронный платежный каналПлатежный канал (payment channel) — смарт-контракт, который позволяет двум пользователям отправлять платежи за пределами блокчейна. В результате экономятся не только деньги (отсутствует комиссия), но и время (вам не надо ждать, пока обработается очередной блок). Платежи могут быть сколь угодно маленькими и происходить настолько часто, насколько это требуется. При этом сторонам не обязательно доверять друг другу, так как справедливость окончательного расчета гарантирована смарт-контрактом.Мы нашли довольно простое решение проблемы. Две стороны могут обмениваться подписанными сообщениями, каждое из которых содержит два числа — полную сумму, уплаченную каждым из участников. Эти два числа работают как векторные часы в традиционных распределенных системах и задают порядок «произошло до» на транзакциях. Используя эти данные, контракт сможет разрешить любой возможный конфликт. На самом деле для реализации этой идеи достаточно и одного числа, но мы оставили оба, поскольку так мы смогли сделать более удобный пользовательский интерфейс. Помимо этого, мы решили включить в каждое сообщение размер платежа. Без него, если сообщение по каким-то причинам потеряется, то, хотя все суммы и окончательный рассчет будут корректными, пользователь потерю может не заметить.Чтобы проверить нашу идею, мы поискали примеры использования такого простого и лаконичного протокола платежного канала. К удивлению, мы обнаружили всего два:Описание похожего подхода, только для случая однонаправленного канала.Туториал, в котором описана та же идея, что и у нас, только без объяснения многих важных деталей, таких как общая корректность и процедура разрешения конфликтов.Стало ясно, что есть смысл подробно описать наш протокол, уделив особое внимание его корректности. После нескольких итераций спецификация была готова, и теперь вы тоже можете на неё посмотреть. Мы реализовали контракт на FunC, а утилиту командной строки для взаимодействия с нашим контрактом мы полностью написали на Fift, как рекомендовали организаторы. Мы могли бы выбрать любой другой язык для нашего CLI, но нам было интересно попробовать именно Fift, чтобы посмотреть, как он покажет себя в деле.Честно говоря, поработав с Fift, мы не увидели веских причин предпочитать этот язык популярным и активно используемым языкам с развитым инструментарием и библиотеками. Программировать на стековом языке довольно неприятно, поскольку приходится постоянно держать в голове что где лежит в стеке, и компилятор с этим никак не помогает.Поэтому единственным, на наш взгляд, оправданием существования Fift является его роль в качестве хост-языка для Fift Assembler. Но не лучше ли было бы встроить ассемблер TVM в какой-то существующий язык, а не придумывать новый для этой, по сути единственной, цели?TVM Haskell eDSLТеперь пришло время рассказать о втором нашем смарт-контракте. Мы решили разработать кошелек с мультиподписью, но писать еще один смарт-контракт на FunC было бы слишком скучно. Нам хотелось добавить какую-нибудь изюминку, и ею стал наш собственный язык ассемблера для TVM. Как и Fift Assembler, наш новый язык встраиваемый, только в качестве хоста вместо Fift мы выбрали Haskell, что позволило нам в полной мере использовать его продвинутую систему типов. При работе со смарт-контрактами, где цена даже небольшой ошибки может быть очень высокой, статическая типизация, на наш взгляд, является большим преимуществом. Чтобы продемонстрировать, как выглядит ассемблер TVM, встроенный в Haskell, мы реализовали на нем стандартный кошелек. Вот несколько вещей, на который стоит обратить внимание:Этот контракт состоит из одной функции, но вы можете использовать сколько угодно. Когда вы определяете новую функцию на языке хоста (то есть на Haskell), наш eDSL позволяет вам выбрать, хотите ли вы, чтобы она превратилась в отдельную подпрограмму в TVM или просто встроена в место вызова.Как и в Haskell, у функций есть типы, которые проверяются во время компиляции. В нашем eDSL тип входа функции это тип стека, который функция ожидает, а тип результата это тип стека, который получится после вызова.В коде есть аннотации stacktype, описывающие ожидаемый тип стека в точке вызова. В оригинальном контракте кошелька это были просто комментарии, но в нашем eDSL они фактически являются частью кода и проверяются во время компиляции. Они могут служить документацией или утверждениями, которые помогают разработчику найти проблему в случае, если при изменении кода тип стека изменится. Само собой, такие аннотации не влияют на производительность во время выполнения, поскольку никакой TVM код для них не генерируется.Это все еще прототип, написанный за две недели, поэтому над проектом предстоит еще много работы. Например, все экземпляры классов, которые вы видите в приведенном ниже коде, должны генерироваться автоматически.Вот как выглядит реализация multisig-кошелька на нашем eDSL:main :: IO ()main = putText $ pretty $ declProgram procedures methods  where    procedures =      [ (""recv_external"", decl recvExternal)      , (""recv_internal"", decl recvInternal)      ]    methods =      [ (""seqno"", declMethod getSeqno)      ]data Storage = Storage  { sCnt :: Word32  , sPubKey :: PublicKey  }instance DecodeSlice Storage where  type DecodeSliceFields Storage = [PublicKey, Word32]  decodeFromSliceImpl = do    decodeFromSliceImpl @Word32    decodeFromSliceImpl @PublicKeyinstance EncodeBuilder Storage where  encodeToBuilder = do    encodeToBuilder @Word32    encodeToBuilder @PublicKeydata WalletError  = SeqNoMismatch  | SignatureMismatch  deriving (Eq, Ord, Show, Generic)instance Exception WalletErrorinstance Enum WalletError where  toEnum 33 = SeqNoMismatch  toEnum 34 = SignatureMismatch  toEnum _ = error ""Uknown MultiSigError id""  fromEnum SeqNoMismatch = 33  fromEnum SignatureMismatch = 34recvInternal :: '[Slice] :-> '[]recvInternal = droprecvExternal :: '[Slice] :-> '[]recvExternal = do  decodeFromSlice @Signature  dup  preloadFromSlice @Word32  stacktype @[Word32, Slice, Signature]  -- cnt cs sign  pushRoot  decodeFromCell @Storage  stacktype @[PublicKey, Word32, Word32, Slice, Signature]  -- pk cnt' cnt cs sign  xcpu @1 @2  stacktype @[Word32, Word32, PublicKey, Word32, Slice, Signature]  -- cnt cnt' pk cnt cs sign  equalInt >> throwIfNot SeqNoMismatch  push @2  sliceHash  stacktype @[Hash Slice, PublicKey, Word32, Slice, Signature]  -- hash pk cnt cs sign  xc2pu @0 @4 @4  stacktype @[PublicKey, Signature, Hash Slice, Word32, Slice, PublicKey]  -- pubk sign hash cnt cs pubk  chkSignU  stacktype @[Bool, Word32, Slice, PublicKey]  -- ? cnt cs pubk  throwIfNot SignatureMismatch  accept  swap  decodeFromSlice @Word32  nip  dup  srefs @Word8  pushInt 0  if IsEq  then ignore  else do    decodeFromSlice @Word8    decodeFromSlice @(Cell MessageObject)    stacktype @[Slice, Cell MessageObject, Word8, Word32, PublicKey]    xchg @2    sendRawMsg    stacktype @[Slice, Word32, PublicKey]  endS  inc  encodeToCell @Storage  popRootgetSeqno :: '[] :-> '[Word32]getSeqno = do  pushRoot  cToS  preloadFromSlice @Word32Полный исходный код нашего eDSL и контракт кошелька с мультиподписью вы можете найти в этом репозитории. А более подробно рассказал про встроенные языки наш коллега Георгий Агапов.Выводы о конкурсе и TONВ сумме наша работа заняла 380 часов (вместе со знакомством с документацией, совещаниями и непосредственно разработкой). В конкурсном проекте приняли участие пять разработчиков: СТО, тим-лид, специалисты по блокчейн-платформам и разработчики программного обеспечения на Haskell.Ресурсы для участия в контесте мы нашли без труда, так как дух хакатона, тесная командная работа, необходимость быстрого погружения в аспекты новых технологий — это всегда увлекательно. Несколько бессонных ночей ради достижения максимального результата в условиях ограниченных ресурсов компенсируются бесценным опытом и отличными воспоминаниями. К тому же работа над подобными задачами — всегда хорошая проверка процессов компании, так как добиться действительно достойных результатов без отлично отлаженного внутреннего взаимодействия крайне тяжело.Кроме лирики: мы были впечатлены объемом работы, проделанным командой TON. Им удалось построить сложную, красивую, и самое главное, работающую систему. TON показал себя как платформа, имеющая большой потенциал. Однако для того, чтобы эта экосистема развивалась, нужно сделать еще очень много, как с точки зрения ее использования в блокчейн проектах, так и с точки зрения совершенствования инструментов разработки. Мы гордимся тем, что теперь являемся частью этого процесса. Если после прочтения этой статьи у вас остались какие-то вопросы или появились идеи о том, как применить TON для решения ваших задач, напишите нам — мы с радостью поделимся опытом."
mikhailkononov-domrf;Технология BLOCKCHAIN в ипотеке (часть 1);Блог компании ДОМ.РФ Децентрализованные сети Финансы в IT;Финансовый сектор уже давно взял курс на цифровизацию, в том числе и в традиционно консервативных областях – ипотечном кредитовании и регистрации сделок с недвижимостью. Полный переход на электронные закладные (e-закладные) является одной из важнейших задач, ведь создание цифрового аналога бумажной закладной и обеспечение «бесшовного» цифрового процесса работы с электронными закладными позволит залогодержателям существенно снизить издержки (временные, материальные). Это будет способствовать созданию более выгодных условий для заемщиков (снижение ипотечной ставки). Мы расскажем, как команда ДОМ.РФ всего за 4 месяца создала и испытала решение по выпуску e-закладных с использованием блокчейн-технологии – Мастерчейн.;/ru/company/domrf/blog/572350/;"Финансовый сектор уже давно взял курс на цифровизацию, в том числе и в традиционно консервативных областях – ипотечном кредитовании и регистрации сделок с недвижимостью. Полный переход на электронные закладные (e-закладные) является одной из важнейших задач, ведь создание цифрового аналога бумажной закладной и обеспечение «бесшовного» цифрового процесса работы с электронными закладными позволит залогодержателям существенно снизить издержки (временные, материальные). Это будет способствовать созданию более выгодных условий для заемщиков (снижение ипотечной ставки). Мы расскажем, как команда ДОМ.РФ всего за 4 месяца создала и испытала решение по выпуску e-закладных с использованием блокчейн-технологии – Мастерчейн.Процесс взаимодействия Росреестра и депозитария для эмиссии электронных закладных. Текущее решениеПри предоставлении ипотечного кредита банк формирует и регистрирует закладную. Выпуск закладной позволяет банкам быстро продавать ипотечные кредиты за счет реализации самой закладной, как ценной бумаги. Ее новый владелец фиксируется в самой закладной. В 2018 году были внесены изменения в 102-ФЗ, которые официально закрепили и описали процесс выдачи электронной закладной, что позволило перевести этот документ в машиночитаемой вид для ускорения процесса обработки данных информационными системами банков и депозитариев. Но необходимость в регистрации закладной в Росреестре с последующей передачей в депозитарий осталась. Для осуществления цифрового взаимодействия Росреестра и депозитария было выбрано централизованное решение - система межведомственного электронного взаимодействия (СМЭВ), которая связывает между собой различные ведомства, банки и других участников.Для запуска процесса выпуска электронных закладных на стороне Росреестра появился, специально разработанный под эти нужны софт – АРМ Электронная закладная, который автоматизирует работу регистратора в части проверки и выпуска электронной закладной. После чего через СМЭВ электронная закладная в виде XML передаётся в депозитарий для постановки на учёт и хранения. Основные сложности у депозитариев вызывал именно процесс подключения к СМЭВ для получения закладных и интеграции СМЭВ со своими учётными системами.Для упрощения этого процесса и  быстрого подключения к Росреестру Ассоциацией финансовых технологий (АФТ) было создано решение на базе блокчейн-технологии - ДДС (децентрализованная депозитарная система), предназначенная для депозитарного учета электронных закладных. По своей сути ДДС создает альтернативный СМЭВ канал обращения и учета е-закладных, используя все преимущества технологии блокчейн – отсутствие централизованного хранения записи, доступность всех движений электронного документа всем участникам без дополнительных синхронизаций. Децентрализация учета с применением средств криптозащиты делает процесс более безопасным, повышая доверие участников к передаваемым объектам учета, а также позволяет относительно легко масштабировать решение, объединяя все большее количество участников – банков, депозитариев.    Решение на блокчейнеОсенью прошлого года Центральным банком было сформировано предложение по оптимизации процесса взаимодействия Росреестра с депозитариями для выпуска электронных закладных за счет использования блокчейна. Команда ДОМ.РФ совместно с Центральным банком, Росреестром и АФТ разработала решение на базе блокчейн-платформы «Мастерчейн», которое позволило ускорить процесс и повысить качество передачи данных между Росреестром и депозитариями для выпуска электронных закладных. После чего наша команда совместно с Росреестром и АФТ приступила к реализации пилота, в рамках которого был реализован процесс выпуска е-закладных через «Мастерчейн» на пилотной группе участников.Основным входным требованием данного пилота было отсутствие влияния на работу АРМ ЭЗ (Автоматизированное рабочее место Электронная закладная) через канал СМЭВ. Кроме того, мы понимали, что электронная закладная – это комплексный документ с сотнями атрибутов, поэтому нужен был удобный инструмент для тех, у кого нет возможности автоматизировать создание этого документа в своих системах. Мы предложили создать API, доступный в будущем для всех партнеров. Также нам предстояло научиться регулировать потоки, которые направляются по разным каналам для каждого депозитария. Итого, функциональная архитектура проекта затронула три компонента (три разные системы с разными владельцами!), на которых нам необходимо было обеспечить синхронный вывод релизов в промышленную эксплуатацию. И все это в режиме интенсивного пилота, с обязательством создания MVP за 3-5 месяцев! Все в лучших традициях стартапов силиконовой долины.Команда и организация работТак как времени на найм с рынка новой команды под этот проект у нас не было, это была полностью волонтерская история. Мы привлекли 5 человек из разных Центров компетенции ДОМ.РФ, кому была интересна данная тема, на part-time, и создали таким образом команду на блокчейн. За несколько спринтов ребята реализовали процесс передачи файла ЭЗ от заявителя до Росреестра, а сам АРМ ЭЗ и сервис электронной регистрации создавала отдельная команда ЕИСЖС (5 человек).Технически сервис электронной регистрации представляет собой отдельный модуль, который размещается в контуре Росреестра, отдельно от ЕГРН. Интеграция двух систем была организована через отдельный API. Таким образом, весь пилот был сделан силами двух небольших agile-команд, взаимодействие которых было обеспечено совместными планированиями и обязательным system demo в конце каждого спринта.В периметре ДОМ.РФ был создан совместный тестовый контур, в котором мы разместили и тестовые системы Росреестра. За два спринта мы сделали смарт-контракт. Затем уже написали обертку – адаптер, в виде внешнего REST API. Проектировать решение мы начали в декабре 2020, а в мае 2021-го уже были готовы запускаться в эксплуатацию. О технических деталях реализации смарт-контракта читайте во 2-ой статье ""Технология блокчейн в Ипотеке (часть 2)"".Самый ценный инсайд по итогам данного пилота состоит в том, что при желании опытная команда может осилить даже такой на первый взгляд неподъемный проект на совершенно новой и еще «не обкатанной» на рынке технологии блокчейн. Нужно просто не бояться, вовлечь нужных участников, погрузиться в вопрос и сделать. И команда ДОМ.РФ это сделала.    Дальнейшие перспективыСейчас ведется проработка вопроса о внесении изменений в законодательство с целью юридической легализации нового альтернативного канала выпуска е-закладных. Это сдерживает запуск в промышленную эксплуатацию и масштабирование данного решения. Говоря про дальнейшие перспективы, надо отметить, что ипотека – это замкнутая экосистема, объединяющая застройщиков, покупателей, кредиторов, оценщиков и регистраторов, то есть представляет собой идеальную прикладную область для построения корпоративного блокчейн-решения. Дальнейшее развитие этой технологии позволит вовлечь в процесс всех участников этой системы и обеспечить полностью цифровую end-to-end ипотечную сделку."
